% 新添加内容
% 编译命令
% bitset操作
% 圆交多边形模板
% Powerful Number Sieve
% Min25 筛
% FWT
% Pohlig Hellman
% 拉格朗日插值
% 三四元环计数
% 杜教筛
% ISAP, HLPP
% 决策单调性分治
% 预处理离散对数
% Coppersmith & LLL
% LGV引理
% 圆反演

% 待添加内容
% 斯特林数(working)
% 群论(working)
% 正则表达式转前缀表达式...
% 闵科夫斯基和
% 线性筛完全体
% 带负权的dij版MCMF
% 基于值域预处理的快速 GCD
% Min_Max容斥
% 类欧几里得算法详解
% 多边形面积
% 模拟退火
% 大质数表
% 拟阵
% 舞蹈链

\documentclass{ctexart}
\usepackage{xeCJK}
\usepackage{multicol}   % 分栏
\usepackage[a4paper, inner=2cm, outer=2cm, top=2cm, bottom=2cm, bindingoffset=0cm]{geometry}
\usepackage{fancyhdr}
\usepackage[colorlinks=true]{hyperref}
% \usepackage[colorlinks=true]{}
\usepackage{zhnumber}   % 中文日期
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{appendix}

\lstset{
    basicstyle          =   \zihao{-5}\ttfamily,          % 基本代码风格
    keywordstyle        =   \zihao{-5}\bfseries,          % 关键字风格
    commentstyle        =   \zihao{-5}\rmfamily\slshape,  % 注释的风格，斜体
    stringstyle         =   \zihao{-5}\ttfamily,  % 字符串风格
    flexiblecolumns,                % 别问为什么，加上这个
    numbers             =   left,   % 行号的位置在左边
    showspaces          =   false,  % 是否显示空格，显示了有点乱，所以不现实了
    numberstyle         =   \zihao{-6}\ttfamily,    % 行号的样式，小五号，tt等宽字体
    showstringspaces    =   false,
    captionpos          =   t,      % 这段代码的名字所呈现的位置，t指的是top上面
    frame               =   lrtb,   % 显示边框
    breaklines          =   true,
    language            =   c++
}

\lstdefinestyle{Python}{
    language        =   Python, % 语言选Python
    basicstyle      =   \zihao{-5}\ttfamily,
    numberstyle     =   \zihao{-5}\ttfamily,
    keywordstyle    =   \color{blue},
    keywordstyle    =   [2] \color{teal},
    stringstyle     =   \color{magenta},
    commentstyle    =   \color{red}\ttfamily,
    breaklines      =   true,   % 自动换行，建议不要写太长的行
    columns         =   fixed,  % 如果不加这一句，字间距就不固定，很丑，必须加
    basewidth       =   0.5em,
}

\newtheorem{example}{例}
\newtheorem{solution}{解}
\newtheorem{algorithm}{算法}
\newtheorem{theorem}{定理}[section]  % 按 section 编号
\newtheorem{definition}{定义}
\newtheorem{axiom}{公理}
\newtheorem{property}{性质}
\newtheorem{proposition}{命题}
\newtheorem{lemma}{引理}
\newtheorem{corollary}{推论}
\newtheorem{remark}{注解}
\newtheorem{condition}{条件}
\newtheorem{conclusion}{结论}
\newtheorem{assumption}{假设}

\title{ACM Templates}
\date{\today}
\author{NamelessOIer}

\begin{document}

\maketitle
\setcounter{page}{0}
\thispagestyle{empty}
\newpage
\pagenumbering{roman}
\tableofcontents
\newpage
\pagenumbering{arabic}
\pagestyle{fancy}
\section{杂项}
\subsection{注意事项}
\begin{itemize}
    \item 最好不要乱改板子，除非卡常/题目需求
\end{itemize}
\subsection{读入优化}
\begin{lstlisting}
#define gc c=getchar()
#define r(x) read(x)
#define getchar() (frS==frT&&(frT=(frS=frBB)+fread(frBB,1,1<<12,stdin),frS==frT)?EOF:*frS++)
char frBB[1<<12],*frS=frBB,*frT=frBB;
// fread, may do not need.

template<typename T>
inline void read(T &x){
	x=0;T k=1;char gc;
	while(!isdigit(c)){if(c=='-')k=-1;gc;}
	while(isdigit(c)){x=x*10+c-'0';gc;}x*=k;
}

\end{lstlisting}
\subsection{输出优化}
\begin{lstlisting}   
template<typename T>
inline void write(const T &x){
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
\end{lstlisting}
\subsection{关闭流同步}
\begin{lstlisting}
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
// 如果编译开启了 C++11 或更高版本，建议使用 std::cin.tie(nullptr);
\end{lstlisting}
\subsection{文件读写}
\begin{lstlisting}
    freopen(".in","r",stdin);
    freopen(".out","w",stdout);
\end{lstlisting}
\subsection{fflush}
To flush the output buffer, you need to do the following immediately after the query output and the end-of-line character:
\begin{itemize}
    \item fflush(stdout) or cout.flush() in C ++;
    \item System.out.flush() in Java;
    \item flush(output) in Pascal;
    \item stdout.flush() in Python;
    \item see the documentation for other languages.
\end{itemize}
\section{数据结构}
\subsection{哈希表}
\begin{lstlisting}
const int N=999983;
struct Hash{
    int tot;
    int fir[N],nex[N],key[N],val[N];
    vector<int>vis;
    inline void clear(){
        for(int i=0;i<vis.size();++i){
            fir[vis[i]]=0;
        }
        vis.clear();
        tot=0;
    }

    inline void insert(int x,int v){
        int k=x%N;
        nex[++tot]=fir[k];
        key[tot]=x;
        val[tot]=v;
        if(!fir[k])(vis.push_back(k));
        fir[k]=tot;
    }

    inline int find(int x){
        int k=x%N;
        for(int i=fir[k];i;i=nex[i]){
            if(key[i]==x){
                return val[i];
            }
        }
        return -1;
    }
}mp;
\end{lstlisting}
\subsection{ST表}
\begin{lstlisting}
inline int STMin(const int &l,const int &r){
    int k=lg[r-l+1];
    return min(st[l][k],st[r-(1<<k)+1][k]);
}

inline void STinit(){
    for(int i=2;i<=n;++i){
        lg[i]=lg[i>>1]+1;
    }
    for(int j=1;j<=lg[n];++j){
        for(int i=1;i+(1<<(j-1))-1<=n;++i){
            st[i][j]=min(st[i][j-1],st[i+(1<<(j-1))][j-1]);
        }
    }
}
\end{lstlisting}
\subsection{虚树}
\begin{lstlisting}
int n,m;

struct Graph1{
    vector<int>G[N];
    
    inline void addedge(int u,int v){
        G[u].emplace_back(v);
        G[v].emplace_back(u);
    }

    int dfs_clock;
    int dfn[N];
    int dep[N];
    int ac[N][20];

    void dfs(int x,int f){
        dfn[x]=++dfs_clock;
        dep[x]=dep[f]+1;
        ac[x][0]=f;
        for(int i=1;(ac[x][i]=ac[ac[x][i-1]][i-1]);++i);
        for(auto v:G[x]){
            if(v==f)continue;
            dfs(v,x);
        }
    }

    inline int LCA(int u,int v){
        if(dep[u]<dep[v])swap(u,v);
        for(int i=19;~i;--i){
            if(dep[ac[u][i]]>=dep[v]){
                u=ac[u][i];
            }
        }
        if(u==v)return u;
        for(int i=19;~i;--i){
            if(ac[u][i]!=ac[v][i]){
                u=ac[u][i];
                v=ac[v][i];
            }
        }
        return ac[u][0];
    }

    inline void clear(){
        dfs_clock=0;
        for(int i=1;i<=n;++i){
            G[i].clear();
            for(int j=0;ac[i][j];++j)ac[i][j]=0;
        }
    }
}G1;


struct Graph2{
    vector<int>G[N];

    int tot;
    bool mark[N];
    int a[N];
    int sta[N];

    void dfs(int x,int f){
        a[++tot]=x;
        for(auto v:G[x]){
            dfs(v,x);
        }
    }

    inline void build(){
        G1.dfs(1,0);
        tot=0;
        mark[1]=1;
        for(int i=1;i<=n;++i){
            if(mark[i]){
                a[++tot]=i;
            }
        }
        sort(a+1,a+tot+1,[](const int &x,const int &y){return G1.dfn[x]<G1.dfn[y];});
        int top=1;
        sta[top]=1;
        for(int i=2;i<=tot;++i){
            int lca=G1.LCA(a[i],sta[top]);
            if(lca!=sta[top]){
                while(G1.dfn[lca]<G1.dfn[sta[top-1]]){
                    G[sta[top-1]].emplace_back(sta[top]);
                    --top;
                }
                if(lca==sta[top-1]){
                    G[lca].emplace_back(sta[top]);
                    --top;
                }
                else {
                    G[lca].emplace_back(sta[top]);
                    sta[top]=lca;
                }
            }
            sta[++top]=a[i];
        }
        for(int i=1;i<top;++i){
            G[sta[i]].emplace_back(sta[i+1]);
        }
        tot=0;
        dfs(1,0);
    }

    inline void clear(){
        for(int i=1;i<=tot;++i){
            G[a[i]].clear();
            mark[a[i]]=0;
        }
    }
}G2;
\end{lstlisting}
\subsection{树状数组}
\subsubsection{二维树状数组}
矩阵加，矩阵求和
\begin{lstlisting}
const int N=1005;

ll c1[N][N];
ll c2[N][N];
ll c3[N][N];
ll c4[N][N];
ll a[N][N];
int n,m;

inline void add(int x,int y,int d){
    for(int i=x;i<=n;i+=(i&(-i))){
        for(int j=y;j<=m;j+=(j&(-j))){
            c1[i][j]+=d;
            c2[i][j]+=d*x;
            c3[i][j]+=d*y;
            c4[i][j]+=d*x*y;
        }
    }
}

inline ll sum(int x,int y){
    ll ret=a[x][y];
    for(int i=x;i;i^=(i&(-i))){
        for(int j=y;j;j^=(j&(-j))){
            ret+=(x+1)*(y+1)*c1[i][j]-(y+1)*c2[i][j]-(x+1)*c3[i][j]+c4[i][j];
        }
    }
    return ret;
}

inline void ADD(int x0,int y0,int x1,int y1,int k){
    add(x0,y0,k);
    add(x1+1,y1+1,k);
    add(x0,y1+1,-k);
    add(x1+1,y0,-k);
}

inline ll SUM(int x0,int y0,int x1,int y1){
    return sum(x1,y1)-sum(x0-1,y1)-sum(x1,y0-1)+sum(x0-1,y0-1);
}
\end{lstlisting}
\subsubsection{树状数组平衡树操作}
P3369 【模板】普通平衡树
\begin{lstlisting}
const int N=2e5+7;

int opt[N],Q[N],c[N];

vector<int>Tmp;

inline int Hash(int x){
    return lower_bound(Tmp.begin(),Tmp.end(),x)-Tmp.begin()+1;
}

inline void Add(int x,int d){
    for(;x<=N;x+=x&(-x))c[x]+=d;
}

inline void Insert(int x){
    Add(x,1);
}

inline int Sum(int x){
    int ret=0;
    for(;x;x-=x&(-x))ret+=c[x];
    return ret;
}

inline void Erase(int x){
    Add(x,-1);
}

inline int Rank(int x){
    return Sum(x-1)+1;
}

inline int Kth(int k){
    int res=0;
    for(int i=17;~i;--i){
        res+=(1<<i);
        if(c[res]>=k)res-=(1<<i);
        else k-=c[res];
    }
    return Tmp[res];
}

int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
    int n;r(n);
    for(int i=1;i<=n;++i){
        r(opt[i]),r(Q[i]);
        if(opt[i]!=4)Tmp.push_back(Q[i]);
    }
    
    sort(Tmp.begin(),Tmp.end());
    
    unique(Tmp.begin(),Tmp.end())-Tmp.begin();
    
    for(int i=1;i<=n;++i){
        int x;
        if(opt[i]!=4)x=Hash(Q[i]);
        else x=Q[i];
        switch(opt[i]){
            case 1:Insert(x);break;
            case 2:Erase(x);break;
            case 3:printf("%d\n",Rank(x));break;
            case 4:printf("%d\n",Kth(x));break;
            case 5:printf("%d\n",Kth(Sum(x-1)));break;
            case 6:printf("%d\n",Kth(Sum(x)+1));break;
        }
    }
    return 0;
}
\end{lstlisting}
\subsubsection{树状数组可持久化平衡树操作}
P3835 【模板】可持久化平衡树
\begin{lstlisting}
const int N=5e5+7;

int opt[N],Q[N],c[N];

vector<int>Tmp,G[N];

inline int Hash(int x){
    return lower_bound(Tmp.begin(),Tmp.end(),x)-Tmp.begin()+1;
}

inline void Add(int x,int d){
    for(;x<=N;x+=x&(-x))c[x]+=d;
}

inline void Insert(int x){
    Add(x,1);
}

inline int Sum(int x){
    int ret=0;
    for(;x;x-=x&(-x))ret+=c[x];
    return ret;
}

inline void Erase(int x){
    Add(x,-1);
}

inline int Rank(int x){
    return Sum(x-1)+1;
}

inline int Kth(int k){
    int res=0;
    for(int i=18;~i;--i){
        res+=(1<<i);
        if(c[res]>=k)res-=(1<<i);
        else k-=c[res];
    }
    return Tmp[res];
}

int ans[N];

void dfs(int u){
    int x;
    bool flag;
    if(opt[u]!=4)x=Hash(Q[u]);
    else x=Q[u];
    switch(opt[u]){
        case 1:Insert(x);break;
        case 2:{
            flag=(Sum(x)!=Sum(x-1));
            if(flag)Erase(x);
            break;
        }
        case 3:ans[u]=Rank(x);break;
        case 4:ans[u]=Kth(x);break;
        case 5:ans[u]=Kth(Sum(x-1));break;
        case 6:ans[u]=Kth(Sum(x)+1);break;
    }
    for(int i=0;i<G[u].size();++i){
    	dfs(G[u][i]);
    }
    switch(opt[u]){
        case 1:Erase(x);break;
        case 2:if(flag)Insert(x);break;
    }
}

int main(){
    int n;r(n);
    for(int i=1;i<=n;++i){
        int ver;r(ver),r(opt[i]),r(Q[i]);
        if(opt[i]!=4)Tmp.push_back(Q[i]);
        G[ver].push_back(i);
    }
    
    sort(Tmp.begin(),Tmp.end());
    
    unique(Tmp.begin(),Tmp.end())-Tmp.begin();
    
    dfs(0);
    
    for(int i=1;i<=n;++i){
        if(opt[i]>2)printf("%d\n",ans[i]);
    }
    return 0;
}
\end{lstlisting}
\subsection{线段树}
\subsubsection{主席树}
P3402 【模板】可持久化并查集
\begin{lstlisting}
// luogu-judger-enable-o2
#include<bits/stdc++.h>

using namespace std;

#define gc c=getchar()
#define r(x) read(x)

template<typename T>
inline void read(T&x){
    x=0;T k=1;char gc;
    while(!isdigit(c)){if(c=='-')k=-1;gc;}
    while(isdigit(c)){x=x*10+c-'0';gc;}x*=k;
}

const int N=2e5+7;

int rt[N];
int id;

struct seg{int fa,dep,ls,rs;}tr[N<<5];

#define mid ((l+r)>>1)

inline int build(int l,int r){
    int rt=++id;
    if(l<r)tr[rt].ls=build(l,mid),tr[rt].rs=build(mid+1,r);
    else tr[rt].fa=l;
    return rt;
}

inline int update(int pre,int l,int r,int x,int v){
    int rt=++id;
    tr[rt]=tr[pre];
    if(l<r)x<=mid?tr[rt].ls=update(tr[pre].ls,l,mid,x,v):tr[rt].rs=update(tr[pre].rs,mid+1,r,x,v);
    else tr[rt].fa=v;
    return rt;
}

inline int query(int rt,int l,int r,int x){
    if(l<r)return x<=mid?query(tr[rt].ls,l,mid,x):query(tr[rt].rs,mid+1,r,x);
    else return rt;
    
}

inline void add(int rt,int l,int r,int x){
    if(l<r)x<=mid?add(tr[rt].ls,l,mid,x):add(tr[rt].rs,mid+1,r,x);
    else ++tr[rt].dep;
}

int n,m;

inline int find(int ver,int x){
    int f=query(rt[ver],1,n,x);
    return x==tr[f].fa?f:find(ver,tr[f].fa);
}

inline void uni(int ver,int a,int b){
    rt[ver]=rt[ver-1];
    int f1=find(ver,a);
    int f2=find(ver,b);
    if(tr[f1].fa==tr[f2].fa)return;
    if(tr[f1].dep<tr[f2].dep)swap(f1,f2);
    rt[ver]=update(rt[ver-1],1,n,tr[f2].fa,tr[f1].fa);
    if(tr[f1].dep==tr[f2].dep)add(rt[ver],1,n,tr[f1].fa);
}

inline void query(int ver,int a,int b){
    printf("%d\n",find(ver,a)==find(ver,b));
}

int main(){
    r(n);r(m);
    rt[0]=build(1,n);
    for(int i=1;i<=m;++i){
        int opt,a,b;
        r(opt);r(a);
        switch(opt){
            case 1:{
                r(b);
                uni(i,a,b);
                break;
            }
            case 2:{
                rt[i]=rt[a];
                break;
            }
            case 3:{
                r(b);
                rt[i]=rt[i-1];
                query(i,a,b);
                break;
            }
        }
    }
}
\end{lstlisting}
\subsubsection{线段树合并}
P3521 [POI2011]ROT-Tree Rotations
\begin{lstlisting}
#include<bits/stdc++.h>

using namespace std;

#define gc c=getchar()
#define r(x) read(x)
#define ll long long

template<typename T>
inline void read(T&x){
    x=0;T k=1;char gc;
    while(!isdigit(c)){if(c=='-')k=-1;gc;}
    while(isdigit(c)){x=x*10+c-'0';gc;}x*=k;
}

const int N=200005;

int ls[N*30];
int rs[N*30];
int siz[N*30];

int n,tot;

void insert(int &rt,int l,int r,int x){
	rt=++tot;
	++siz[rt];
	if(l==r)return;
	int mid=(l+r)>>1;
	if(x<=mid)insert(ls[rt],l,mid,x);
	else insert(rs[rt],mid+1,r,x);
}

ll ans1,ans2,ans;

int merge(int x,int y){
	if(!x||!y)return x|y;
	ans1+=(ll)siz[ls[x]]*siz[rs[y]];
	ans2+=(ll)siz[ls[y]]*siz[rs[x]];
	ls[x]=merge(ls[x],ls[y]);
	rs[x]=merge(rs[x],rs[y]);
	siz[x]+=siz[y];
	return x;
}

void solve(int &rt){
	int x;r(x);
	if(!x){
		int ls,rs;
		solve(ls);
		solve(rs);
		ans1=ans2=0;
		rt=merge(ls,rs);
		ans+=min(ans1,ans2);
	}
	else insert(rt,1,n,x);
}

int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	r(n);
	int t=0;
	solve(t);
	printf("%lld\n",ans);
	return 0;
}
\end{lstlisting}
\subsubsection{最值线段树}
\begin{lstlisting}
#include<bits/stdc++.h>

using namespace std;

#define gc c=getchar()
#define r(x) read(x)
#define ll long long

template<typename T>
inline void read(T&x){
    x=0;T k=1;char gc;
    while(!isdigit(c)){if(c=='-')k=-1;gc;}
    while(isdigit(c)){x=x*10+c-'0';gc;}x*=k;
}

const int INF=1e9;
const int N=5e5+7;

int a[N];

struct MaxInfo{
	int fir,sec,cnt,tag;
	
	inline MaxInfo(int _fir=-INF,int _sec=-INF,int _cnt=0,int _tag=0):fir(_fir),sec(_sec),cnt(_cnt),tag(_tag){}
	
	inline void operator += (int v){
		fir+=v;
		sec+=v;
	}

};

inline MaxInfo operator + (const MaxInfo &A,const MaxInfo &B){
	if(A.fir==B.fir)return MaxInfo(A.fir,max(A.sec,B.sec),A.cnt+B.cnt);
	if(A.fir<B.fir)return MaxInfo(B.fir,max(A.fir,B.sec),B.cnt);
	return MaxInfo(A.fir,max(B.fir,A.sec),A.cnt);
}

struct MinInfo{
	int fir,sec,cnt,tag;
	
	inline MinInfo(int _fir=INF,int _sec=INF,int _cnt=0,int _tag=0):fir(_fir),sec(_sec),cnt(_cnt),tag(_tag){}
	
	inline void operator += (int v){
		fir+=v;
		sec+=v;
	}

};

inline MinInfo operator + (const MinInfo &A,const MinInfo &B){
	if(A.fir==B.fir)return MinInfo(A.fir,min(A.sec,B.sec),A.cnt+B.cnt);
	if(A.fir>B.fir)return MinInfo(B.fir,min(A.fir,B.sec),B.cnt);
	return MinInfo(A.fir,min(B.fir,A.sec),A.cnt);
}

struct Node{
	MaxInfo mx;
	MinInfo mi;
	ll sum;
	int siz;
	int tag;
	
	inline Node (){
		tag=sum=0;
	}
	
	inline Node (int x){
		mx=MaxInfo(x,-INF,1);
		mi=MinInfo(x,INF,1);
		sum=x;
		siz=1;
	}
	
	inline Node (const MaxInfo &_mx,const MinInfo &_mi,ll _sum,int _siz,int _tag=0):mx(_mx),mi(_mi),sum(_sum),siz(_siz),tag(_tag){}
	
	inline void AddMax(int v){
		if(mx.fir==mi.fir){
			mi.fir+=v;
			tag+=v;
		}
		else {
			if(mx.fir==mi.sec){
				mi.sec+=v;
			}
			mx.tag+=v;
		}
		mx.fir+=v;
		sum+=(ll)mx.cnt*v;
	}
	
	inline void AddMin(int v){
		if(mi.fir==mx.fir){
			mx.fir+=v;
			tag+=v;
		}
		else {
			if(mi.fir==mx.sec){
				mx.sec+=v;
			}
			mi.tag+=v;
		}
		mi.fir+=v;
		sum+=(ll)mi.cnt*v;
	}
	
	inline void AddSeg(int v){
		mx+=v;
		mi+=v;
		tag+=v;
		sum+=(ll)siz*v;
	}

}tr[N<<2];

inline void print(int rt){
	puts("-------------------------------");
	printf("ID=%d\n",rt); 
	printf("Sum=%d\n",tr[rt].sum); 
	printf("Tag=%d\n",tr[rt].tag); 
	printf("MaxInfo=%d %d %d %d\n",tr[rt].mx.fir,tr[rt].mx.sec,tr[rt].mx.cnt,tr[rt].mx.tag); 
	printf("MinInfo=%d %d %d %d\n",tr[rt].mi.fir,tr[rt].mi.sec,tr[rt].mi.cnt,tr[rt].mi.tag); 
	puts("-------------------------------");
}

inline Node operator + (const Node &A,const Node &B){
	return Node(A.mx+B.mx,A.mi+B.mi,A.sum+B.sum,A.siz+B.siz);
}

#define ls (rt<<1)
#define rs (rt<<1|1)

inline void update(int rt){
	tr[rt]=tr[ls]+tr[rs];
}

inline void pushdown(int rt){
	Node &x=tr[rt];
	Node &l=tr[ls];
	Node &r=tr[rs];
	if(x.mx.tag){
		int mx=max(l.mx.fir,r.mx.fir);
		if(l.mx.fir==mx)l.AddMax(x.mx.tag);
		if(r.mx.fir==mx)r.AddMax(x.mx.tag);
		x.mx.tag=0;
	}
	if(x.mi.tag){
		int mi=min(l.mi.fir,r.mi.fir);
		if(l.mi.fir==mi)l.AddMin(x.mi.tag);
		if(r.mi.fir==mi)r.AddMin(x.mi.tag);
		x.mi.tag=0;
	}
	if(x.tag){
		l.AddSeg(x.tag);
		r.AddSeg(x.tag);
		x.tag=0;
	}
}

void build(int rt,int l,int r){
	if(l==r){
		tr[rt]=Node(a[l]);
		return ;
	}
	int mid=(l+r)>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
	update(rt);
}

void Min(int rt,int l,int r,int v){
	if(tr[rt].mx.fir<=v)return ;
	if(tr[rt].mx.sec<v){
		tr[rt].AddMax(v-tr[rt].mx.fir);
		return ;
	}
	int mid=(l+r)>>1;
	pushdown(rt);
	Min(ls,l,mid,v);
	Min(rs,mid+1,r,v);
	update(rt);
}

void Max(int rt,int l,int r,int v){
	if(tr[rt].mi.fir>=v)return ;
	if(tr[rt].mi.sec>v){
		tr[rt].AddMin(v-tr[rt].mi.fir);
		return ;
	}
	int mid=(l+r)>>1;
	pushdown(rt);
	Max(ls,l,mid,v);
	Max(rs,mid+1,r,v);
	update(rt);
}

void Work(int rt,int l,int r,int x,int y,int opt,int v){
	if(x<=l&&r<=y){
		switch(opt){
			case 1:return tr[rt].AddSeg(v);
			case 2:return Max(rt,l,r,v);
			case 3:return Min(rt,l,r,v);
		}
	}
	int mid=(l+r)>>1;
	pushdown(rt);
	if(x<=mid)Work(ls,l,mid,x,y,opt,v);
	if(y>mid)Work(rs,mid+1,r,x,y,opt,v);
	update(rt);
}

int QMax(int rt,int l,int r,int x,int y){
	if(x<=l&&r<=y)return tr[rt].mx.fir;
	int mid=(l+r)>>1;
	pushdown(rt);
	if(y<=mid)return QMax(ls,l,mid,x,y);
	else if(x>mid)return QMax(rs,mid+1,r,x,y);
	else return max(QMax(ls,l,mid,x,y),QMax(rs,mid+1,r,x,y));
}

int QMin(int rt,int l,int r,int x,int y){
	if(x<=l&&r<=y)return tr[rt].mi.fir;
	int mid=(l+r)>>1;
	pushdown(rt);
	if(y<=mid)return QMin(ls,l,mid,x,y);
	else if(x>mid)return QMin(rs,mid+1,r,x,y);
	else return min(QMin(ls,l,mid,x,y),QMin(rs,mid+1,r,x,y));
}

ll QSum(int rt,int l,int r,int x,int y){
	if(x<=l&&r<=y)return tr[rt].sum;
	int mid=(l+r)>>1;
	pushdown(rt);
	if(y<=mid)return QSum(ls,l,mid,x,y);
	else if(x>mid)return QSum(rs,mid+1,r,x,y);
	else return QSum(ls,l,mid,x,y)+QSum(rs,mid+1,r,x,y);
}

int main(){
	int n,m;r(n);
	for(int i=1;i<=n;++i)r(a[i]);
	build(1,1,n);
	for(r(m);m;--m){
		int opt,x,y,t;
		r(opt),r(x),r(y);
		if(opt<=3)r(t),Work(1,1,n,x,y,opt,t);
		else switch(opt){
			case 4:printf("%lld\n",QSum(1,1,n,x,y));break;
			case 5:printf("%d\n",QMax(1,1,n,x,y));break;
			case 6:printf("%d\n",QMin(1,1,n,x,y));break;
		}
	}
	return 0;
}
\end{lstlisting}
\subsubsection{历史线段树}
P4314 CPU监控
\begin{lstlisting}
#include<bits/stdc++.h>

using namespace std;

#define gc c=getchar()
#define r(x) read(x)
#define ll long long

template<typename T>
inline void read(T&x){
    x=0;T k=1;char gc;
    while(!isdigit(c)){if(c=='-')k=-1;gc;}
    while(isdigit(c)){x=x*10+c-'0';gc;}x*=k;
}
const int INF=INT_MAX/2;
const int N=1e5+7;

struct Tag{
	int a,b;
	
	inline Tag(int _a=0,int _b=-INF):a(_a),b(_b){}	
	
}null;

inline bool operator != (const Tag &A,const Tag &B){
	return A.a!=B.a||A.b!=B.b;
}

inline Tag operator + (const Tag &A,const Tag &B){
	return Tag(max(-INF,A.a+B.a),max(A.b+B.a,B.b));
}

inline Tag max(const Tag &A,const Tag &B){
	return Tag(max(A.a,B.a),max(A.b,B.b));
}

struct Node {
	int curmax,hismax;
	Tag curtag,histag;
}tr[N<<2];

inline void print(int rt){
	puts("------------------------------");
	printf("ID=%d\n",rt);
	printf("cur=%d\n",tr[rt].curmax);
	printf("his=%d\n",tr[rt].hismax);
	printf("curtag=%d %d\n",tr[rt].curtag.a,tr[rt].curtag.b);
	printf("histag=%d %d\n",tr[rt].histag.a,tr[rt].histag.b);
	puts("------------------------------");
}

int a[N];

inline int calc(const int &x,const Tag &F){
	return max(x+F.a,F.b);
}

#define ls (rt<<1)
#define rs (rt<<1|1)

inline void update(int rt){
	tr[rt].curmax=max(tr[ls].curmax,tr[rs].curmax);
	tr[rt].hismax=max(tr[ls].hismax,tr[rs].hismax);
}

inline void pushdown(int rt){
	if(tr[rt].histag!=null){
		tr[ls].hismax=max(tr[ls].hismax,calc(tr[ls].curmax,tr[rt].histag));
		tr[rs].hismax=max(tr[rs].hismax,calc(tr[rs].curmax,tr[rt].histag));
		tr[ls].histag=max(tr[ls].histag,tr[ls].curtag+tr[rt].histag);
		tr[rs].histag=max(tr[rs].histag,tr[rs].curtag+tr[rt].histag);
		tr[rt].histag=null;
	}
	if(tr[rt].curtag!=null){
		tr[ls].curmax=calc(tr[ls].curmax,tr[rt].curtag);
		tr[rs].curmax=calc(tr[rs].curmax,tr[rt].curtag);
		tr[ls].curtag=tr[ls].curtag+tr[rt].curtag;
		tr[rs].curtag=tr[rs].curtag+tr[rt].curtag;
		tr[rt].curtag=null;
	}
}

void build(int rt,int l,int r){
	if(l==r){
		tr[rt].curmax=a[l];
		tr[rt].hismax=a[l];
		return ;
	}
	int mid=(l+r)>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
	update(rt);
}

void Modify(int rt,int l,int r,int x,int y,const Tag &A){
	if(x<=l&&r<=y){
		tr[rt].curmax=calc(tr[rt].curmax,A);
		tr[rt].curtag=tr[rt].curtag+A;
		tr[rt].hismax=max(tr[rt].hismax,tr[rt].curmax);
		tr[rt].histag=max(tr[rt].histag,tr[rt].curtag);
		return ;
	}
	pushdown(rt);
	int mid=(l+r)>>1;
	if(x<=mid)Modify(ls,l,mid,x,y,A);
	if(y>mid)Modify(rs,mid+1,r,x,y,A);
	update(rt);
}
		
int QMax(int rt,int l,int r,int x,int y){
	if(x<=l&&r<=y)return tr[rt].curmax;
	pushdown(rt);
	int mid=(l+r)>>1;
	if(y<=mid)return QMax(ls,l,mid,x,y);
	if(x>mid)return QMax(rs,mid+1,r,x,y);
	return max(QMax(ls,l,mid,x,y),QMax(rs,mid+1,r,x,y));
}
		
int QHis(int rt,int l,int r,int x,int y){
	if(x<=l&&r<=y)return tr[rt].hismax;
	pushdown(rt);
	int mid=(l+r)>>1;
	if(y<=mid)return QHis(ls,l,mid,x,y);
	if(x>mid)return QHis(rs,mid+1,r,x,y);
	return max(QHis(ls,l,mid,x,y),QHis(rs,mid+1,r,x,y));
}

inline char GetChar(){
	char gc;
	while(c!='Q'&&c!='A'&&c!='P'&&c!='C')gc;
	return c;
}

int main(){
	int n;r(n);
	for(int i=1;i<=n;++i){
		r(a[i]);
	}
	build(1,1,n);
	int m;r(m);
	while(m--){
		char opt=GetChar();
		int x,y,z;r(x),r(y);
		switch(opt){
			case 'Q':printf("%d\n",QMax(1,1,n,x,y));break;
			case 'A':printf("%d\n",QHis(1,1,n,x,y));break;
			case 'P':r(z),Modify(1,1,n,x,y,Tag(z,-INF));break;
			case 'C':r(z),Modify(1,1,n,x,y,Tag(-INF,z));break;
		}
	}
	return 0;
}
\end{lstlisting}
\subsection{KD-Tree}
\subsubsection{静态KD-Tree}
P4475 巧克力王国
\begin{lstlisting}
struct Node{
	int ch[2];
	int h;
	int mx[D],mi[D],A[D];
	ll sum;
}tr[N];

inline void update(int rt){
	int ls=tr[rt].ch[0];
	int rs=tr[rt].ch[1];
	for(int i=0;i<D;++i)tr[rt].mx[i]=tr[rt].mi[i]=tr[rt].A[i];
	tr[rt].sum=tr[rt].h;
	if(ls){
		for(int i=0;i<D;++i)tr[rt].mx[i]=max(tr[rt].mx[i],tr[ls].mx[i]);
		for(int i=0;i<D;++i)tr[rt].mi[i]=min(tr[rt].mi[i],tr[ls].mi[i]);
		tr[rt].sum+=tr[ls].sum;
	}
	if(rs){
		for(int i=0;i<D;++i)tr[rt].mx[i]=max(tr[rt].mx[i],tr[rs].mx[i]);
		for(int i=0;i<D;++i)tr[rt].mi[i]=min(tr[rt].mi[i],tr[rs].mi[i]);
		tr[rt].sum+=tr[rs].sum;
	}
}

inline bool cmp0(const Node &a,const Node &b){
	return a.A[0]<b.A[0];
}

inline bool cmp1(const Node &a,const Node &b){
	return a.A[1]<b.A[1];
}

inline void build(int &rt,int l,int r,int d){
	if(l>r){
		rt=0;
		return ;
	}
	rt=(l+r)>>1;
	if(d==0)nth_element(tr+l,tr+rt,tr+r+1,cmp0);
	else nth_element(tr+l,tr+rt,tr+r+1,cmp1);
	build(tr[rt].ch[0],l,rt-1,d^1);
	build(tr[rt].ch[1],rt+1,r,d^1);
	update(rt);
}

ll A,B,C;

inline int check(const Node &a){
	int ret=0;
	ret+=(A*a.mi[0]+B*a.mi[1]<C);
	ret+=(A*a.mi[0]+B*a.mx[1]<C);
	ret+=(A*a.mx[0]+B*a.mi[1]<C);
	ret+=(A*a.mx[0]+B*a.mx[1]<C);
	return ret;
}

inline ll query(int rt){
	if(!rt)return 0;
	int tmp=check(tr[rt]);
	if(!tmp)return 0;
	if(tmp==4)return tr[rt].sum;
	return tr[rt].h*(A*tr[rt].A[0]+B*tr[rt].A[1]<C)+query(tr[rt].ch[0])+query(tr[rt].ch[1]);
}
\end{lstlisting}
\subsubsection{动态加点KD-Tree}
P4148 简单题
\begin{lstlisting}
struct Point{
	int A[2];
	
	inline Point(){}
	inline Point(int x,int y){
		A[0]=x,A[1]=y;
	}
	
	inline int & operator [](const int &x){
		return A[x];
	}
	
	inline const int & operator [](const int &x)const{
		return A[x];
	}
};

struct Node{
	int val,sum;
	int ch[2],siz;
	Point mx,mi,A;
	
	inline void init(const Point &P,int v){
		siz=1;
		val=sum=v;
		mx=mi=A=P;
		ch[0]=ch[1]=0;
	}
	
}tr[N];

int tot;
int can[N],top;

inline int NewNode(const Point &A,int v){
	int x=top?can[top--]:++tot;
	tr[x].init(A,v);
	return x;
}

#define ls tr[rt].ch[0]
#define rs tr[rt].ch[1]

inline void update(int rt){
	tr[rt].mi=tr[rt].mx=tr[rt].A;
	tr[rt].sum=tr[rt].val;
	tr[rt].siz=1;
	if(ls){
		if(tr[ls].mi[0]<tr[rt].mi[0])tr[rt].mi[0]=tr[ls].mi[0];
		if(tr[ls].mx[0]>tr[rt].mx[0])tr[rt].mx[0]=tr[ls].mx[0];
		if(tr[ls].mi[1]<tr[rt].mi[1])tr[rt].mi[1]=tr[ls].mi[1];
		if(tr[ls].mx[1]>tr[rt].mx[1])tr[rt].mx[1]=tr[ls].mx[1];
		tr[rt].sum+=tr[ls].sum;
		tr[rt].siz+=tr[ls].siz;
	}
	if(rs){
		if(tr[rs].mi[0]<tr[rt].mi[0])tr[rt].mi[0]=tr[rs].mi[0];
		if(tr[rs].mx[0]>tr[rt].mx[0])tr[rt].mx[0]=tr[rs].mx[0];
		if(tr[rs].mi[1]<tr[rt].mi[1])tr[rt].mi[1]=tr[rs].mi[1];
		if(tr[rs].mx[1]>tr[rt].mx[1])tr[rt].mx[1]=tr[rs].mx[1];
		tr[rt].sum+=tr[rs].sum;
		tr[rt].siz+=tr[rs].siz;
	}
} 

#define alpha 0.65

typedef pair<Point,int> Data;

int D,cnt;
Data tmp[N];

inline bool cmp(const Data &a,const Data &b){
	return a.first[D]<b.first[D];
}

void rebuild(int &rt,int l,int r,int d){
	if(l>r)return ;
	int mid=(l+r)>>1;
	D=d;nth_element(tmp+l,tmp+mid,tmp+r+1,cmp);
	rt=NewNode(tmp[mid].first,tmp[mid].second);
	rebuild(ls,l,mid-1,d^1);
	rebuild(rs,mid+1,r,d^1);
	update(rt);
}

void dfs(int rt){
	if(!rt)return ;
	dfs(ls);
	tmp[++cnt]=make_pair(tr[rt].A,tr[rt].val);
	can[++top]=rt;
	dfs(rs);
}

inline void check(int &rt,bool d){
	if(tr[rt].siz*alpha<tr[ls].siz||tr[rt].siz*alpha<tr[rs].siz){
		cnt=0;
		dfs(rt);
		rebuild(rt,1,cnt,d);
	}
}

void insert(int &rt,const Point &A,int v,bool d){
	if(!rt){
		rt=NewNode(A,v);
		return ;
	}
	if(A[d]<=tr[rt].A[d])insert(ls,A,v,d^1);
	else insert(rs,A,v,d^1);
	update(rt);
	check(rt,d);
}

inline int relation(const Node &x,int xl,int xr,int yl,int yr){
	if(x.mx[0]<xl||x.mi[0]>xr||x.mx[1]<yl||x.mi[1]>yr)return 0;
	if(x.mx[0]<=xr&&x.mi[0]>=xl&&x.mx[1]<=yr&&x.mi[1]>=yl)return 1;
	if(x.A[0]<=xr&&x.A[0]>=xl&&x.A[1]<=yr&&x.A[1]>=yl)return 2;
	return 3;
}

int query(int rt,int xl,int xr,int yl,int yr){
	if(!rt)return 0;
	switch(relation(tr[rt],xl,xr,yl,yr)){
		case 0:return 0;
		case 1:return tr[rt].sum;
		case 2:return tr[rt].val+query(ls,xl,xr,yl,yr)+query(rs,xl,xr,yl,yr);
		default:return query(ls,xl,xr,yl,yr)+query(rs,xl,xr,yl,yr);
	}
}
\end{lstlisting}
\subsection{莫队}
\subsubsection{普通莫队}
\begin{lstlisting}
#include<bits/stdc++.h>

using namespace std;

#define gc c=getchar()
#define r(x) read(x)
#define ll long long

template<typename T>
inline void read(T&x){
    x=0;T k=1;char gc;
    while(!isdigit(c)){if(c=='-')k=-1;gc;}
    while(isdigit(c)){x=x*10+c-'0';gc;}x*=k;
}

const int N=2e5+7;
const int S=450;
int n,m;
int a[N];
int be[N];
int cnt[N];
int Ans[N];
int sum[N];

inline void work(int pos,int d){
	if(a[pos]>n)return ;
	if(d==1){
		cnt[a[pos]]++;
		if(cnt[a[pos]]==1)sum[a[pos]/S]++;
	}
	else {
		cnt[a[pos]]--;
		if(cnt[a[pos]]==0)sum[a[pos]/S]--;
	} 
}

inline int calc(){
	for(int i=0;i<S;i++){
		if(sum[i]<S){
			for(int j=0;j<S;++j){
				if(!cnt[i*S+j])return i*S+j;
			}
		}
	}
}

struct Query{
	int l,r,id;
	inline bool operator < (const Query &a)const{
		return be[l]==be[a.l]?r<a.r:l<a.l;
	}
}Q[N];

int main(){
    // freopen("forest.in","r",stdin);
    // freopen("forest.out","w",stdout);
    r(n),r(m);
    int size=sqrt(n);
    for(int i=1;i<=n;++i){
    	be[i]=(i-1)/size+1;
    	r(a[i]);
    }
    for(int i=1;i<=m;++i){
    	r(Q[i].l),r(Q[i].r);
    	Q[i].id=i;
    }
    sort(Q+1,Q+m+1);
    int l=1,r=0;
    for(int i=1;i<=m;++i){
    	Query &x=Q[i];
    	while(r>Q[i].r)work(r--,-1);
    	while(r<Q[i].r)work(++r,1);
    	while(l>Q[i].l)work(--l,1);
    	while(l<Q[i].l)work(l++,-1);
    	Ans[x.id]=calc();
    }
    for(int i=1;i<=m;++i){
    	printf("%d\n",Ans[i]);
    }
}
\end{lstlisting}
\subsubsection{回滚莫队}
BZOJ4241 历史研究
\begin{lstlisting}
#include<bits/stdc++.h>

using namespace std;

#define gc c=getchar()
#define r(x) read(x)
#define ll long long

template<typename T>
inline void read(T&x){
    T k=1;char gc;
    while(!isdigit(c)){if(c=='-')k=-1;gc;}
    while(isdigit(c))x=x*10+c-'0',gc;x*=k;
}

const int N=1e5+7;
const int S=320;

int a[N];
int be[N];
int val[N];
int cnt[N];
ll Ans[N];
int L[S];
int R[S];

struct Query{
    int l,r,id;
    inline bool operator < (const Query &a)const{
        return be[l]==be[a.l]?r<a.r:l<a.l;
    }
}Q[N];

int n,q;
ll ans;

inline void add(int x){
    cnt[x]++;
    ans=max(ans,(ll)cnt[x]*val[x]);
}

inline void del(int x){
    cnt[x]--;
}

int tmp[N];

inline ll solve(int l,int r){
    ll ret=0;
    for(int i=l;i<=r;++i)tmp[a[i]]=0;
    for(int i=l;i<=r;++i)tmp[a[i]]++;
    for(int i=l;i<=r;++i)ret=max(ret,(ll)tmp[a[i]]*val[a[i]]);
    return ret;
}

inline void Get(int x,int &i){
    int l=R[x]+1,r=R[x];
    memset(cnt+1,0,n<<2);
    for(ans=0;be[Q[i].l]==x;++i){
        if(be[Q[i].r]==x){
            Ans[Q[i].id]=solve(Q[i].l,Q[i].r);
            continue;
        }
        while(r<Q[i].r)add(a[++r]);
        ll t=ans;
        while(l>Q[i].l)add(a[--l]);
        Ans[Q[i].id]=ans;
        while(l<R[x]+1)del(a[l++]);
        ans=t;
    }
}

int main(){
    r(n),r(q);
    const int SIZE=sqrt(n);
    for(int i=1;i<=n;++i){
        r(a[i]);
        be[i]=(i-1)/SIZE+1;
        if(!L[be[i]])L[be[i]]=i;
        R[be[i]]=i;
        val[i]=a[i];
    }
    sort(val+1,val+n+1);
    for(int i=1;i<=n;++i){
        a[i]=lower_bound(val+1,val+n+1,a[i])-val;
    }
    for(int i=1;i<=q;++i){
        r(Q[i].l),r(Q[i].r);
        Q[i].id=i;
    }
    sort(Q+1,Q+q+1);
    for(int i=1,x=1;i<=q;++x){
        Get(x,i);
    }
    for(int i=1;i<=q;++i){
        printf("%lld\n",Ans[i]);
    }
}
\end{lstlisting}
\subsection{线性基}
\subsubsection{普通线性基}
\begin{lstlisting}
inline void insert(ll x){
    for(int i=N-1;~i;--i){
        if(!(x>>i))continue;
        if(!a[i])a[i]=x;
        x^=a[i];
    }
}
\end{lstlisting}
\subsubsection{离线带删线性基}
\begin{lstlisting}
const int N=3e5+7;
const int SIZE=64;

int Time[SIZE];
ull Basis[SIZE];

inline void Insert(ull x,int ddl){
    for(int i=SIZE-1;~i;--i){
        if(!(x>>i))continue;
        if(Time[i]<ddl){
            swap(Time[i],ddl);
            swap(x,Basis[i]);
        }
        if(!x)return ;
        x^=Basis[i];
    }
}

inline ull Query(int ddl){
    ull x=0;
    for(int i=SIZE-1;~i;--i){
        if(Time[i]>ddl && (Basis[i]^x)>x){
            x^=Basis[i];
        }
    }
    return x;
}

bool opt[N];
ull x[N];
ull Val[N];

int cnt[N];
int L[N];
int R[N];
ull num[N];

int main(){
    int n;r(n);
    for(int i=1;i<=n;++i){
        r(opt[i]),r(x[i]);
        Val[i]=x[i];
    }
    sort(Val+1,Val+n+1);
    int m=unique(Val+1,Val+n+1)-Val-1;
    for(int i=1;i<=n;++i){
        x[i]=lower_bound(Val+1,Val+m+1,x[i])-Val;
    }
    for(int i=1;i<=n;++i){
        if(opt[i]){
            if(!--cnt[x[i]]){
                num[L[x[i]]]=Val[x[i]];
                R[L[x[i]]]=i;
            }
        }
        else {
            if(!cnt[x[i]]++){
                L[x[i]]=i;
            }
        }
    }
    for(int i=1;i<=m;++i){
        if(cnt[i]){
            num[L[i]]=Val[i];
            R[L[i]]=n+1;
        }
    }
    for(int i=1;i<=n;++i){
        if(R[i]){
            Insert(num[i],R[i]);
        }
        printf("%llu\n",Query(i));
    }
    return 0;
}
\end{lstlisting}
\subsection{平衡树}
\subsubsection{FHQ-Treap}
P3369 【模板】普通平衡树
\begin{lstlisting}
struct fhq_Treap{
    int siz[N],ch[N][2],val[N],key[N];
    int tot,root;
    
    #define ls ch[rt][0]
    #define rs ch[rt][1]
    
    inline void update(int rt){
        siz[rt]=siz[ls]+siz[rs]+1;
    }
    
    void split(int rt,int k,int &x,int &y){
        if(!rt){
            x=y=0;
            return;
        }
        if(val[rt]<=k)x=rt,split(rs,k,rs,y);
        else y=rt,split(ls,k,x,ls);
        update(rt);
    }
    
    int merge(int x,int y){
        if(!x)return y;
        if(!y)return x;
        if(key[x]<key[y]){
            ch[x][1]=merge(ch[x][1],y);
            update(x);
            return x;
        }
        else {
            ch[y][0]=merge(x,ch[y][0]);
            update(y);
            return y;
        }
    }
    
    inline int New_Node(int k){
        siz[++tot]=1;
        val[tot]=k;
        key[tot]=rand();
        return tot;
    }
    
    inline void Insert(int k){
        int x,y;
        split(root,k,x,y);
        root=merge(merge(x,New_Node(k)),y);
    }
    
    inline void Erase(int k){
        int x,y,z;
        split(root,k,x,y);
        split(x,k-1,x,z);
        root=merge(x,merge(merge(ch[z][0],ch[z][1]),y));
    }
    
    inline int Rank(int k){
        int x,y;
        split(root,k-1,x,y);
        int ans=siz[x]+1;
        root=merge(x,y);
        return ans;
    }
    
    inline int Kth(int k){
        for(int rt=root;;){
            if(siz[ls]>=k)rt=ls;
            else if(siz[ls]+1<k)k-=siz[ls]+1,rt=rs;
            else return val[rt];
        }
    }
    
    inline int Pre(int k){
        int x;
        split(root,k-1,root,x);
        int ans=Kth(siz[root]);
        root=merge(root,x);
        return ans;
    }
    
    inline int Suc(int k){
        int x;
        split(root,k,x,root);
        int ans=Kth(1);
        root=merge(x,root);
        return ans;
    }
        
}Treap;
\end{lstlisting}
P3391 【模板】文艺平衡树
\begin{lstlisting}
struct fhq_Treap{
    int siz[N],ch[N][2],val[N],key[N];
    int tot,root;
    bool rev[N];
    
    #define ls ch[rt][0]
    #define rs ch[rt][1]
    
    inline void update(int rt){
        siz[rt]=siz[ls]+siz[rs]+1;
    }
    
    inline void pushdown(int rt){
        if(rev[rt]){
            rev[ls]^=1;
            rev[rs]^=1;
            swap(ls,rs);
            rev[rt]=0;
        }
    }
        
    
    void split(int rt,int k,int &x,int &y){
        if(!rt){
            x=y=0;
            return;
        }
        pushdown(rt);
        if(siz[ls]<k)x=rt,split(rs,k-siz[ls]-1,rs,y);
        else y=rt,split(ls,k,x,ls);
        update(rt);
    }
    
    int merge(int x,int y){
        if(!x)return y;
        if(!y)return x;
        if(key[x]<key[y]){
            pushdown(x);
            ch[x][1]=merge(ch[x][1],y);
            update(x);
            return x;
        }
        else {
            pushdown(y);
            ch[y][0]=merge(x,ch[y][0]);
            update(y);
            return y;
        }
    }
    
    inline int New_Node(int k){
        siz[++tot]=1;
        val[tot]=k;
        key[tot]=rand();
        return tot;
    }
    
    inline void Insert(int x){
        root=merge(root,New_Node(x));
    }
    
    inline void Reverse(int l,int r){
        int x,y,z;
        split(root,l-1,x,y);
        split(y,r-l+1,y,z);
        rev[y]^=1;
        root=merge(x,merge(y,z));
    }
    
    inline void Out_Mid(int rt){
        if(!rt)return;
        pushdown(rt);
        Out_Mid(ls);
        printf("%d ",val[rt]);
        Out_Mid(rs);
    }
    
}Treap;
\end{lstlisting}
P3835 【模板】可持久化平衡树
\begin{lstlisting}
struct fhq_Treap{
    struct Node{
        int siz,ch[2],val,key;
        
        inline void New(int k){
            siz=1;
            val=k;
            key=rand();
        }
        
    }tr[N*50];
    
    int tot;
    
    #define ls ch[0]
    #define rs ch[1]
    
    inline void update(int rt){
        tr[rt].siz=tr[tr[rt].ls].siz+tr[tr[rt].rs].siz+1;
    }
    
    inline int New_Node(int k){
        tr[++tot].New(k);
        return tot;
    }
    
    inline int Copy_Node(int x){
        tr[++tot]=tr[x];
        return tot;
    }
    
    void split(int rt,int k,int &x,int &y){
        if(!rt){
            x=y=0;
            return;
        }
        if(tr[rt].val<=k){
            x=Copy_Node(rt);
            split(tr[x].rs,k,tr[x].rs,y);
            update(x);
        }
        else {
            y=Copy_Node(rt);
            split(tr[y].ls,k,x,tr[y].ls);
            update(y);
        }
    }
    
    int merge(int x,int y){
        if(!x||!y)return x+y;
        if(tr[x].key<tr[y].key){
            tr[x].rs=merge(tr[x].rs,y);
            update(x);
            return x;
        }
        else {
            tr[y].ls=merge(x,tr[y].ls);
            update(y);
            return y;
        }
    }
    
    inline void Insert(int &root,int k){
        int x,y;
        split(root,k,x,y);
        root=merge(merge(x,New_Node(k)),y);
    }
    
    inline void Erase(int &root,int k){
        int x,y,z;
        split(root,k,x,y);
        split(x,k-1,x,z);
        root=merge(x,merge(merge(tr[z].ls,tr[z].rs),y));
    }
    
    inline int Rank(int &root,int k){
        int x,y;
        split(root,k-1,x,y);
        int ans=tr[x].siz+1;
        root=merge(x,y);
        return ans;
    }
    
    inline int Kth(int &root,int k){
        for(int rt=root;;){
            if(tr[tr[rt].ls].siz>=k)rt=tr[rt].ls;
            else if(tr[tr[rt].ls].siz+1<k)k-=tr[tr[rt].ls].siz+1,rt=tr[rt].rs;
            else return tr[rt].val;
        }
    }
    
    inline int Pre(int &root,int k){
        int x;
        split(root,k-1,root,x);
        int ans=tr[root].siz?Kth(root,tr[root].siz):-2147483647;
        root=merge(root,x);
        return ans;
    }
    
    inline int Suc(int &root,int k){
        int x;
        split(root,k,x,root);
        int ans=tr[root].siz?Kth(root,1):-2147483647;
        root=merge(x,root);
        return ans;
    }
        
}Treap;
\end{lstlisting}
P5055 【模板】可持久化文艺平衡树
\begin{lstlisting}
struct fhq_Treap{
    struct Node{
        int siz,key,val,ls,rs;
        ll sum;
        bool rev;
        
        inline void New(int k){
            siz=1;
            sum=val=k;
            key=rand();
            ls=rs=0;
            rev=0;
        }
        
    }tr[N*80];
    
    int tot;
    
    inline int New_Node(int k){
        tr[++tot].New(k);
        return tot;
    }
    
    inline int Copy_Node(int x){
        tr[++tot]=tr[x];
        return tot;
    }
    
    inline void update(int x){
        Node & T=tr[x];
        T.siz=tr[T.ls].siz+tr[T.rs].siz+1;
        T.sum=tr[T.ls].sum+tr[T.rs].sum+T.val;
    }
    
    inline void pushdown(int x){
        Node & T=tr[x];
        if(!T.rev)return;
        if(T.ls)T.ls=Copy_Node(T.ls),tr[T.ls].rev^=1;
        if(T.rs)T.rs=Copy_Node(T.rs),tr[T.rs].rev^=1;
        swap(T.ls,T.rs);
        T.rev=0;
    }
    
    inline void split(int rt,int k,int &x,int &y){
        if(!rt){
            x=y=0;
            return;
        }
        pushdown(rt);
        Node &T=tr[rt];
        if(tr[T.ls].siz<k){
            x=Copy_Node(rt);
            split(tr[x].rs,k-tr[T.ls].siz-1,tr[x].rs,y);
            update(x);
        }
        else {
            y=Copy_Node(rt);
            split(tr[y].ls,k,x,tr[y].ls);
            update(y);
        }
    }
    
    inline int merge(int x,int y){
        if(!x||!y)return x^y;
        if(tr[x].key<tr[y].key){
            pushdown(x);
            tr[x].rs=merge(tr[x].rs,y);
            update(x);
            return x;
        }
        else {
            pushdown(y);
            tr[y].ls=merge(x,tr[y].ls);
            update(y);
            return y;
        }
    }
    
    inline void Insert(int &rt,int p,int k){
        int x,y;
        split(rt,p,x,y);
        rt=merge(merge(x,New_Node(k)),y);
    }
    
    inline void Erase(int &rt,int p){
        int x,y,z;
        split(rt,p,x,y);
        split(x,p-1,x,z);
        rt=merge(x,y);
    }
    
    inline void Reverse(int &rt,int l,int r){
        int x,y,z;
        split(rt,r,x,z);
        split(x,l-1,x,y);
        tr[y].rev^=1;
        rt=merge(merge(x,y),z);
    }
    
    inline ll Sum(int &rt,int l,int r){
        int x,y,z;
        split(rt,r,x,z);
        split(x,l-1,x,y);
        ll ans=tr[y].sum;
        rt=merge(merge(x,y),z);
        return ans;
    }
    
}Treap;
\end{lstlisting}
\subsubsection{Splay}
P3369 【模板】普通平衡树
\begin{lstlisting}
struct Splay{
	struct Node{
		int fa,ch[2];
		int val;
		int cnt;
		int siz;
	}tr[N],null;
	
	int tot;
	int can[N],top;
	int root;
	
	inline void update(int x){
		if(!x)tr[x]=null;
		else tr[x].siz=tr[tr[x].ch[0]].siz+tr[tr[x].ch[1]].siz+tr[x].cnt;
	}
	
	inline bool relation(int x){
		return x==tr[tr[x].fa].ch[1];
	}
	
	inline void connect(int x,int f,bool d){
		tr[x].fa=f;
		tr[f].ch[d]=x;
	}
	
	inline void rotate(int x){
		int  f=tr[x].fa;
		int  g=tr[f].fa;
		bool dx=relation(x);
		bool df=relation(f);
		int  s=tr[x].ch[dx^1];
		
		connect(x,g,df);
		connect(s,f,dx);
		connect(f,x,dx^1);
		
		update(f);
		update(x);
		update(g);
		
		if(!g)root=x;
	}
	
	inline void splay(int x,int target=0){
		for(int f=tr[x].fa;(f=tr[x].fa)!=target;rotate(x)){
			if(tr[f].fa!=target)rotate(relation(x)==relation(f)?f:x);
		}
	}
	
	inline int find(int k){
		for(int x=root;x;x=tr[x].ch[tr[x].val<k]){
			if(tr[x].val==k)return x;
		}
		//assert(0);
		return -1;
	}
	
	inline int Pre_Node(int k){
		splay(find(k));
		int x=tr[root].ch[0];
		while(tr[x].ch[1])x=tr[x].ch[1];
		return x;
	}
	
	inline int Suc_Node(int k){
		splay(find(k));
		int x=tr[root].ch[1];
		while(tr[x].ch[0])x=tr[x].ch[0];
		return x;
	}
	
	inline int New_Node(int k){
		int x=top?can[top--]:++tot;
		tr[x].siz=1;
		tr[x].cnt=1;
		tr[x].val=k;
		return x;
	}
	
	inline void Del_Node(int x){
		tr[tr[x].fa].ch[relation(x)]=0;
		update(tr[x].fa);
		can[++top]=x;
		tr[x]=null;
	}
	
	inline void Insert(int k){
		if(!root){
			root=New_Node(k);
			return ;
		}
		int x=root;
		while(1){
			++tr[x].siz;
			if(tr[x].val==k){
				++tr[x].cnt;
				break;
			}
			else {
				bool d=k>tr[x].val;
				if(tr[x].ch[d])x=tr[x].ch[d];
				else {
					connect(New_Node(k),x,d);
					x=tr[x].ch[d];
					break;
				}
			}
		}
		splay(x);
	}
	
	inline void Erase(int k){
		int pre=Pre_Node(k);
		int suc=Suc_Node(k);
		splay(pre);
		splay(suc,pre);
		int x=tr[suc].ch[0];
		assert(tr[x].val==k);
		if(tr[x].cnt>1){
			tr[x].cnt--;
			tr[x].siz--;
			splay(x);
			return ;
		}
		Del_Node(x);
		splay(suc);
	}
	
	inline int Rank(int k){
		int x=Pre_Node(k);
		splay(x);
		return tr[tr[x].ch[0]].siz+tr[x].cnt+1;
	}
	
	inline int Kth(int k){
		for(int x=root;;){
			if(tr[tr[x].ch[0]].siz+tr[x].cnt<k)k-=(tr[tr[x].ch[0]].siz+tr[x].cnt),x=tr[x].ch[1];
			else if(tr[tr[x].ch[0]].siz>=k)x=tr[x].ch[0];
			else return tr[x].val;
		}
		assert(0);
		return -1;
	}
	
	inline int Pre(int k){
		Insert(k);
		int x=Pre_Node(k);
		Erase(k);
		return tr[x].val;
	}
	
	inline int Suc(int k){
		Insert(k);
		int x=Suc_Node(k);
		Erase(k);
		return tr[x].val;
	}
	
}tr;
\end{lstlisting}
P3391 【模板】文艺平衡树
\begin{lstlisting}
struct Splay{
	struct Node{
		int fa,ch[2];
		int val;
		int siz;
		bool tag;
	}tr[N],null;
	
	int tot;
	int root;
	
	inline void update(int x){
		if(!x)tr[x]=null;
		else tr[x].siz=tr[tr[x].ch[0]].siz+tr[tr[x].ch[1]].siz+1;
	}
	
	inline void pushdown(int x){
		if(tr[x].tag){
			tr[tr[x].ch[0]].tag^=1;
			tr[tr[x].ch[1]].tag^=1;
			swap(tr[x].ch[0],tr[x].ch[1]);
			tr[x].tag=0;
		}
	}
	
	inline bool relation(int x){
		return x==tr[tr[x].fa].ch[1];
	}
	
	inline void connect(int x,int f,bool d){
		tr[x].fa=f;
		tr[f].ch[d]=x;
	}
	
	inline void rotate(int x){
		int  f=tr[x].fa;
		int  g=tr[f].fa;
		pushdown(x);
		pushdown(f);
		bool dx=relation(x);
		bool df=relation(f);
		int  s=tr[x].ch[dx^1];
		
		connect(x,g,df);
		connect(s,f,dx);
		connect(f,x,dx^1);
		
		update(f);
		update(x);
		update(g);
		
		if(!g)root=x;
	}
	
	inline void splay(int x,int target=0){
		for(int f=tr[x].fa;(f=tr[x].fa)!=target;rotate(x)){
			if(tr[f].fa!=target)rotate(relation(x)==relation(f)?f:x);
		}
	}
	
	inline int find(int k){
		for(int x=root;;){
			pushdown(x);
			if(tr[tr[x].ch[0]].siz+1<k)k-=(tr[tr[x].ch[0]].siz+1),x=tr[x].ch[1];
			else if(tr[tr[x].ch[0]].siz>=k)x=tr[x].ch[0];
			else return x;
		}
		assert(0);
		return -1;
	}
	
	inline int New_Node(int k){
		int x=++tot;
		tr[x].siz=1;
		tr[x].val=k;
		return x;
	}
	
	int build(int l,int r,int f){
		if(l>r)return 0;
		int mid=(l+r)>>1;
		int x=New_Node(mid);
		tr[x].fa=f;
		tr[x].ch[0]=build(l,mid-1,x);
		tr[x].ch[1]=build(mid+1,r,x);
		update(x);
		return x;
	}
	
	inline void build(int l,int r){
		root=build(l,r,0);
	}
	
	inline void reverse(int l,int r){
		int pre=find(l-1);
		int suc=find(r+1);
		splay(pre);
		splay(suc,pre);
		int x=tr[suc].ch[0];
		tr[x].tag^=1;
		splay(x);
	}
	
	void dfs(int x){
		if(!x)return;
		pushdown(x);
		dfs(tr[x].ch[0]);
		printf("%d ",tr[x].val-1);
		dfs(tr[x].ch[1]);
	}
	
	inline void print(){
		int pre=find(1);
		int suc=find(tot);
		splay(pre);
		splay(suc,pre);
		int x=tr[suc].ch[0];
		dfs(x);
	}
	
}tr;
\end{lstlisting}
\subsection{可并堆}
\subsubsection{左偏树}
一开始有 $n$ 个小根堆，每个堆包含且仅包含一个数。接下来需要支持两种操作：

1 x y：将第 $x$ 个数和第 $y$ 个数所在的小根堆合并（若第 $x$ 或第 $y$ 个数已经被删除或第 $x$ 和第 $y$ 个数在用一个堆内，则无视此操作）。

2 x：输出第 $x$ 个数所在的堆最小数，并将这个最小数删除（若有多个最小数，优先删除先输入的；若第 $x$ 个数已经被删除，则输出 $-1$ 并无视删除操作）。

\begin{lstlisting}
#include<bits/stdc++.h>

using namespace std;

#define gc c=getchar()
#define r(x) read(x)

template<typename T>
inline void read(T&x){
    x=0;T k=1;char gc;
    while(!isdigit(c)){if(c=='-')k=-1;gc;}
    while(isdigit(c)){x=x*10+c-'0';gc;}x*=k;
}

const int N=1e5+7;

struct Node{
    int key,dis,ls,rs;
    Node(int d=-1):dis(d){};
}tr[N],null;

int fa[N];

int find(int x){
    return fa[x]==x?x:fa[x]=find(fa[x]);
}

void uni(int x,int y){
    fa[find(x)]=find(y);
}

inline int Merge(int x,int y){
    if(!x)return y;
    if(!y)return x;
    if(tr[x].key>tr[y].key||(tr[x].key==tr[y].key&&x>y))swap(x,y);
    tr[x].rs=Merge(tr[x].rs,y);
    fa[tr[x].rs]=x;
    if(tr[tr[x].ls].dis<tr[tr[x].rs].dis)swap(tr[x].ls,tr[x].rs);
    tr[x].dis=tr[tr[x].rs].dis+1;
    return x;
}

inline void Pop(int x){
    x=find(x);
    int t=Merge(tr[x].ls,tr[x].rs);
    fa[x]=fa[tr[x].ls]=fa[tr[x].rs]=t;
    tr[x]=null;
}

inline int Top(int x){
    return tr[find(x)].key;
}

int main(){
    int n,m;
    r(n);r(m);
    for(int i=1;i<=n;++i)r(tr[i].key),tr[i].dis=0,fa[i]=i;
    for(int i=1,opt,x,y;i<=m;++i){
        r(opt);r(x);
        if(opt==1){
            r(y);
            if(!tr[x].key||!tr[y].key)continue;
            if(find(x)!=find(y))Merge(fa[x],fa[y]);
        }
        else {
            if(!tr[x].key)puts("-1");
            else {
                printf("%d\n",Top(x));
                Pop(x);
            }
        }
    }
}
\end{lstlisting}
\subsection{动态树}
\subsubsection{Link-Cut Tree}
P3690 【模板】Link Cut Tree
\begin{lstlisting}
struct LinkCutTree{
	struct Node{
		int fa,ch[2];
		int val;
		int sum;
		bool rev;
	}tr[N],null;
	
	inline void update(int x){
		tr[x].sum=tr[tr[x].ch[0]].sum^tr[tr[x].ch[1]].sum^tr[x].val;
	}
	
    inline void reverse(int x){
        tr[x].rev^=1;
        swap(tr[x].ch[0],tr[x].ch[1]);
    }
    
	inline bool relation(int x){
		return x==tr[tr[x].fa].ch[1];
	}
	
	inline bool isroot(int x){
		return tr[tr[x].fa].ch[0]!=x&&tr[tr[x].fa].ch[1]!=x;
	}
	
	inline void pushdown(int x){
		if(tr[x].rev){
			reverse(tr[x].ch[0]);
			reverse(tr[x].ch[1]);
			tr[x].rev=0;
		}
	}
	
    void pushdown_all(int x){
    	if(!isroot(x))pushdown_all(tr[x].fa);
    	pushdown(x);
    }
    
    inline void rotate(int x){
        int  f=tr[x].fa;
        int  g=tr[f].fa;
        
        bool dx=relation(x);
        bool df=relation(f);
        int  s=tr[x].ch[dx^1];
        
        if(!isroot(f))tr[g].ch[df]=x;
        tr[x].fa=g;
        
        tr[f].ch[dx]=s;
        if(s)tr[s].fa=f;
        
        tr[x].ch[dx^1]=f;
        tr[f].fa=x;
        
        update(f);
    }
    
    inline void splay(int x){
    	pushdown_all(x);
        for(int f;!isroot(x);rotate(x))if(!isroot(f=tr[x].fa))rotate(relation(x)==relation(f)?f:x);
        update(x);
    }
    
	inline void access(int x){
		for(int y=0;x;y=x,x=tr[x].fa)splay(x),tr[x].ch[1]=y,update(x);
	}
	
	inline void makeroot(int x){
		access(x),splay(x),reverse(x);
	}
	
	inline int findroot(int x){
		for(access(x),splay(x);pushdown(x),tr[x].ch[0];x=tr[x].ch[0]);
		return x;
	}
	
	inline void split(int x,int y){
		makeroot(x),access(y),splay(y);
	}
	
	inline void link(int x,int y){
		makeroot(x);
		if(findroot(y)==x)return;
		tr[x].fa=y;
	}
	
	inline void cut(int x,int y){
		makeroot(x);
		if(findroot(y)!=x)return;
		access(y),splay(y);
		if(tr[y].ch[0]!=x||tr[x].ch[1])return;
		tr[x].fa=tr[y].ch[0]=0;
		update(y);
	}
	
	inline void modify(int x,int y){
		splay(x),tr[x].val=y,update(x);
	}
	
	inline int query(int x,int y){
		split(x,y);
		return tr[y].sum;
	}
	
}tr;
\end{lstlisting}
维护子树信息（我们的 CPU 遭到攻击）
\begin{lstlisting}
struct LinkCutTree{
    struct Node{
        int fa,ch[2],val,cnt,cnt0;
        ll sumw,sum1,sum2,sum0;
        bool col,rev;
    }tr[N],null;
    
    int tot;
    int can[N],cnt;
    
    inline int New_Node(int k){
    	int x=cnt?can[cnt--]:++tot;
    	tr[x].val=k;
    	return x;
    }
    
    inline void Del_Node(int x){
    	tr[x]=null;
    	can[++cnt]=x;
    }
    
    inline bool relation(int x){
        return x==tr[tr[x].fa].ch[1];
    }
    
    inline bool isroot(int x){
        return tr[tr[x].fa].ch[0]!=x&&tr[tr[x].fa].ch[1]!=x;
    }
    
    inline void reverse(int x){
        tr[x].rev^=1;
        swap(tr[x].sum1,tr[x].sum2);
        swap(tr[x].ch[0],tr[x].ch[1]);
    }
    
    inline void update(int x){
    	if(!x)return ;
       	tr[x].cnt=tr[tr[x].ch[0]].cnt+tr[tr[x].ch[1]].cnt+tr[x].col+tr[x].cnt0;
       	tr[x].sumw=tr[tr[x].ch[0]].sumw+tr[tr[x].ch[1]].sumw+tr[x].val;
       	tr[x].sum1=tr[x].sum0+tr[tr[x].ch[0]].sum1+tr[tr[x].ch[1]].sum1+(tr[tr[x].ch[1]].cnt+tr[x].cnt0)*(tr[tr[x].ch[0]].sumw+tr[x].val)+tr[x].col*tr[tr[x].ch[0]].sumw;
       	tr[x].sum2=tr[x].sum0+tr[tr[x].ch[0]].sum2+tr[tr[x].ch[1]].sum2+(tr[tr[x].ch[0]].cnt+tr[x].cnt0)*(tr[tr[x].ch[1]].sumw+tr[x].val)+tr[x].col*tr[tr[x].ch[1]].sumw;
    }
    
    inline void pushdown(int x){
        if(tr[x].rev){
            tr[x].rev=0;
            reverse(tr[x].ch[0]);
            reverse(tr[x].ch[1]);
        }
    }
    
    void pushdown_all(int x){
    	if(!isroot(x))pushdown_all(tr[x].fa);
    	pushdown(x);
    }
    
    inline void rotate(int x){
        int  f=tr[x].fa;
        int  g=tr[f].fa;
        
        bool dx=relation(x);
        bool df=relation(f);
        int  s=tr[x].ch[dx^1];
        
        if(!isroot(f))tr[g].ch[df]=x;
        tr[x].fa=g;
        
        tr[f].ch[dx]=s;
        if(s)tr[s].fa=f;
        
        tr[x].ch[dx^1]=f;
        tr[f].fa=x;
        
        update(f);
    }
    
    inline void splay(int x){
    	pushdown_all(x);
        for(int f;!isroot(x);rotate(x))if(!isroot(f=tr[x].fa))rotate(relation(x)==relation(f)?f:x);
        update(x);
    }
    
	inline void access(int x){
 	   for(int y=0;x;y=x,x=tr[x].fa){
        	splay(x);
        	tr[x].cnt0+=tr[tr[x].ch[1]].cnt-tr[y].cnt;
        	tr[x].sum0+=tr[tr[x].ch[1]].sum1-tr[y].sum1;
        	tr[x].ch[1]=y;
        	update(x);
        }
	}
    inline void makeroot(int x){
        access(x),splay(x),reverse(x);
    }
    
    inline void split(int x,int y){
        makeroot(x),access(y),splay(y);
    }
    
    inline void link(int x,int y){
        makeroot(x);
        makeroot(y);
        tr[y].cnt0+=tr[x].cnt;
        tr[y].sum0+=tr[x].sum1;
        tr[x].fa=y;
        update(y);
    }
    
    inline void cut(int x,int y){
        split(x,y);
        tr[x].fa=tr[y].ch[0]=0;
        update(y);
    }
    
    inline void addedge(int x,int y,int c){
    	int e=New_Node(c);
    	link(x,e),link(e,y);
    }
    
    inline void deledge(int x,int y){
    	split(x,y);
    	int e=tr[y].ch[0];
    	if(e==x)e=tr[x].ch[1];
    	cut(x,e),cut(e,y);
    	Del_Node(e);
    }
    
    inline void modify(int x){
    	makeroot(x);
    	tr[x].col^=1;
    	update(x);
    }
    
    inline ll query(int x){
    	makeroot(x);
    	return tr[x].sum1;
    }
    
}tr;
\end{lstlisting}
\subsection{长链剖分}
\subsubsection{普通长链剖分}
BZOJ4543 [POI2014]Hotel加强版
给出 $n$ 个点的树，求有多少个元素互不相同的无序三元组 $(a,b,c)$ 满足两两之间树上距离相等
\begin{lstlisting}
#include<bits/stdc++.h>

using namespace std;

#define gc c=getchar()
#define r(x) read(x)
#define ll long long

template<typename T>
inline void read(T&x){
    x=0;T k=1;char gc;
    while(!isdigit(c)){if(c=='-')k=-1;gc;}
    while(isdigit(c)){x=x*10+c-'0';gc;}x*=k;
}

const int N=1e5+7;

int fa[N];
int hit[N];
int son[N];

vector<int>G[N];

void dfs1(int x,int f){
	fa[x]=f;
	for(int i=0;i<G[x].size();++i){
		int v=G[x][i];
		if(v==f)continue;
		dfs1(v,x);
		if(hit[v]>hit[son[x]])son[x]=v;
	}
	hit[x]=hit[son[x]]+1;
}

//F[x][d] in x,dist to x=d
//G[x][d] in x,the third point is the d-th father of x

ll *F[N],*H[N],pool[N<<2],*p=pool;
ll ans;

void dfs2(int x){
	if(son[x]){
		H[son[x]]=H[x]-1;//x将继承son[x]的信息 
		F[son[x]]=F[x]+1;
		dfs2(son[x]);
	}
	F[x][0]=1;
	ans+=H[x][0];//当前点形成三元组 
	for(int i=0;i<G[x].size();++i){
		int v=G[x][i];
		if(v==fa[x]||v==son[x])continue;
		F[v]=p;p+=hit[v]*2;
		H[v]=p;p+=hit[v]*2;
		dfs2(v);
		for(int j=0;j<hit[v];++j){
			if(j)ans+=F[x][j-1]*H[v][j];//x 向已经走过的子节点走 j-1步与向当前节点中的二元组形成三元组 
			ans+=H[x][j+1]*F[v][j];//x 向当前节点走j步形成与已走过子节点中的二元组三元组 
		}
		for(int j=0;j<hit[v];++j){
			H[x][j+1]+=F[x][j+1]*F[v][j];//新组成二元组 
			if(j)H[x][j-1]+=H[v][j];//继承子节点的二元组 
			F[x][j+1]+=F[v][j]; 
		}
	}
}

int main(){
	int n;r(n);
	for(int i=1;i<n;++i){
		int u,v;r(u),r(v);
		G[u].push_back(v);
		G[v].push_back(u);
	}
	dfs1(1,0);
	F[1]=p;p+=hit[1]*2;
	H[1]=p;p+=hit[1]*2;
	dfs2(1);
	printf("%lld\n",ans);
	return 0;
}
\end{lstlisting}
\subsubsection{线段树维护长链}
P4292 [WC2010]重建计划
\begin{lstlisting}
#include<bits/stdc++.h>

using namespace std;

#define gc c=getchar()
#define r(x) read(x)
#define ll long long
#define db double

template<typename T>
inline void read(T&x){
    x=0;T k=1;char gc;
    while(!isdigit(c)){if(c=='-')k=-1;gc;}
    while(isdigit(c)){x=x*10+c-'0';gc;}x*=k;
}

const int N=100005;
const db eps=1e-4;
const db INF=1e18;

int n,L,R;

int ecnt;
int fir[N],to[N<<1],w[N<<1],nex[N<<1];
db val[N<<1];

inline void addedge(int u,int v,int c){
	nex[++ecnt]=fir[u],fir[u]=ecnt,to[ecnt]=v,w[ecnt]=c;
	nex[++ecnt]=fir[v],fir[v]=ecnt,to[ecnt]=u,w[ecnt]=c;
}

int fa[N],son[N],hight[N];

void dfs1(int x,int f){
	fa[x]=f;
	for(int i=fir[x];i;i=nex[i]){
		int v=to[i];
		if(v==f)continue;
		dfs1(v,x);
		if(hight[son[x]]<hight[v])son[x]=v;
	}
	hight[x]=hight[son[x]]+1;
}

int dfs_clock;
int top[N],dfn[N];

void dfs2(int x,int t){
	top[x]=t;
	dfn[x]=++dfs_clock;
	if(!son[x])return ;
	dfs2(son[x],t);
	for(int i=fir[x];i;i=nex[i]){
		int v=to[i];
		if(v==fa[x]||v==son[x])continue;
		dfs2(v,v);
	}
}

#define ls (rt<<1)
#define rs (rt<<1|1)

int SegID[N];
db mx[N<<2];

void build(int rt,int l,int r){
	mx[rt]=-INF;
	if(l==r){
		SegID[l]=rt;
		return ;
	}
	int mid=(l+r)>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
}

void modify(int rt,int l,int r,int x,db v){
	if(l==r){
		mx[rt]=max(mx[rt],v);
		return ;
	}
	int mid=(l+r)>>1;
	if(x<=mid)modify(ls,l,mid,x,v);
	else modify(rs,mid+1,r,x,v);
}

db query(int rt,int l,int r,int x,int y){
	if(x<=l&&r<=y)return mx[rt];
	int mid=(l+r)>>1;
	if(y<=mid)return query(ls,l,mid,x,y);
	else if(x>mid)return query(rs,mid+1,r,x,y);
	else return max(query(ls,l,mid,x,y),query(rs,mid+1,r,x,y));
}

inline void modify(int x,db v){
	modify(1,1,n,x,v);
}

inline db query(int x){
	return mx[SegID[x]];
}

inline db query(int x,int y){
	if(x>y)return -INF;
	return query(1,1,n,x,y);
}

db ans;
db dis[N];
db len[N];

void dfs3(int x){
	modify(dfn[x],dis[x]);
	for(int i=fir[x];i;i=nex[i]){
		int v=to[i];
		if(v==fa[x])continue;
		dis[v]=dis[x]+val[i];
		dfs3(v);
		if(v==son[x])continue;
		else {
			for(int j=1;j<=hight[v];++j){
				len[j]=query(dfn[v]+j-1);
				if(j<=R){
					ans=max(ans,query(max(dfn[x],dfn[x]+L-j),min(dfn[x]+hight[x],dfn[x]+R-j))+len[j]-2*dis[x]);
				}
			}
			for(int j=1;j<=hight[v];++j){
				modify(dfn[x]+j,len[j]);
			}
		}
	}
	ans=max(ans,query(dfn[x]+L,min(dfn[x]+hight[x],dfn[x]+R))-dis[x]);
}

inline bool check(db x){
	ans=-INF;
	for(int i=1;i<=ecnt;++i)val[i]=w[i]-x;
	build(1,1,n);
	dfs3(1);
	return ans>0;
}

int main(){
	r(n),r(L),r(R);
	for(int i=1;i<n;++i){
		int u,v,c;
		r(u),r(v),r(c);
		addedge(u,v,c);
	}
	dfs1(1,0);
	dfs2(1,1);
	db l=0,r=1e6,mid;
	while(l+eps<r){
		mid=(l+r)*0.5;
		if(check(mid))l=mid;
		else r=mid;
	}
	printf("%.3lf",l);
	return 0;
}
\end{lstlisting}
\subsection{点分治}
\subsubsection{静态点分治}
P3806 【模板】点分治1
给定一棵有 $n$ 个点的树，询问树上距离为 $k$ 的点对是否存在。
\begin{lstlisting}
#include<bits/stdc++.h>

using namespace std;

#define gc c=getchar()
#define r(x) read(x)

template<typename T>
inline void read(T&x){
    x=0;T k=1;char gc;
    while(!isdigit(c)){if(c=='-')k=-1;gc;}
    while(isdigit(c)){x=x*10+c-'0';gc;}x*=k;
}

const int N=10005;
const int K=10000005;

int rt,n,m,cnt,t[3],ecnt;
int fir[N],nex[N<<1],to[N<<1],val[N<<1],s[N],siz[N],dis[N];
bool vis[N],exist[K],ans[105];
int query[N];

inline void add(int u,int v,int w){nex[++ecnt]=fir[u];fir[u]=ecnt;to[ecnt]=v;val[ecnt]=w;}

inline void init(){r(n);r(m);for(int i=1,u,v,w;i<n;++i)r(u),r(v),r(w),add(u,v,w),add(v,u,w);}

inline void dfs1(int x,int f){
    siz[x]=1;
    s[x]=0;
    for(int i=fir[x],v;i;i=nex[i]){
        v=to[i];
        if(v==f||vis[v])continue;
        dfs1(v,x);
        siz[x]+=siz[v];
        s[x]=max(s[x],siz[v]);
    }
    s[x]=max(s[x],cnt-siz[x]);
    if(s[x]<s[rt])rt=x;
}

int d[N];

inline void dfs2(int x,int f){
    d[++d[0]]=dis[x];
    for(int i=fir[x],v;i;i=nex[i]){
        v=to[i];
        if(v==f||vis[v])continue;
        dis[v]=dis[x]+val[i];
        dfs2(v,x);
    }
}

int clear[N];

inline void clac(int x){
    for(int i=fir[x];i;i=nex[i]){
        int v=to[i];
        if(vis[v])continue;
        dis[v]=val[i];
        d[0]=0;
        dfs2(v,x);
        
        for(int j=1;j<=d[0];++j)
            for(int k=1;k<=m;++k)
                if(query[k]>=d[j])ans[k]|=exist[query[k]-d[j]];
        
        for(int j=1;j<=d[0];++j)exist[clear[++clear[0]]=d[j]]=1;
    }
    for(int i=clear[0];i;--i)exist[clear[i]]=0;
    for(int i=clear[0];~i;--i)clear[i]=0;
}

inline void slove(int x){
    exist[0]=vis[x]=1;
    clac(x);
    for(int i=fir[x],v;i;i=nex[i]){
        v=to[i];
        if(vis[v])continue;
        rt=0;
        cnt=siz[v];
        dfs1(v,0);
        slove(rt);
    }
}

inline void work(){
    s[rt]=cnt=n;
    dfs1(1,0);
    slove(rt);
}

int main(){
    init();
    for(int i=1;i<=m;++i)r(query[i]);
    work();
    for(int i=1;i<=m;++i)puts(ans[i]?"AYE":"NAY");
}
\end{lstlisting}
\subsubsection{动态点分治}
P2056 [ZJOI2007]捉迷藏
\begin{lstlisting}
#include<bits/stdc++.h>

using namespace std;

#define gc c=getchar()
#define r(x) read(x)
#define ll long long

template<typename T>
inline void read(T&x){
    x=0;T k=1;char gc;
    while(!isdigit(c)){if(c=='-')k=-1;gc;}
    while(isdigit(c)){x=x*10+c-'0';gc;}x*=k;
}

const int N=100005;
const int INF=1e9;

int col[N];
vector<int>G[N];
int n;

namespace sp{
	
	int siz[N];
	int dep[N];
	int son[N];
	int fa[N];
	
	void dfs1(int x,int f){
		fa[x]=f;
		siz[x]=1;
		dep[x]=dep[f]+1;
		for(int i=0;i<G[x].size();++i){
			int v=G[x][i];
			if(v==f)continue;
			dfs1(v,x);
			siz[x]+=siz[v];
			if(siz[son[x]]<siz[v])son[x]=v;
		}
	}
	
	int top[N];
	
	void dfs2(int x,int t){
		top[x]=t;
		if(!son[x])return ;
		dfs2(son[x],t);
		for(int i=0;i<G[x].size();++i){
			int v=G[x][i];
			if(v==fa[x]||v==son[x])continue;
			dfs2(v,v);
		}
	}
	
	inline int lca(int u,int v){
		while(top[u]!=top[v]){
			if(dep[top[u]]<dep[top[v]])swap(u,v);
			u=fa[top[u]];
		}
		return dep[u]<dep[v]?u:v;
	}
	
	inline int dist(int u,int v){
		return dep[u]+dep[v]-2*dep[lca(u,v)];
	}
}
using sp::dist;

namespace df{

	struct Heap{
		multiset<int>A;
		
		inline void ins(int x){
			A.insert(x);
		}
		
		inline void del(int x){
			A.erase(A.find(x));
		}
		
		inline int max(){
			return *A.rbegin();
		}
		
		inline int sec(){
			return *(++A.rbegin());
		}
		
		inline Heap(){
			A.insert(-INF);
			A.insert(-INF);
		}
	}Ans,A[N],B[N];

	int root,SIZE;
	int siz[N];
	int s[N];
	bool vis[N];
	
	void getroot(int x,int f){
		siz[x]=1;
		s[x]=0;
		for(int i=0;i<G[x].size();++i){
			int v=G[x][i];
			if(v==f||vis[v])continue;
			getroot(v,x);
			siz[x]+=siz[v];
			s[x]=max(s[x],siz[v]);
		}
		s[x]=max(s[x],SIZE-siz[x]);
		if(s[x]<s[root])root=x;
	}
	
	int fa[N];
	vector<int>son[N];
	
	void build(int x,int size){
		vis[x]=1;
		for(int i=0;i<G[x].size();++i){
			int v=G[x][i];
			if(vis[v])continue;
			s[root=0]=SIZE=(siz[x]<siz[v]?size-siz[x]:siz[v]);
			getroot(v,0);
			fa[root]=x;
			son[x].push_back(root);
			build(root,SIZE);
		}
	}
	
	inline void work(){
		s[root=0]=SIZE=n;
		getroot(1,0);
		build(root,n);
		for(int u=1;u<=n;++u){
			for(int x=u,f;;x=f){
				f=fa[x];
				if(f)A[x].ins(dist(u,f));
				else break;
			}
		}
		for(int i=1;i<=n;++i){
			for(int j=0;j<son[i].size();++j){
				int x=son[i][j];
				B[i].ins(A[x].max());
			}
			B[i].ins(0);
			Ans.ins(B[i].max()+B[i].sec());
		}
		int q;r(q);
		int cnt=n;
		while(q--){
			char s[5];
			scanf("%s",s);
			if(s[0]=='G'){
				if(cnt==0)puts("-1");
				else if(cnt==1)puts("0");
				else printf("%d\n",Ans.max());
			}
			else {
				int u;r(u);
				if(col[u]){
					col[u]=0;
					++cnt;
					int mx=B[u].max();
					int sc=B[u].sec();
					if(0>B[u].sec()){
						Ans.del(B[u].max()+B[u].sec());
						B[u].ins(0);
						Ans.ins(B[u].max()+B[u].sec());
					}
					else B[u].ins(0);
					for(int x=u,f;;x=f){
						f=fa[x];
						if(f){
//							Ans.del(B[f].max()+B[f].sec());
//							B[f].del(A[x].max());
//							A[x].ins(dist(u,f));
//							B[f].ins(A[x].max());
//							Ans.ins(B[f].max()+B[f].sec());
							int dis=dist(u,f);
							int mxa=A[x].max();
							if(dis>A[x].max()){
								int mx=B[f].max();
								int sc=B[f].sec();
								if(dis>sc){
									Ans.del(B[f].max()+B[f].sec());
									B[f].del(A[x].max());
									A[x].ins(dist(u,f));
									B[f].ins(A[x].max());
									Ans.ins(B[f].max()+B[f].sec());
								}
								else {
									B[f].del(A[x].max());
									A[x].ins(dist(u,f));
									B[f].ins(A[x].max());
								}
							}
							else A[x].ins(dist(u,f));
						}
						else break;
					}
				}
				else {
					col[u]=1;
					--cnt;
					int mx=B[u].max();
					int sc=B[u].sec();
					if(0>=B[u].sec()){
						Ans.del(B[u].max()+B[u].sec());
						B[u].del(0);
						Ans.ins(B[u].max()+B[u].sec());
					}
					else B[u].del(0);
					for(int x=u,f;;x=f){
						f=fa[x];
						if(f){
//							Ans.del(B[f].max()+B[f].sec());
//							B[f].del(A[x].max());
//							A[x].del(dist(u,f));
//							B[f].ins(A[x].max());
//							Ans.ins(B[f].max()+B[f].sec());int dis=dist(u,f);
							int dis=dist(u,f);
							int mxa=A[x].max();
							if(dis>=A[x].max()){
								int mx=B[f].max();
								int sc=B[f].sec();
								if(dis>=sc){
									Ans.del(B[f].max()+B[f].sec());
									B[f].del(A[x].max());
									A[x].del(dist(u,f));
									B[f].ins(A[x].max());
									Ans.ins(B[f].max()+B[f].sec());
								}
								else {
									B[f].del(A[x].max());
									A[x].del(dist(u,f));
									B[f].ins(A[x].max());
								}
							}
							else A[x].del(dist(u,f));
						}
						else break;
					}
				}
			}
		}
	}
}

int main(){
	r(n);
	for(int i=1;i<n;++i){
		int u,v;r(u),r(v);
		G[u].push_back(v);
		G[v].push_back(u);
	}
	sp::dfs1(1,0);
	sp::dfs2(1,1);
	df::work(); 
	return 0;
}
\end{lstlisting}
% \subsection{笛卡尔树}
\section{数学}
\subsection{数论}
\subsubsection{ExGCD}
\begin{lstlisting}
void exgcd(int a,int b,int &x,int &y){
    if(!b){
        x=1;
        y=0;
        return;
    }
    exgcd(b,a%b,y,x);
    y-=a/b*x;
}
\end{lstlisting}
\subsubsection{ExCRT}
\begin{lstlisting}
void exgcd(ll a,ll b,ll &d,ll &x,ll &y){
    if(!b){
        d=a,x=1,y=0;
        return;
    }
    exgcd(b,a%b,d,y,x);
    y-=a/b*x;
}

inline bool Uni(ll &p1,ll &a1,ll p2,ll a2){
    ll d,k1,k2;
    exgcd(p1,p2,d,k1,k2);
    // if((a1-a2)%d)return 1;
    ll lcm=p1/d*p2;
    a1=(a1+(__int128)(a2-a1)/d*k1%lcm*p1)%lcm;
    p1=lcm;
    return 0;
}

inline ll exCRT(ll *p,ll *a,int n){
    ll P=p[0],A=a[0];
    for(int i=1;i<n;++i){
        Uni(P,A,p[i],a[i]);
        // if(Uni(P,A,p[i],a[i]))return -1;
    }
    return (A%P+P)%P;
}
\end{lstlisting}
\subsubsection{逆元}
线性求逆元
\begin{lstlisting}
inv[1]=1;
for(int i=2;i<=n;++i){
    inv[i]=(ll)(p-p/i)*inv[p%i]%p;
}
\end{lstlisting}
\subsubsection{线性筛}
\begin{lstlisting}
int tot;
int pri[N];
bool mark[N];
int phi[N];
int mu[N];
int s0[N];
int num[N];

inline void init(){
    phi[1]=mu[1]=s0[1]=1;
    for(int i=2;i<=n;++i){
        if(!mark[i]){
            pri[++tot]=i;
            phi[i]=i-1;
            mu[i]=-1;
            s0[i]=2;
            num[i]=1;
        }
        for(int j=1,tmp;j<=tot&&(tmp=i*pri[j])<=n;++j){
            mark[tmp]=1;
            if(i%pri[j]){
                phi[tmp]=phi[i]*phi[pri[j]];
                mu[tmp]=-mu[i];
                num[tmp]=1;
                s0[tmp]=s0[i]*2;
            }
            else {
                phi[tmp]=phi[i]*pri[j];
                mu[tmp]=0;
                num[tmp]=num[i]+1;
                s0[tmp]=s0[i]/num[tmp]*(num[tmp]+1);
                break;
            }
        }
    }
}
\end{lstlisting}
\subsubsection{杜教筛}
\paragraph{用途}\ 

求积性函数 $f$ 的前缀和 $S(n)=\sum_n^{i=1} f(i)$.

复杂度 $O(n^{\frac{3}{4}})$，线性预处理后 $O(n^{\frac{2}{3}})$

\paragraph{原理}\ 

尝试构造 $S(n)$ 关于 $S(\lfloor\frac{n}{i}\rfloor)$ 的递推式。

对任意数论函数 $g$, 有
\begin{align*}
    \sum_{i = 1} ^ {n} (f\cdot g)(i) &= \sum_{i = 1} ^ {n} \sum_{d|i}g(d)f(\frac{i}{d})\\
                                     &= \sum_{d = 1} ^ {n} g(d) \sum_{i = 1}^{\lfloor \frac{n}{d} \rfloor} f(i)\\
                                     &= \sum_{d = 1} ^ {n} g(d) S(\lfloor \frac{n}{d} \rfloor)
\end{align*}

易得
\begin{align*}
    g(1)S(n) = \sum_{i = 1} ^ {n} (f\cdot g)(i) - \sum_{i = 2} ^ {n} g(i) S(\lfloor \frac{n}{i} \rfloor)
\end{align*}

若可以快速计算 $g(1)$、$f\cdot g$ 前缀和、$g(i)$ 前缀和则可递归计算 $S(n)$。

\paragraph{例题}\

求 $\varphi(i)$ 和 $\mu(i)$ 前缀和。

\begin{lstlisting}
ll phi[N],mu[N];
int prime[N];
bool mark[N];
int cnt;

inline void init(){
	phi[1]=mu[1]=1;
	for(int i=2;i<N;i++){
		if(!mark[i])prime[++cnt]=i,phi[i]=i-1,mu[i]=-1;
		for(int j=1;j<=cnt;j++){
			ll tmp=i*prime[j];
			if(tmp>=N)break;
			mark[tmp]=1;
			if(i%prime[j]==0){phi[tmp]=phi[i]*prime[j],mu[tmp]=0;break;}
			else phi[tmp]=phi[i]*phi[prime[j]],mu[tmp]=-mu[i];
		}
	}
	for(int i=1;i<N;++i)phi[i]+=phi[i-1],mu[i]+=mu[i-1];
}

map<int,ll>s_mu;
ll sum_mu(int n){
	if(n<N)return mu[n];
	if(s_mu.count(n))return s_mu[n];
	ll ans=1;
	for(ll i=2,j;i<=n;i=j+1){
		j=n/(n/i);
		ans-=(j-i+1)*sum_mu(n/i);
	}
	return s_mu[n]=ans;
}

ll sum_phi(int n){
	if(n<N)return phi[n];
	ll ans=0;
    for(ll i=1,j;i<=n;i=j+1){
    	j=n/(n/i);
		ans+=(n/i)*(n/i)*(sum_mu(j)-sum_mu(i-1));
	}
    return ((ans-1)>>1)+1;
}

int main(){
	init();
	int T,n;
	scanf("%d",&T);
	while(T--){
		scanf("%d",&n);
		printf("%lld %lld\n",sum_phi(n),sum_mu(n));
	}
}
\end{lstlisting}
\subsubsection{Min25筛}
\paragraph{用途}\ 

求积性函数 $f$ 的前缀和 $F(n)=\sum_n^{i=1} f(i)$.

复杂度 $O(\frac{n^{\frac{3}{4}}}{\log{n}})$ (或者 $O(n^{1-\epsilon})$, 存在 $O(n^{\frac{2}{3}})$ 的树状数组优化版本, 但常数巨大)

\paragraph{使用条件}\ 

\begin{itemize}
    \item $f(p)$ 是低次多项式(感觉是完全积性函数的线性组合就行?)
    \item $f(p^e)$ 可以快速求出
\end{itemize}

\paragraph{原理}\ 

\textbf{Part 1}

对于完全积性函数 $f_k(i)=i^k$, 求解 $\sum_{p_i \le n} f_k(p_i)$, 其中 $p_i$ 是第 $i$ 小的质数.

通过埃氏筛的方式只留下合法位置, 这样质数只需要筛到 $\sqrt{n}$ 就可以把合数位置全部去除.

设 $g_k(n,i)$ 为用前 $i$ 个质数做埃氏筛, 前 $n$ 个数剩余合法位置的 $f_k$ 的和, 即

\begin{align*}
    g_k(n,i)=\sum_{j=2}^{n}{[MinP(j) > p_i \lor j \in P] \cdot f_k(j)}
\end{align*}

其中, $MinP(j)$ 为 $j$ 的最小质因数.

考虑埃氏筛的过程:

首先, $1$ 从一开始就被筛去, 因此 $g_k(n,0) = \sum_{i=2}^{n} f_k(p_i)$, 即自然数幂和减 $1$.

接下来每个数被其最小质因数筛去.

\begin{align*}
    g_k(n,i)&=g_k(n,i-1)-\sum_{j=p_i+1}^{n}{[MinP(j)=P]\cdot f_k(j)}\\
          &=g_k(n,i-1)-f_k(p_i)\cdot\sum_{j=p_i+1}^{n}{[MinP(j)=P]\cdot f_k(\frac{j}{p_i})}\\
          &=g_k(n,i-1)-f_k(p_i)\cdot\sum_{j=p_i}^{\lfloor \frac{n}{p_i} \rfloor}{[MinP(j)\ge P]\cdot f_k(j)}\\
          &=g_k(n,i-1)-f_k(p_i)\cdot(g_k(\lfloor \frac{n}{p_i} \rfloor,i-1)-\sum_{j=1}^{i-1}f_k(p_i))
\end{align*}

记 $\sum_{j=1}^{i-1}f_k(p_i)$ 为 $sp_k(i-1)$, 可以线性筛预处理.

根据这个式子可以dp, 但时间和空间复杂度都不能接受.

可以注意到,第 $i$ 次筛后的 $g$ 数组是由第 $i-1$ 次筛后的 $g$ 数组转移而来, 且转移点 $\lfloor \frac{n}{p_i} \rfloor < n$, 所以可以直接省掉一维.

注意到每次转移点都是 $\lfloor \frac{n}{x} \rfloor$ 的形式, 
由于 $\lfloor \frac{\lfloor \frac{n}{a} \rfloor}{b} \rfloor = \lfloor \frac{n}{ab} \rfloor$,
所以为了求 $g_k(n,i)$ 实际需要用到的位置不超过 $2\sqrt{n}$ 个.

将这 $2\sqrt{n}$ 个位置拼成一个数组, 只计算这些位置的值, 看起来就非常优秀了.

由于对于 $g_k(n,\infty)$, 只需要枚举不超过 $\sqrt{n}$ 的质数, 总复杂度为:

\begin{align*}
    T(n)&=\sum_{i=1}^{\sqrt{n}}O(\pi(\sqrt{i}))+\sum_{i=1}^{\sqrt{n}}O(\pi(\sqrt{\lfloor \frac{n}{i} \rfloor}))\\
        &=\sum_{i=1}^{\sqrt{n}}O(\pi(\sqrt{\frac{n}{i}}))\\
        &=\sum_{i=1}^{\sqrt{n}}O(\frac{\sqrt{\frac{n}{i}}}{\log(\frac{n}{i})})\\
        &=O(\int_{1}^{\sqrt{n}}\frac{\sqrt{\frac{n}{x}}}{\log(\sqrt{\frac{n}{x}})} \mathrm{d}x)\\
        &=O(\frac{\sqrt{n}}{\log n}\int_{1}^{\sqrt{n}}x^{-\frac{1}{2}} \mathrm{d}x)\\
        &=O(\frac{n^{\frac{3}{4}}}{\log n})
\end{align*}

这样,就对所有 $m = \lfloor \frac{n}{x} \rfloor$ 的位置都求出了$\sum_{p_i \le m} f_k(p_i)$, 如果$f(i)$只在质数位置不为$0$(如求质数个数等, 就已经做完了).

\textbf{Part 2}

接下来求解 $\sum_{i=1}^{n}f(i)$, 设:

\begin{align*}
    S(n,i)=\sum_{j=2}^{n}{[MinP(j)>p_i] \cdot f(j)}
\end{align*}

所求即为 $S(n,0)+1$.

分别考虑质数和合数位置对 $S(n,i)$ 的贡献:

\quad 对质数位置, $f(i)$ 是低次多项式, $i^k$的贡献为 $g_k(n,\infty)-sp_k(i)$, 容易算出总贡献.

\quad 对合数位置, 需要枚举其最小质因子及其次数, 根据积性函数的性质知道,贡献为:
\begin{align*}
    \sum_{j>i}\sum_{p_j^e\le n}f(p_j^e)(S(\lfloor \frac{n}{p_j^e} \rfloor,j)+[e\neq 1])
\end{align*}

似乎因为某些深刻的原因(好像是只会每个位置访问一次)直接递归计算就行, 复杂度是 $O(n^{1-\epsilon})$ 的, 但常数巨小, 在$n \le 10^{13}$时和$O(\frac{n^{\frac{3}{4}}}{\log{n}})$等数量级.
如果也写成dp递推就同样是 $O(\frac{n^{\frac{3}{4}}}{\log{n}})$ 的.

\paragraph{例题}\ 

$f(p^k)=p^k(p^k-1)$, 求 $\sum_{i=1}^{n} f(i)$

\begin{lstlisting}
ll n;
int sq,m;

int tot;
int prime[N];
bool mark[N];

int sp1[N]; // f1 在前 n 个质数位置的前缀和
int sp2[N]; // f2 在前 n 个质数位置的前缀和

int g1[N*2]; // f1 在不超过 m = n/x 的质数位置的前缀和
int g2[N*2]; // f2 在不超过 m = n/x 的质数位置的前缀和

ll w[N*2];
int Ind1[N];
int Ind2[N];

// 注意 n 是全局变量
inline int& index(const ll &x){
    return x<=sq?Ind1[x]:Ind2[n/x];
}

// f'(x) 与 积性函数 f(x) 在质数位置相等 
// 且 f'(x) 为 f2(x) 与 f1(x) 的差
// f'(x) = x * (x - 1) = x^2 - x
inline ll f(ll x){
    x%=p;
    return x*(x-1)%p;
}

// f1(x) = x
inline ll f1(ll x){
    return x;
}

// f2(x) = x^2
inline ll f2(ll x){
    return x*x%p;
}

// f1 的前缀和
inline ll s1(ll x){
    x%=p;
    return x*(x+1)/2%p;
}

// f2 的前缀和
inline ll s2(ll x){
    x%=p;
    return x*(x+1)%p*(2*x+1)%p*inv6%p;
}

inline ll S(ll x,int j){
    if(prime[j]>x)return 0;
    // 质数位置的贡献
    int ans=sub(sub(g2[index(x)],g1[index(x)]),sub(sp2[j],sp1[j]));
    for(int i=j+1;i<=tot&&(ll)prime[i]*prime[i]<=x;++i){
        for(ll e=1,pk=prime[i];pk<=x;++e,pk*=prime[i]){
            // 合数位置的贡献(枚举最小质因子及其次幂)
            ans=add(ans,mul(f(pk),add(S(x/pk,i),(e>1))));
        }
    }
    return ans;
}

int main(){
    r(n);
    sq=sqrt(n);
    for(int i=2;i<=sq;++i){
        if(!mark[i]){
            prime[++tot]=i;
            sp1[tot]=add(sp1[tot-1],f1(i));
            sp2[tot]=add(sp2[tot-1],f2(i));
        }
        for(int j=1,tmp;j<=tot&&(tmp=i*prime[j])<=sq;++j){
            mark[tmp]=1;
            if(i%prime[j]==0)break;
        }
    }
    for(ll i=1,j;i<=n;i=j+1){
        w[++m]=n/i;
        j=n/w[m];
        index(w[m])=m;
        g1[m]=sub(s1(w[m]),1); // 先筛掉 1, f1(1)=1
        g2[m]=sub(s2(w[m]),1); // 先筛掉 1, f2(1)=1
    }
    for(int i=1;i<=tot;++i){
        for(int j=1;j<=m&&(ll)prime[i]*prime[i]<=w[j];++j){
            g1[j]=sub(g1[j],mul(f1(prime[i]),sub(g1[index(w[j]/prime[i])],sp1[i-1])));
            g2[j]=sub(g2[j],mul(f2(prime[i]),sub(g2[index(w[j]/prime[i])],sp2[i-1])));
        }
    }
    printf("%d\n",add(S(n,0),1)); // 还原 f(1) 的贡献(因为是积性函数所以一定是 1 )
    return 0;
}
\end{lstlisting}
\subsubsection{Powerful Number筛}
\paragraph{用途}\ 

求积性函数 $f$ 的前缀和 $F(n)=\sum_n^{i=1} f(i)$.

复杂度 $O(\sqrt{n})$ 或 $O(\sqrt{n}\log n)$ 或 $O(n^{\frac{2}{3}})$.

\paragraph{使用条件}\ 

存在一个函数 $g$ 满足：
\begin{itemize}
    \item $g$ 是积性函数
    \item $g$ 易求前缀和
    \item 对于质数 $p$，$g(p)=f(p)$
\end{itemize}

\paragraph{Powerful Number}\ 

定义为每个质因子次数都不小于 $2$ 的数.

将 PN 表示为 $a^2b^3$ 的形式, 积分可以证明, $n$ 以内的 PN 只有 $O(\sqrt{n})$ 个.

可以通过线性筛筛出 $\sqrt{n}$ 内的所有质数, 然后直接 dfs 质数指数搜出所有 PN, 复杂度是 $O(\sqrt{n})$ 的.

\paragraph{原理}\ 

首先，构造出合适的 $g$, 记 $G(n)=\sum^n_{i=1} g(i)$.

然后考虑另一个函数 $h$, 满足 $f=g∗h$, 故 $h$ 也为积性函数.

代入 $f(p)=h(p)g(1)+g(p)h(1)=h(p)+g(p)$ 容易得到 $h(p)=0$ , 由于 $h$ 为积性函数, 故 $h$ 仅在 PN 处不为 $0$.

\begin{align*}
    F(n) & = \sum_{i=1}^{n} f(i)\\
         & = \sum_{i=1}^{n} \sum_{d|i}h(i)g(\frac{i}{d})\\
         & = \sum_{d=1}^{n} h(d) \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} g(i)\\
         & = \sum_{d~is~PN}^{n} h(d) G(\lfloor \frac{n}{d} \rfloor)
\end{align*}

搜索所有 PN, 维护出 $h(d)$ 即可计算, 因此需要求出 $h(p^c)$ 的值, 共 $O(\Pi(\sqrt{n})*\log{n}) = O(\sqrt{n})$ 个.

若能线性预处理 $h(p^c)$ , 则总复杂度为 $O(\sqrt{n})$.

若能快速求 $f(p^c)$ 和 $g(p^c)$, 则可以根据 $h(p^c)=f(p^c)-\sum_{i=1}^{c} g(p^i)h(p^{c-i})$, $O(\sqrt{n}\log{n})$ 预处理.

\quad 常见 $\frac{g(p^c)}{g(p^{c-1})}$ 为常数 $t$ 时, 易得:

\begin{align*}
    \sum_{i=1}^{c} g(p^{i})h(p^{c-i}) & = \sum_{i=0}^{c-1} g(p^{i+1})h(p^{c-i-1})\\
                              & = t \sum_{i=0}^{c-1} g(p^{i})h(p^{c-i-1})\\
                              & = t * f(p^{c-1})
\end{align*}

\quad 则 $h(p^c)=f(p^c)-t * f(p^{c-1})$.

若使用杜教筛求 $G$, 则总复杂度和杜教筛相同.
因为若事先计算一次 $G(n)$ , 则杜教筛过程中用到的 $G(\lfloor \frac{n}{d} \rfloor)$ 都是访问过的.

\paragraph{例题}\ 

$f(p^c)=\frac{p^c}{c}$

令 $g(x)=x$, 可求出 $h(p^c)=-\frac{p^c}{c(c-1)}$, 即可筛出 $F(n)$.

\begin{lstlisting}
// 求 g(x) 前缀和
inline ll gsum(ll x){
    return (__int128)x*(x+1)/2%p;
}

// 预处理 h(p^c)
vector<ll>H[N];

inline void get_h(ll n){
    for(int i=1;i<=tot;++i){
        __int128 prod=(ll)pri[i]*pri[i];
        int cnt=2;
        H[i].resize(2);
        while(prod<=n){
            H[i].push_back(sub(0,mul(mul(prod,inv[cnt]),inv[cnt-1])));
            prod*=pri[i];
            ++cnt;
        }
    }
}

ll ans;
// 搜索所有 PN, 同时维护 h(x), 统计答案
inline void dfs(int id,ll prod,ll h,ll n){
    ll t=pri[id];
    if(id>tot||(__int128)prod*t*t>n){
        ans=add(ans,mul(h,gsum(n/prod)));
        return ;
    }
    dfs(id+1,prod,h,n);
    prod*=t;
    int c=1;
    while((__int128)prod*t<=n){
        ++c;
        prod*=t;
        dfs(id+1,prod,mul(h,H[id][c]),n);
    }
}

inline ll Powerful_Number_Sieve(ll n){
    ans=0;
    inv[1]=1;
    for(int i=2;i<=64;++i){
        inv[i]=mul((p-p/i),inv[p%i]);
    }
    get_prime(sqrtl(n)); // 筛质数
    get_h(n);
    dfs(1,1,1,n);
}
\end{lstlisting}
\subsubsection{二次剩余}
\begin{lstlisting}
namespace FindRoot{
    int omega,p;
    struct comp{
        int a,b;
        inline comp(){}
        inline comp(int _a,int _b):a(_a),b(_b){}
    };

    inline comp operator *(const comp &x,const comp &y){
        return comp(((ll)x.a*y.a+(ll)x.b*y.b%p*omega)%p,((ll)x.a*y.b+(ll)y.a*x.b)%p);
    }

    inline bool check(int n){
        return qpow(n,(p-1)/2,p)==p-1;
    }

    inline comp qpow(comp a,int b){
        comp ans(1,0);
        while(b){
            if(b&1)ans=ans*a;
            a=a*a;
            b>>=1;
        }
        return ans;
    }

    inline int Cipolla(int n,int modular){
        p=modular;
        n%=p;
        if(n==0)return 0;
        if(check(n))return -1;
        while(1){
            int a=rand()%p;
            omega=((ll)a*a+p-n)%p;
            if(check(omega)){
                comp x=qpow(comp(a,1),(p+1)/2);
                return x.a;
            }
        }
    }
}
\end{lstlisting}
\subsubsection{K次剩余}
\begin{lstlisting}
inline ll qpow(ll a,ll b,int p){
    ll ans=1;
    while(b){
        if(b&1)(ans*=a)%=p;
        (a*=a)%=p;
        b>>=1;
    }
    return ans;
}

inline int getrt(int p){
    vector<int>f;
    int x=p-1;
    for(int i=2;i*i<=x;++i){
        if(x%i==0){
            f.push_back(i);
            while(x%i==0)x/=i;
        }
    }
    if(x!=1)f.push_back(x);
    for(int i=1;;++i){
        bool flag=1;
        for(int j=0;j<f.size();++j){
            if(qpow(i,(p-1)/f[j],p)==1){
                flag=0;
                break;
            }
        }
        if(flag)return i;
    }
}

const int N=999983;
struct Hash{
    int tot;
    int fir[N],nex[N],key[N],val[N];
    vector<int>vis;
    inline void clear(){
        for(int i=0;i<vis.size();++i){
            fir[vis[i]]=0;
        }
        vis.clear();
        tot=0;
    }

    inline void insert(int x,int v){
        int k=x%N;
        nex[++tot]=fir[k];
        key[tot]=x;
        val[tot]=v;
        if(!fir[k])(vis.push_back(k));
        fir[k]=tot;
    }

    inline int find(int x){
        int k=x%N;
        for(int i=fir[k];i;i=nex[i]){
            if(key[i]==x){
                return val[i];
            }
        }
        return -1;
    }
}mp;

inline int BSGS(int A,int B,int p){
    mp.clear();
    int m=sqrt(p)+1;
    ll t=1;
    for(int i=0;i<m;++i){
        mp.insert(t*B%p,i);
        t=t*A%p;
    }
    ll w=1;
    for(int i=1;i<=m;++i){
        w=w*t%p;
        int tmp=mp.find(w);
        if(~tmp){
            return m*i-tmp;
        }
    }
    assert(0);
}

int gcd(int a,int b){
    return b?gcd(b,a%b):a;
}

void exgcd(int a,int b,ll &x,ll &y){
    if(!b){
        x=1,y=0;
        return ;
    }
    exgcd(b,a%b,x,y);
    int t=x;
    x=y;
    y=t-a/b*y;
}

inline int inv(int a,int p){
    ll x,y;
    exgcd(a,p,x,y);
    return (x%p+p)%p;
}

inline vector<int> Ksqrt(int k,int a,int p){
    vector<int>Ans;
    int g=getrt(p);
    a=BSGS(g,a,p);
    int A=k,B=p-1;
    int t=gcd(A,B);
    if(a%t!=0)return Ans;
    A/=t,B/=t,a/=t;
    int k0=inv(A,B);
    A=(ll)k0*a%B;
    int ans=qpow(g,A,p),step=qpow(g,B,p);
    for(int i=A;i<p-1;i+=B){
        Ans.push_back(ans);
        ans=(ll)ans*step%p;
    }
    sort(Ans.begin(),Ans.end());
    return Ans;
}

int main(){
    // freopen(".in","r",stdin);
    // freopen(".out","w",stdout);
    int T;r(T);
    while(T--){
        int p,A,B;
        r(p),r(A),r(B);
        vector<int>t=Ksqrt(A,B,p);
        if(!t.size())puts("No Solution");
        else {
            for(int i=0;i<t.size();++i){
                printf("%d ",t[i]);
            }
            puts("");
        }
    }
}
\end{lstlisting}
\subsubsection{Pollard-rho}
\begin{lstlisting}
inline __int128 qpow(__int128 a,ll b,ll p){
    __int128 ans=1;
    while(b){
        if(b&1)(ans*=a)%=p;
        (a*=a)%=p;
        b>>=1;
    }
    return ans;
}

inline ll gcd(ll a,ll b){
    return b?gcd(b,a%b):a;
}

inline bool Miller_Rabin(ll p){
    if(p==2||p==3||p==5||p==7||p==11||p==13)return 1;
    if((p%2==0)||(p%3==0)||(p%5==0)||(p%7==0)||(p%11==0)||(p%13==0))return 0;
    ll t=p-1,c=0;
    while(!(t&1))t>>=1,++c;
    for(int i=0;i<10;++i){
        __int128 x=rand()%(p-2)+2;
        x=qpow(x,t,p);
        if(x==1||x==p-1)continue;
        for(int j=0;j<c-1;++j){
            (x*=x)%=p;
            if(x==p-1)break;
        }
        if(x!=p-1)return 0;
    }
    return 1;
}

inline ll Pollard_Rho(ll p){
    ll s=0,t=0;
    ll c=(ll)rand()%(p-1)+1;
    ll prod=1;
    for(int i=1;;i<<=1,s=t,prod=1){
        for(int j=0;j<i;++j){
            t=((__int128)t*t+c)%p;
            prod=(__int128)prod*abs(t-s)%p;
            if(j&127)continue;
            ll d=gcd(prod,p);
            if(d>1)return d;
        }
        ll d=gcd(prod,p);
        if(d>1)return d;
    }
}

vector<ll>factors;

void factor(ll p){
    if(p<2)return ;
    if(Miller_Rabin(p)){
        factors.push_back(p);
        return ;
    }
    ll t=p;
    while(t==p)t=Pollard_Rho(t);
    while(!(p%t))p/=t;
    factor(p),factor(t);
}
\end{lstlisting}
\subsubsection{ExLucas}
\begin{lstlisting}
void exgcd(int a,int b,int &x,int &y){
    if(b){
        exgcd(b,a%b,x,y);
        int t=x;
        x=y;
        y=t-a/b*y;
    }
    else x=1,y=0;
}

int inv(int a,int b){
    int x,y;
    exgcd(a,b,x,y);
    return (x%b+b)%b;
}

inline int CRT(int *f,int *m,int n,int p){
    int ans=0;
    for(int i=1;i<=n;++i){
        ans=(ans+(ll)f[i]*(p/m[i])%p*inv(p/m[i],m[i])%p)%p;
    }
    return ans;
}

inline ll qpow(ll a,ll b,int p){
    ll ans=1;
    while(b){
        if(b&1)(ans*=a)%=p;
        (a*=a)%=p;
        b>>=1;
    }
    return ans;
}

inline int F(ll n,int p,int pk){
    if(n==0)return 1;
    ll prod=1;
    for(int i=1;i<=pk;++i){
        if(i%p)(prod*=i)%=pk;
    }
    prod=qpow(prod,n/pk,pk);
    for(int i=0;i<=n-pk*(n/pk);++i){
        if(i%p)(prod*=i)%=pk;
    }
    return F(n/p,p,pk)*prod%pk;
}

inline int G(ll n,int p){
    return n<p?0:n/p+G(n/p,p);
}

inline int calc(ll n,ll m,int p,int pk){
    return (ll)F(n,p,pk)*inv(F(m,p,pk),pk)%pk*inv(F(n-m,p,pk),pk)%pk*qpow(p,G(n,p)-G(m,p)-G(n-m,p),pk)%pk;
}

int a[1005];
int b[1005];

inline int exLucas(ll n,ll m,int p){
    int tmp=p;
    int tot=0;
    for(int i=2;i*i<=p;++i){
        if(tmp%i==0){
            int pk=1;
            while(tmp%i==0){
                pk*=i;
                tmp/=i;
            }
            a[++tot]=pk;
            b[tot]=calc(n,m,i,pk);
        }
    }
    if(tmp!=1){
        a[++tot]=tmp;
        b[tot]=calc(n,m,tmp,tmp);
    }
    return CRT(b,a,tot,p);
}
\end{lstlisting}
\subsubsection{原根}
\paragraph{原根判定定理} 
设$m \ge 3$, $\gcd(a,m)=1$, 则$a$是模$m$的原根的充要条件是，对$\varphi(m)$的每个素因子$p$，都有$a^{\frac{\varphi(m)}{p}} \not \equiv 1 \mod m$.
\paragraph{原根个数定理} 
若一个数$m$有原根，则它原根的个数为$\varphi(\varphi(m))$。
\paragraph{原根存在定理}
一个数 $m$ 存在原根当且仅当 $m = 2, 4, p^\alpha, 2p^\alpha$，其中$p$为奇素数，$\alpha \in N^*$
\paragraph{最小原根的数量级}
最小原根不多于 $m^{0.25}$ 级别，可以暴力找。
\subsubsection{Pohlig Hellman}
\begin{lstlisting}
struct Pohlig_Hellman{
	const int mod;
	const int n;
	int g;
	vector<int>factor_p;
	vector<int>factor_pk;
	vector<int>gi;
	vector<unordered_map<int, int>> hs;
	
	Pohlig_Hellman(int mod) : mod(mod), n(mod - 1) { // n = phi(mod)
		int nn = n;
		for(int i = 2; i * i <= nn; ++i){
			if(nn % i == 0){
				int pk = 1;
				while(nn % i == 0){
					nn /= i;
					pk *= i;
				}
				factor_p.push_back(i);
				factor_pk.push_back(pk);
			}
		}
		if(nn != 1){
			factor_p.push_back(nn);
			factor_pk.push_back(nn);
		}
		for(g = 2; ; ++g){
			bool flag = 1;
			for(auto &p: factor_p){
				if(qpow(g, n / p, mod) == 1){
					flag = 0;
					break;
				}
			}
			if(flag) break;
		}
		hs.resize(factor_pk.size());
		for(int i = 0; i < factor_pk.size(); ++i){
			int pk = factor_pk[i];
			int m = sqrt(pk) + 1;
			gi.push_back(qpow(g, n / pk, mod));
			ll t = 1;
			ll gm = qpow(gi[i], m, mod);
			for(int j = 1; j <= m; ++j){
				t = t * gm % mod;
				hs[i][t] = j;
			}
		}
	}

	int calc(int x){
		vector<int> X;
		for(int i = 0; i < factor_pk.size(); ++i){
			int pk = factor_pk[i];
			int b = qpow(x, n / pk, mod);
			int a = gi[i];
			int m = sqrt(pk) + 1;
			ll t = 1;
			for(int j = 0; j < m; ++j){
				int v = b * t % mod;
				if(hs[i].find(v) != hs[i].end()){
					X.push_back((hs[i][v] * m - j) % pk);
					break;
				}
				t = t * a % mod;
			}
		}
		return CRT(X, factor_pk, n);
	}
};
\end{lstlisting}
\subsubsection{预处理离散对数}
\begin{lstlisting}
int Lg[M];
 
inline void init(){
    unordered_map<int, int> f;
    const int siz = 512;
    int t = qpow(g, siz, p);
    for(int i = 1, prod = 1; ; ++i){
        prod = (ll)prod * t % p;
        f[prod] = i * siz;
        if(i * siz > p - 1){
            break;
        }
    }
    for(int i = 1; i < M; ++i){
        ll prod = i;
        for(int j = 0; j < siz; ++j){
            if(f.find(prod) != f.end()){
                Lg[i] = (f[prod] - j) % (p - 1);
                break;
            }
            prod = prod * g % p;
        }
    }
}
 
inline int dislog(int x){
    if(x < M) return Lg[x];
    int r = p % x;
    if(r * 2 <= x){
        return sub(add((p - 1) / 2, dislog(r), p - 1), dislog(p / x), p - 1);
    }
    else{
        return sub(dislog(x - r), dislog(p / x + 1), p - 1);
    }
}
\end{lstlisting}

当质因子都比较小时，可以不用 BSGS
\begin{lstlisting}
struct Pohlig_Hellman{
	const int mod;
	const int n;
	int g;
	vector<int>factor_p;
	vector<int>factor_pk;
	vector<unordered_map<int, int>> ans;
	
	Pohlig_Hellman(int mod) : mod(mod), n(mod - 1) { // n = phi(mod)
		int nn = n;
		for(int i = 2; i * i <= nn; ++i){
			if(nn % i == 0){
				int pk = 1;
				while(nn % i == 0){
					nn /= i;
					pk *= i;
				}
				factor_p.push_back(i);
				factor_pk.push_back(pk);
			}
		}
		if(nn != 1){
			factor_p.push_back(nn);
			factor_pk.push_back(nn);
		}
		for(g = 2; ; ++g){
			bool flag = 1;
			for(auto &p: factor_p){
				if(qpow(g, n / p, mod) == 1){
					flag = 0;
					break;
				}
			}
			if(flag) break;
		}
		ans.resize(factor_pk.size());
		for(int i = 0; i < factor_pk.size(); ++i){
			int pk = factor_pk[i];
			ll t = 1;
			ll gg = qpow(g, n / pk, mod);
			for(int j = 0; j < pk; ++j){
				ans[i][t] = j;
				t = t * gg % mod;
			}
			assert(t == 1);
		}
	}
 
	int calc(int x){
		vector<int> X;
		for(int i = 0; i < factor_pk.size(); ++i){
			int pk = factor_pk[i];
			int b = qpow(x, n / pk, mod);
			X.push_back(ans[i][b]);
		}
		return CRT(X, factor_pk, n);
	}
};
\end{lstlisting}
\subsubsection{阶}
使用前先分解$p-1$
\begin{lstlisting}
inline ll insert(ll x){
    ll ord=p-1;
    int id=0;
    for(int i=1;i<=tot;++i){
        ord/=pk[i];
        ll t=qpow(x,ord,p);
        int cnt=0;
        while(t!=1){
            t=qpow(t,fp[i],p);
            ord*=fp[i];
            ++cnt;
        }
    }
    return ord;
}
\end{lstlisting}
注意到第6行对大指数做快速幂会比较慢，有一种分治写法可以减小常数
\begin{lstlisting}
struct Data{
    int l,r;
    ll v;
    Data(int _l=0,int _r=0,ll _v=0): l(_l),r(_r),v(_v){}
};

inline ll insert(ll x){
    ll ord=1;
    queue<Data>Q;
    Q.emplace(1,tot,x);
    while(!Q.empty()){
        auto t=Q.front();Q.pop();
        int &l=t.l;
        int &r=t.r;
        ll v=t.v;
        if(l>=r){
            for(ll v=t.v;v!=1;v=qpow(v,fp[l],p)){
                ord*=fp[l];
            }
        }
        else {
            int mid=(l+r)>>1;
            Q.emplace(l,mid,qpow(v,prod1[l][r],p));
            Q.emplace(mid+1,r,qpow(v,prod2[l][r],p));
        }
    }
    return ord
}
\end{lstlisting}
\subsubsection{拉格朗日反演}
常用形式:
若两个多项式 $F(x),G(x)$ ,都满足常数项为 $0$ , $1$ 次项不为 $0$ ,且两者互为复合逆,即, $G(F(x))=x$ ,则有
$$
\begin{aligned}
[x^n] F(x)=\frac 1 n [x^{-1}] \frac{1}{G^n(x)}\\
[x^n] F(x)=\frac 1 n [x^{n-1}] (\frac{x}{G(x)})^n
\end{aligned}
$$
拓展形式为：
$$
[x^n]H(F(x))=\frac 1 n[x^{n-1}]H'(x)(\frac x {G(x)})^n
$$
证明如下：\\
引理：
$$
[x^{-1}]F'(x)F^k(x)=[k=-1]
$$
当$k\not=-1$时
$$
F'(x)F^k(x)=(\frac{1}{k+1}F^{k+1}(x))
$$
显然多项式求导的$x^{-1}$项的系数为$0$\\
当$k=-1$时
$$
\begin{aligned}
    F^{-1}(x)F'(x)
    &={a_1+2a_2x+3a_3x^2+...\over a_1x+a_2x^2+a_3x^3+...}\\
    &=\frac{a_1+2a_2x+3a_3x^2+\cdots}{a_1x}\cdot \frac{1}{1+\left(\frac{a_2}{a_1}x+\frac{a_3}{a_1}x^2+\cdots\right)}\\
\end{aligned}
$$
后面一项的分母多项式常数项为$1$，故求逆后常数项仍为$1$，
前面一项多项式$x^-1$为最低次项且系数为$1$
所以
$$
[x^{-1}]F'(x)F^{-1}(x)=1
$$
即可得到
$$
\begin{aligned}
    F^k(G(x)) &= x^k \\
    (F^k)'(G)G' &= kx^{k-1} \\
    \sum\limits_i i([x^i] F^k)G^{i-1}G' &= kx^{k-1} \\
    \sum\limits_i i([x^i] F^k)G^{i-1-n}G' &= kx^{k-1} G^{-n} \\
    [x^{-1}]\sum\limits_i i([x^i] F^k)G^{i-1-n}G' &= [x^{-1}]kx^{k-1} G^{-n} \\
    n[x^n] F^k &= [x^{-1}] kx^{k-1}G^{-n} \\
    &= k[x^{-k}] G^{-n}
\end{aligned}
$$
\subsection{多项式相关}
\subsubsection{拉格朗日插值}
给 $n + 1$ 个点 $(x_0, y_0),\cdots,(x_n, y_n)$ 确定一个 $n$ 次多项式

令 
$$
\ell_i(x) = \prod_{j\not = i} \frac{x - x_j}{x_i - x_j}
$$

显然代入 $x = x_i$ 时，分子分母相同，$\ell_i(x) = 1$；
代入 $x = x_j (j\not = i)$ 时，分子为零分母不为零，$\ell_i(x) = 0$；
同时 $\ell_i(x)$ 是个 $n$ 次多项式。

容易构造 
$$
F(x) = \sum_{i = 0}^{n} \ell_i(x)y_i
$$

则$F(x)$是经过该 $n + 1$ 个点的至多 $n$ 次多项式。
代值计算的复杂度显然为 $O(n^2)$。

\begin{lstlisting}
typedef long long ll;

const int p=998244353;

inline ll qpow(ll a,int b){
    ll ans=1;
    while(b){
        if(b&1)ans=ans*a%p;
        a=a*a%p;
        b>>=1;
    }
    return ans;
}

inline ll sub(ll a,ll b){
    a-=b;
    if(a<0)a+=p;
    return a;
}

const int N=2005;

ll x[N],y[N];

int main(){
    int n,k;
    r(n);r(k);
    for(int i=1;i<=n;++i)r(x[i]),r(y[i]);
    ll ans=0;
    for(int i=1;i<=n;++i){
        ll ret=1;
        for(int j=1;j<=n;++j)if(i!=j)ret=ret*sub(x[i],x[j])%p;
        ret=qpow(ret,p-2);
        for(int j=1;j<=n;++j)if(i!=j)ret=ret*sub(k,x[j])%p;
        ans=(ans+ret*y[i])%p;
    }
    printf("%lld\n",ans);
}
\end{lstlisting}

当这 $n + 1$ 个点取值连续时，可以前缀后缀积优化，如 $x_i = i$ 时：
$$
\begin{aligned}
    \ell_i(x) &= \prod_{j\not = i} \frac{x - x_j}{x_i - x_j}\\
              &= \prod_{j = 0}^{n} (x - x_j) \cdot \frac{1}{x - x_i} \cdot \frac{1}{\prod_{j\not = i} x_i - x_j}\\
              &= \prod_{j = 0}^{n} (x - j) \cdot \frac{1}{x - i} \cdot \frac{1}{\prod_{j\not = i} i - j}\\
              &= \prod_{j = 0}^{n} (x - j) \cdot \frac{1}{x - i} \cdot \frac{1}{i!(n-i)!(-1)^{n-i}}
\end{aligned}
$$

另外，需要每次插入点重新插值时，可以使用重心拉格朗日插值
$$
F(x) = \sum_{i = 0}^{n} y_i\prod_{j\not = i} \frac{x - x_j}{x_i - x_j}\\
$$
我们注意到分子重复计算很多，设 $g(x) = \prod_{i = 0}^{n} x - x_i$，得
$$
F(x) = g(x)\sum_{i = 0}^{n} \frac{1}{x - x_i}\frac{y_i}{\prod_{j\not = i} x_i - x_j}\\
$$
我们提出只与已知点有关的项，设$t_i = \frac{y_i}{\prod_{j\not = i} x_i - x_j}$，有
$$
F(x) = g(x)\sum_{i = 0}^{n} \frac{t_i}{x - x_i}
$$
因此我们只需每次维护 $t_i$ 即可
\subsubsection{FFT}
\begin{lstlisting}
struct cmx{
    db r,i;
    cmx(){}
    cmx(db _r,db _i){r=_r;i=_i;}
    fr cmx op+(const cmx&x,const cmx&y){return cmx(x.r+y.r,x.i+y.i);}
    fr cmx op-(const cmx&x,const cmx&y){return cmx(x.r-y.r,x.i-y.i);}
    fr cmx op*(const cmx&x,const cmx&y){return cmx(x.r*y.r-x.i*y.i,x.r*y.i+x.i*y.r);}
    fr cmx op/(const cmx&x,const db&y){return cmx(x.r/y,x.i/y);}
}a[N<<2],b[N<<2];

int r[N<<2];
const db pi=acos(-1.0);

inline void fft(cmx *t,int len,int on){
    for(int i=0;i<len;++i)if(i<r[i])swap(t[i],t[r[i]]);
    for(int i=1;i<len;i<<=1){
        cmx wn(cos(pi/i),on*sin(pi/i));
        for(int j=0;j<len;j+=(i<<1)){
            cmx w(1,0);
            for(int k=0;k<i;++k,w=w*wn){
                cmx u=t[j+k];
                cmx v=w*t[j+k+i];
                t[j+k]=u+v;
                t[j+k+i]=u-v;
            }
        }
    }
    if(on==-1)for(int i=0;i<len;++i)t[i]=t[i]/len;
}
\end{lstlisting}
\subsubsection{NTT}
\begin{lstlisting}
inline void ntt(int *A,int len,bool opt=1){
    for(int i=0;i<len;++i)rev[i]=(rev[i>>1]>>1)|((i&1)*(len>>1));
    for(int i=0;i<len;++i)if(i<rev[i])swap(A[i],A[rev[i]]);
    for(int i=2;i<=len;i<<=1){
        int wn=qpow(g,(p-1)/i),n=i>>1;
        if(opt==0)wn=qpow(wn,p-2);
        for(int j=0;j<len;j+=i){
            int w=1;
            for(int k=0;k<n;++k,w=1ll*w*wn%p){
                int u=A[j+k],v=1ll*A[j+k+n]*w%p;
                A[j+k]=(u+v)%p;
                A[j+k+n]=(u-v+p)%p;
            }
        }
    }
    if(!opt){
        int inv=qpow(len,p-2);
        for(int i=0;i<len;++i)A[i]=1ll*A[i]*inv%p;
    }
}
\end{lstlisting}
\subsubsection{MTT}
\begin{lstlisting}
inline void mtt(int *A,int n,int *B,int m,int *C,int P){
    int l,i,p=sqrt(P),t;
    
    for(i=0;i<=n;++i){t=A[i];t%=P;a[i]=cmx(t/p,0);b[i]=cmx(t%p,0);}
    for(i=0;i<=m;++i){t=B[i];t%=P;c[i]=cmx(t/p,0);d[i]=cmx(t%p,0);}
    
    for(m+=n,n=1,l=0;n<=m;n<<=1)++l;
    for(len=n,i=0;i<n;++i)r[i]=(r[i>>1]>>1)|(i&1)<<(l-1);
    
    fft(a,n,1);fft(b,n,1);fft(c,n,1);fft(d,n,1);
    for(i=0;i<n;++i){
        s1[i]=a[i]*c[i];
        s2[i]=a[i]*d[i]+b[i]*c[i];
        s3[i]=b[i]*d[i];
    }
    fft(s1,n,-1);fft(s2,n,-1);fft(s3,n,-1);
    for(i=0;i<=m;++i)C[i]=(((ll)(s1[i].r+0.5)%P*p%P*p%P+(ll)(s2[i].r+0.5)%P*p%P)%P+(ll)(s3[i].r+0.5)%P)%P;
}
\end{lstlisting}
\subsubsection{FFT/MTT多项式乘法优化}
P3803 【模板】多项式乘法-3DFT
\begin{lstlisting}
#include<cmath>
#include<cstdio>
#include<iostream>
#include<algorithm>

using namespace std;

#define db double
#define fr friend
#define op operator
#define N 4000010
#define gc c=getchar()
#define r(x) read(x)

template<typename T>
inline void read(T&x){
    x=0;T k=1;char gc;
    while(!isdigit(c)){if(c=='-')k=-1;gc;}
    while(isdigit(c)){x=x*10+c-'0';gc;}x*=k;
}

struct cmx{
    db r,i;
    cmx(){}
    cmx(db _r,db _i){r=_r;i=_i;}
    fr cmx op+(const cmx&x,const cmx&y){return cmx(x.r+y.r,x.i+y.i);}
    fr cmx op-(const cmx&x,const cmx&y){return cmx(x.r-y.r,x.i-y.i);}
    fr cmx op*(const cmx&x,const cmx&y){return cmx(x.r*y.r-x.i*y.i,x.r*y.i+x.i*y.r);}
}a[N],b[N];

int r[N];
const db pi=acos(-1.0);

inline void fft(cmx *t,int len,int on){
    for(int i=0;i<len;++i)if(i<r[i])swap(t[i],t[r[i]]);
    for(int i=1;i<len;i<<=1){
        cmx wn(cos(pi/i),on*sin(pi/i));
        for(int j=0;j<len;j+=(i<<1)){
            cmx w(1,0);
            for(int k=0;k<i;++k,w=w*wn){
                cmx u=t[j+k];
                cmx v=w*t[j+k+i];
                t[j+k]=u+v;
                t[j+k+i]=u-v;
            }
        }
    }
}

int main(){
    register int n,m,l,i;r(n);r(m);
    for(i=0;i<=n;++i)r(a[i].r);
    for(i=0;i<=m;++i)r(b[i].r);
    for(m+=n,n=1,l=0;n<=m;++l)n<<=1;
    for(i=0;i<n;++i)r[i]=(r[i>>1]>>1)|(i&1)<<(l-1);
    fft(a,n,1);fft(b,n,1);
    for(i=0;i<n;++i)a[i]=a[i]*b[i];
    fft(a,n,-1);
    for(i=0;i<=m;++i)printf("%d ",int(a[i].r/n+0.5));
}
\end{lstlisting}
P3803 【模板】多项式乘法-1.5DFT
\begin{lstlisting}
#include<bits/stdc++.h>

using namespace std;

#define gc c=getchar()

template<typename T>
inline void read(T&x){
	x=0;T k=1;char gc;
	while(!isdigit(c)){if(c=='-')k=-1;gc;}
	while(isdigit(c)){x=x*10+c-'0';gc;}x*=k;
}

struct comp{
	double r,i;
	comp():r(0),i(0){}
	comp(const double &_r,const double &_i):r(_r),i(_i){}
};

inline comp operator + (const comp &a,const comp &b){
	return comp(a.r+b.r,a.i+b.i);
}

inline comp operator - (const comp &a,const comp &b){
	return comp(a.r-b.r,a.i-b.i);
}

inline comp operator * (const comp &a,const comp &b){
	return comp(a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r);
}

inline comp operator / (const comp &a,const double &b){
	return comp(a.r/b,a.i/b);
}

inline comp conj(const comp &a){
	return comp(a.r,-a.i);
}

const double PI=acos(-1.0);
const int N=2e6+7;

int rev[N];
comp Wn[N];
int Now_Len;
inline void revinit(int n){
	for(int i=0;i<n;++i)rev[i]=(rev[i>>1]>>1)|((i&1)*(n>>1));
	Wn[0]=comp(1,0);
	Wn[1]=comp(cos(2*PI/n),sin(2*PI/n));
	for(int i=2;i<n;++i)Wn[i]=Wn[i-1]*Wn[1];
	Now_Len=n;
}

inline void DFT(comp *A,int n){
	if(Now_Len!=n)revinit(n);
	for(int i=0;i<n;++i)if(i<rev[i])swap(A[i],A[rev[i]]);
	for(int i=1;i<n;i<<=1){
		for(int j=0;j<n;j+=i<<1){
			for(int k=0;k<i;++k){
				comp u=A[j+k],v=A[i+j+k]*Wn[n/(i<<1)*k];
				A[j+k]=u+v;
				A[i+j+k]=u-v;
			}
		}
	}
}

inline void IDFT(comp *A,int n){
	if(Now_Len!=n)revinit(n);
	for(int i=0;i<n;++i)if(i<rev[i])swap(A[i],A[rev[i]]);
	for(int i=1;i<n;i<<=1){
		for(int j=0;j<n;j+=i<<1){
			for(int k=0;k<i;++k){
				comp u=A[j+k],v=A[i+j+k]*conj(Wn[n/(i<<1)*k]);
				A[j+k]=u+v;
				A[i+j+k]=u-v;
			}
		}
	}
	for(int i=0;i<n;++i){
		A[i]=A[i]/n;
	}
}

comp F[N],G[N],H[N];
inline void mul(int *A,int *B,int *C,int lenA,int lenB){
	int lenC=lenA+lenB-1,n;
	for(n=1;n<lenC;n<<=1);n>>=1;
	for(int i=0;i<n;++i){
		F[i]=comp(((i<<1)<lenA)?A[i<<1]:0,((i<<1|1)<lenA)?A[i<<1|1]:0);
		G[i]=comp(((i<<1)<lenB)?B[i<<1]:0,((i<<1|1)<lenB)?B[i<<1|1]:0);
	}
	DFT(F,n);DFT(G,n);
	for(int i=0,j;i<n;++i){
		j=(n-i)&(n-1);
		/*
		comp A0=(F[i]+conj(F[j]))*comp(0.5,0);
		comp A1=(F[i]-conj(F[j]))*comp(0,-0.5);
		comp B0=(G[i]+conj(G[j]))*comp(0.5,0);
		comp B1=(G[i]-conj(G[j]))*comp(0,-0.5);
		comp d0=A0*B0+Wn[i]*A1*B1;
		comp d1=A1*B0+A0*B1;
		H[i]=d0+d1*comp(0,1);
		*/
		H[i]=F[i]*G[i]-(comp(1,0)+Wn[i])*(F[i]-conj(F[j]))*(G[i]-conj(G[j]))*comp(0.25,0);
	}
	IDFT(H,n);
	for(int i=0;(i<<1)<lenC;++i){
		C[i<<1]=int(H[i].r+0.5);
		C[i<<1|1]=int(H[i].i+0.5);
	}
}

int A[N],B[N];
int main(){
	int n,m;read(n),read(m);++n,++m;
	for(int i=0;i<n;++i)read(A[i]);
	for(int i=0;i<m;++i)read(B[i]);
	mul(A,B,A,n,m);
	for(int i=0;i<n+m-1;++i)printf("%d ",A[i]);
}
\end{lstlisting}
P3803 【模板】多项式乘法-2DFT
\begin{lstlisting}
#include<bits/stdc++.h>

using namespace std;

#define gc c=getchar()

template<typename T>
inline void read(T&x){
    x=0;T k=1;char gc;
    while(!isdigit(c)){if(c=='-')k=-1;gc;}
    while(isdigit(c)){x=x*10+c-'0';gc;}x*=k;
}

struct comp{
    double r,i;
    comp():r(0),i(0){}
    comp(const double &_r,const double &_i):r(_r),i(_i){}
};

inline comp operator + (const comp &a,const comp &b){
    return comp(a.r+b.r,a.i+b.i);
}

inline comp operator - (const comp &a,const comp &b){
    return comp(a.r-b.r,a.i-b.i);
}

inline comp operator * (const comp &a,const comp &b){
    return comp(a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r);
}

inline comp operator / (const comp &a,const double &b){
    return comp(a.r/b,a.i/b);
}

inline comp conj(const comp &a){
    return comp(a.r,-a.i);
}

const comp Tmp=comp(0,-0.25);
const double PI=acos(-1.0);
const int N=4e6+7;

int rev[N];
inline void revinit(int n){
    for(int i=0;i<n;++i)rev[i]=(rev[i>>1]>>1)|((i&1)*(n>>1));
}

int Now_Len;
inline void FFT(comp *A,int n,int opt){
    if(Now_Len!=n)revinit(n);
    for(int i=0;i<n;++i)if(i<rev[i])swap(A[i],A[rev[i]]);
    for(int i=1;i<n;i<<=1){
        comp wn(cos(PI/i),opt*sin(PI/i));
        for(int j=0;j<n;j+=i<<1){
            comp w(1,0);
            for(int k=0;k<i;++k,w=w*wn){
                comp u=A[j+k],v=A[i+j+k]*w;
                A[j+k]=u+v;
                A[i+j+k]=u-v;
            }
        }
    }
    if(opt==-1){
        for(int i=0;i<n;++i)A[i]=A[i]/n;
    }
}

#define DFT(A,n) FFT(A,n,1);
#define IDFT(A,n) FFT(A,n,-1);

comp F[N],G[N];
inline void mul(int *A,int *B,int *C,int lenA,int lenB){
    int lenC=lenA+lenB-1,n;
    for(n=1;n<lenC;n<<=1);
    for(int i=0;i<n;++i)F[i]=comp(A[i],B[i]);
    DFT(F,n);
    for(int i=0,j;i<n;++i)j=(n-i)&(n-1),G[j]=(F[j]*F[j]-conj(F[i]*F[i]))*Tmp;
    IDFT(G,n);
    for(int i=0;i<lenC;++i)C[i]=int(G[i].r+0.5);
}

int A[N],B[N];
int main(){
    int n,m;read(n),read(m);++n,++m;
    for(int i=0;i<n;++i)read(A[i]);
    for(int i=0;i<m;++i)read(B[i]);
    mul(A,B,A,n,m);
    for(int i=0;i<n+m-1;++i)printf("%d ",A[i]);
}
\end{lstlisting}
P4245 【模板】任意模数NTT-4DFT
\begin{lstlisting}
#include<bits/stdc++.h>

using namespace std;

#define gc c=getchar()
#define ll long long
#define db double 

template<typename T>
inline void read(T&x){
    x=0;T k=1;char gc;
    while(!isdigit(c)){if(c=='-')k=-1;gc;}
    while(isdigit(c)){x=x*10+c-'0';gc;}x*=k;
}

struct comp{
    db r,i;
    comp(){}
    comp(const db &_r,const db &_i):r(_r),i(_i){}
};

inline comp operator + (const comp &a,const comp &b){
    return comp(a.r+b.r,a.i+b.i);
}

inline comp operator - (const comp &a,const comp &b){
    return comp(a.r-b.r,a.i-b.i);
}

inline comp operator * (const comp &a,const comp &b){
    return comp(a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r);
}

inline comp operator / (const comp &a,const db &b){
    return comp(a.r/b,a.i/b);
}

inline comp conj(const comp &a){
    return comp(a.r,-a.i);
}

const db PI=acos(-1.0);
const int N=4e5+7;

int rev[N];
comp Wn[N];
int Now_Len;
inline void revinit(int n){
    for(int i=0;i<n;++i)rev[i]=(rev[i>>1]>>1)|((i&1)*(n>>1));
    for(int i=0;i<n;++i)Wn[i]=comp(cos(PI*i/n),sin(PI*i/n));
    Now_Len=n;
}

inline void DFT(comp *A,int n){
    if(Now_Len!=n)revinit(n);
    for(int i=0;i<n;++i)if(i<rev[i])swap(A[i],A[rev[i]]);
    for(int i=1;i<n;i<<=1){
        for(int j=0;j<n;j+=i<<1){
            for(int k=0;k<i;++k){
                comp u=A[j+k],v=A[i+j+k]*Wn[n/i*k];
                A[j+k]=u+v;
                A[i+j+k]=u-v;
            }
        }
    }
}

inline void IDFT(comp *A,int n){
    if(Now_Len!=n)revinit(n);
    for(int i=0;i<n;++i)if(i<rev[i])swap(A[i],A[rev[i]]);
    for(int i=1;i<n;i<<=1){
        for(int j=0;j<n;j+=i<<1){
            for(int k=0;k<i;++k){
                comp u=A[j+k],v=A[i+j+k]*conj(Wn[n/i*k]);
                A[j+k]=u+v;
                A[i+j+k]=u-v;
            }
        }
    }
    for(int i=0;i<n;++i){
    	A[i]=A[i]/n;
    }
}

#define DFT(A) DFT(A,n)
#define IDFT(A) IDFT(A,n)

int p;
comp a[N],b[N],c[N],d[N];
inline void MTT(int *A,int *B,int *C,int lenA,int lenB){
    int lenC=lenA+lenB-1,n;
    if(lenC<=256){
    	memset(C,0,lenC<<2);
    	for(int i=0;i<lenA;++i){
    		for(int j=0;j<lenB;++j){
    			C[i+j]=(C[i+j]+(ll)A[i]*B[j])%p;
    		}
    	}
    	return ;
    }
    for(n=1;n<lenC;n<<=1);
    for(int i=0;i<lenA;++i)a[i]=comp(A[i]&32767,A[i]>>15);
    for(int i=0;i<lenB;++i)b[i]=comp(B[i]&32767,B[i]>>15);
    DFT(a);DFT(b);
    for(int i=0;i<n;++i){
        int j=(n-i)&(n-1);
        comp A0=(a[i]+conj(a[j]))*comp(0.5,0);
        comp A1=(a[i]-conj(a[j]))*comp(0,-0.5);
        comp B0=(b[i]+conj(b[j]))*comp(0.5,0);
        comp B1=(b[i]-conj(b[j]))*comp(0,-0.5);
        c[i]=A0*B0+A0*B1*comp(0,1);
        d[i]=A1*B0+A1*B1*comp(0,1);
    }
    IDFT(c);IDFT(d);
    for(int i=0;i<n;++i){
        ll s1=(ll)(c[i].r+0.5)%p;
        ll s2=(ll)(c[i].i+0.5)%p;
        ll s3=(ll)(d[i].r+0.5)%p;
        ll s4=(ll)(d[i].i+0.5)%p;
        C[i]=(s1+((s2+s3)<<15)+(s4<<30))%p;
    }
}

int A[N],B[N],C[N];
int main(){
    int n,m;read(n),read(m),read(p);++n,++m;
    for(int i=0;i<n;++i)read(A[i]),A[i]%=p;
    for(int i=0;i<m;++i)read(B[i]),B[i]%=p;
    MTT(A,B,C,n,m);
    for(int i=0;i<n+m-1;++i)printf("%d ",C[i]);
}
\end{lstlisting}
P4245 【模板】任意模数NTT-7DFT
\begin{lstlisting}
#include<cmath>
#include<cstdio>
#include<iostream>
#include<algorithm>

using namespace std;

#define db long double
#define fr friend
#define op operator
#define N 400005
#define gc c=getchar()
#define r(x) read(x)
#define ll long long
#define rint register int

template<typename T>
inline void read(T&x){
    x=0;T k=1;char gc;
    while(!isdigit(c)){if(c=='-')k=-1;gc;}
    while(isdigit(c)){x=x*10+c-'0';gc;}x*=k;
}

struct cmx{
    db r,i;
    cmx(){}
    cmx(db _r,db _i){r=_r;i=_i;}
    fr cmx op+(const cmx&x,const cmx&y){return cmx(x.r+y.r,x.i+y.i);}
    fr cmx op-(const cmx&x,const cmx&y){return cmx(x.r-y.r,x.i-y.i);}
    fr cmx op*(const cmx&x,const cmx&y){return cmx(x.r*y.r-x.i*y.i,x.r*y.i+x.i*y.r);}
    fr cmx op/(const cmx&x,const db &y){return cmx(x.r/y,x.i/y);}
    fr cmx op*(const cmx&x,const db &y){return cmx(x.r*y,x.i*y);}
}a[N],b[N],c[N],d[N],s1[N],s2[N],s3[N],Wn[N];

int r[N],len;
const db pi=acos(-1.0);

inline void fft(cmx *t,int on=1){
    rint i,j,k;
    for(i=0;i<len;++i)if(i<r[i])swap(t[i],t[r[i]]);
    for(i=1;i<len;i<<=1){
        cmx wn(Wn[i].r,on*Wn[i].i);
        for(j=0;j<len;j+=(i<<1)){
            cmx w(1,0);
            for(k=0;k<i;++k,w=w*wn){
                cmx u=t[j+k];
                cmx v=w*t[j+k+i];
                t[j+k]=u+v;
                t[j+k+i]=u-v;
            }
        }
    }
    if(on==-1)for(i=0;i<len;++i)t[i].r/=len;
}

int P,p;

int main(){
    rint t,n,m,l,i;r(n);r(m);r(P);p=sqrt(P);
    
    for(i=0;i<=n;++i){read(t);t%=P;a[i]=cmx(t/p,0);b[i]=cmx(t%p,0);}
    for(i=0;i<=m;++i){read(t);t%=P;c[i]=cmx(t/p,0);d[i]=cmx(t%p,0);}
    
//	for(i=0;i<=n;++i)cout<<a[i].r<<" ";puts("");
//	for(i=0;i<=n;++i)cout<<b[i].r<<" ";puts("");
//	for(i=0;i<=m;++i)cout<<c[i].r<<" ";puts("");
//	for(i=0;i<=m;++i)cout<<d[i].r<<" ";puts("");
    
    for(m+=n,n=1,l=0;n<=m;n<<=1,++l)Wn[n]=cmx(std::cos(pi/n),std::sin(pi/n));
    for(len=n,i=0;i<n;++i)r[i]=(r[i>>1]>>1)|(i&1)<<(l-1);
    
    fft(a,1);fft(b,1);fft(c,1);fft(d,1);
    for(i=0;i<n;++i){
        s1[i]=a[i]*c[i];
        s2[i]=a[i]*d[i]+b[i]*c[i];
        s3[i]=b[i]*d[i];
    }
    fft(s1,-1);fft(s2,-1);fft(s3,-1);
    
    for(i=0;i<=m;++i)printf("%lld ",(((ll)(s1[i].r+0.5)%P*p%P*p%P+(ll)(s2[i].r+0.5)%P*p%P)%P+(ll)(s3[i].r+0.5)%P)%P);
}
\end{lstlisting}
\subsubsection{多项式乘法}
\begin{lstlisting}
int Tmp_mul1[N],Tmp_mul2[N];
inline void mul(int *A,int *B,int *C,int lenA,int lenB){
	int len=1,lenC=lenA+lenB-1;
	while(len<lenC)len<<=1;
	memcpy(Tmp_mul1,A,lenA<<2);
	memcpy(Tmp_mul2,B,lenB<<2);
	memset(Tmp_mul1+lenA,0,(len-lenA)<<2);
	memset(Tmp_mul2+lenB,0,(len-lenB)<<2);
	ntt(Tmp_mul1,len);ntt(Tmp_mul2,len);
	for(int i=0;i<len;++i)C[i]=1ll*Tmp_mul1[i]*Tmp_mul2[i]%p;
	ntt(C,len,0);
	memset(C+lenC,0,(len-lenC)<<2);
}
\end{lstlisting}
\subsubsection{多项式求逆}
对于给定$F(x)$

求出$G(x)$使得
$$
G(x)F(x) \equiv 1 \mod x^n
$$
设$G_0(x)$满足
$$
G_0(x)F(x) \equiv 1 \mod x^{\lceil \frac{n}{2}\rceil}
$$
两式相减
$$
G(x)-G_0(x)\equiv 0 \mod x^{\lceil \frac{n}{2}\rceil}
$$
两边平方
$$
G^2(x)-2G_0(x)G(x)+G_0^2(x)\equiv 0 \mod x^n
$$
两边同时乘上$F(x)$
$$
G(x)-2G_0(x)+F(x)G_0^2(x)\equiv 0 \mod x^n
$$
$$
G(x)=(2-G_0(x)F(x))G_0(x) \mod x^n
$$

对于$n=1$

直接对常数项求逆

其余情况倍增即可
\begin{lstlisting}
int Tmp_inv[N];
inline void inverse(int *A,int *Inv,int len){
    memset(Inv,0,len<<3);
    Inv[0]=qpow(A[0],p-2);
    for(int i=2;i<=len;i<<=1){
        memcpy(Tmp,A,i<<2);
        memset(Tmp+i,0,i<<2);
        ntt(Inv,i<<1,1);
        ntt(Tmp,i<<1,1);
        for(int k=0;k<i<<1;++k)Inv[k]=Inv[k]*(2-1ll*Inv[k]*Tmp[k]%p+p)%p;
        ntt(Inv,i<<1,-1);
        memset(Inv+i,0,i<<2);
    }
}
\end{lstlisting}
\subsubsection{多项式除法}
对于给定$F(x),G(x)$

求出$D(x),R(x)$使得
$$
F(x)=D(x)G(x)+R(x)
$$

并且满足
$$
deg_D=deg_F-deg_G
$$
$$
deg_R=deg_G-1
$$
$R(x)$可以有最高位为$0$的情况

令$A^R(x)=x^{deg_A}A(\frac{1}{x})$

相当于翻转$A$的系数

令$n=deg_F,m=deg_G$
$$
F(\frac{1}{x})=D(\frac{1}{x})G(\frac{1}{x})+R(\frac{1}{x})
$$
$$
x^nF(\frac{1}{x})=x^{n-m}D(\frac{1}{x})x^{m}G(\frac{1}{x})+x^nR(\frac{1}{x})
$$
$$
F^R(x)=D^R(x)G^R(x)+x^{n-m+1}R^R(x)
$$
$$
F^R(x)\equiv D^R(x)G^R(x) \mod x^{n-m+1}
$$
$$
D^R(x)\equiv F^R(x){{G}^{R}}^{-1}(x) \mod x^{n-m+1}
$$
多项式求逆得到${{G}^{R}}^{-1}(x)$

多项式乘法得到$D^R(x)$

最后再算出$R(x)$
\begin{lstlisting}
int A0[N],B0[N];
inline void division(int* A,int* B,int* D,int* R,int lenA,int lenB){
	int len=1,t=lenA-lenB+1;
	while(len<=t)len<<=1;
	reverse_copy(B,B+lenB,A0);
	inverse(A0,B0,len);
	reverse_copy(A,A+lenA,A0);
	mul(A0,B0,A0,t,t);
	reverse(A0,A0+t);
	copy(A0,A0+t,D);
	for(len=1;len<(lenA<<1);len<<=1);
	copy(B,B+lenB,B0);
	mul(A0,B0,R,t,lenB);
	for(int i=0;i<lenB-1;++i)R[i]=(A[i]-R[i]+p)%p;
}
\end{lstlisting}
\subsubsection{多项式牛顿迭代}
对于给定$F(x)$

求出$G(x)$使得
$$
F(G(x))\equiv 0 \mod x^n
$$
令$G_0(x)$满足
$$
F(G_0(x))\equiv 0 \mod x^{\lceil \frac{n}{2} \rceil}
$$
将$F(G(x))$在$G_0(x)$处展开
$$
F(G(x))=F(G_0(x))+\frac{F'(G_0(x))}{1!}(G(x)-G_0(x))+\frac{F''(G_0(x))}{2!}{(G(x)-G_0(x))}^2+...
$$
因为$G(x)$与$G_0(x)$的前$\lceil \frac{n}{2} \rceil$项相同

$G(x)-G_0(x)$的$x$次幂的前$x^{\lceil \frac{n}{2} \rceil}$项都是$0$

所以
$$
F(G(x))\equiv F(G_0(x))+F'(G_0(x))(G(x)-G_0(x)) \equiv 0\mod x^n
$$
$$
G(x)\equiv G_0(x)-\frac{F(G_0(x))}{F'(G_0(x))} \mod x^n
$$

不过一般是知道了关于 $G$ 的一个式子, 需要求出 $G$, 再来构造 $F(x)$, 倍增求 $G$.
\subsubsection{多项式开根}
对于给定$F(x)$

求出$G(x)$使得
$$
G^2(x)\equiv F(x) \mod x^n
$$
令

$$
A(G(x))=G^2(x)-F(x)
$$

要求$G(x)$使得

$$
A(G(x))\equiv 0 \mod x^n
$$

由多项式牛顿迭代
$$
G(x)\equiv G_0(x)-\frac{G_0^2(x)-F(x)}{2G_0}\mod x^n
$$
$$
G(x)\equiv \frac{G_0^2(x)+F(x)}{2G_0}\mod x^n
$$
\begin{lstlisting}
const int Inv2=499122177;
int Tmp_sqrt1[N],Tmp_sqrt2[N];
inline void sqrt(int *A, int *Sqrt, int len){
//	Sqrt[0]=1;//A[0]==1
	Sqrt[0]=std::sqrt(A[0]); //using Cipolla algorithm when needed
	for(int i=1;i<=len;i<<=1){
		for(int j=0;j<i;++j)Tmp_sqrt2[j]=2ll*Sqrt[j]%p;
		memset(Tmp_sqrt1,0,i<<2);
		inverse(Tmp_sqrt2,Tmp_sqrt1,i);
		for(int j=i;j<(i<<1);++j)Tmp_sqrt1[j]=0;
		memcpy(Tmp_sqrt2,A,i<<2);
		mul(Tmp_sqrt1,Tmp_sqrt2,Tmp_sqrt1,i,i);
		for(int j=0;j<(i<<1);++j)Sqrt[j]=(1ll*Inv2*Sqrt[j]+Tmp_sqrt1[j])%p;
    }
}
\end{lstlisting}
\subsubsection{多项式求导}
\begin{lstlisting}
inline void differentiate(int *A,int *Dif,int len){
	for(int i=1;i<len;++i)Dif[i-1]=1ll*A[i]*i%p;
	Dif[len-1]=0;
}
\end{lstlisting}
\subsubsection{多项式积分}
\begin{lstlisting}
inline void integrate(int *A,int *Int,int len){
	for(int i=len-1;i>=1;--i)Int[i]=1ll*A[i-1]*qpow(i,p-2)%p;
	Int[0]=0;
}
\end{lstlisting}
\subsubsection{多项式对数函数}
对于给定$F(x)$

求出$G(x)$使得
$$
G(x)\equiv \ln(F(x)) \mod x^n
$$
求导可得
$$
G'(x)=\frac{F'(x)}{F(x)}
$$
多项式求导求出$F'(x)$

多项式求逆求出$\frac{1}{F(x)}$

多项式乘法求出$G'(x)$

多项式积分求出$G(x)$
\begin{lstlisting}
int Inv_ln[N];
inline void ln(int *A,int *Ln,int n){
	inverse(A,Inv_ln,n);
    differentiate(A,Ln,n); 
	mul(Ln,Inv_ln,Ln,n,n);
	integrate(Ln,Ln,n<<1);
	memset(Ln+n,0,n<<2);
	memset(Inv_ln,0,n<<3);
}
\end{lstlisting}
\subsubsection{多项式指数函数}
对于给定$F(x)$

求出$G(x)$使得
$$
G(x)\equiv e^{F(x)} \mod x^n
$$

两边取对数
$$
\ln(G(x))-F(x)\equiv 0 \mod x^n
$$

多项式牛顿迭代
$$
G(x)\equiv G_0(x)-\frac{\ln(G_0(x))-F(x)}{\frac{1}{G_0(x)}} \mod x^n
$$
$$
 G(x) \equiv (1-\ln(G_0(x))+F(x))G_0(x) \mod x^n
$$
\begin{lstlisting}
int Ln[N];
inline void exp(int *A,int *Exp,int n){
    Exp[0]=1;//A[0]==0 
    for(int i=2;i<=(n<<1);i<<=1){
        memcpy(Ln,Exp,i<<2);
        ln(Ln,Ln,i);
        for(int j=0;j<i;++j)Ln[j]=(A[j]+(j==0)+p-Ln[j])%p;
		mul(Exp,Ln,Exp,i,i);
    }
}
\end{lstlisting}
\subsubsection{多项式k次幂}
对于给定$F(x)$

求出$G(x)$使得
$$
G(x)\equiv F^k(x) \mod x^n
$$
先两边取对数
$$
\ln(G(x))=k\ln(F(x))
$$
通过多项式求对数函数得到$\ln(F(x))$

算出$\ln(G(x))$

然后多项式求指数函数得到$G(x)$

注意这个方法会损失常数项

需要单独处理
\begin{lstlisting}
int Tmp_pow[N];
inline void pow(int *A,int*Pow,int n,int k){
	int len=1;
	while(len<n)len<<=1;
//	memset(Tmp_pow,0,sizeof(ll)*len);
	ln(A,Tmp_pow,len);
	for(int i=0;i<n;++i)Tmp_pow[i]=1ll*Tmp_pow[i]*k%p;
	exp(Tmp_pow,Pow,len);
}
\end{lstlisting}
\subsubsection{拉格朗日插值多项式}
输入多项式的项数和在$0,1,2,\cdots,n-1$处的取值，求出这个多项式。
\begin{lstlisting}
#include<bits/stdc++.h>

using namespace std;

#define gc c=getchar()
#define r(x) read(x)
#define ll long long

template<typename T>
inline void read(T&x){
    x=0;T k=1;char gc;
    while(!isdigit(c)){if(c=='-')k=-1;gc;}
    while(isdigit(c)){x=x*10+c-'0';gc;}x*=k;
}

typedef vector<int> poly;

const int N=50005;
const int p=2013265921;
const int g=31;

inline ll qpow(ll a,int b){
    int ans=1;
    for(;b;b>>=1){
        if(b&1)ans=ans*a%p;
		a=a*a%p;
	}
    return ans;
}

inline ll inv(ll x){
	return qpow(x,p-2);
}

inline ll add(ll a,ll b){
	a+=b;
	if(a>=p)a-=p;
	return a;
}

inline ll sub(ll a,ll b){
	a-=b;
	if(a<0)a+=p;
	return a;
}

inline void ntt(poly &A,bool opt=1) {
	int len=A.size();
	for(int i=1,j=len>>1,k;i<len-1;++i){
        if(i<j)swap(A[i],A[j]);
        k=len>>1;
        while(j>=k){j-=k,k>>=1;}
        if(j<k)j+=k;
    }
	for(int i=2;i<=len;i<<=1){
		int n=i>>1,wn=qpow(g,(p-1)/i);
        if(!opt)wn=qpow(wn,p-2);
        for(int j=0;j<len;j+=i){
            ll w=1;
            for(int k=0;k<n;++k,w=w*wn%p){
                int u=A[j+k+n]*w%p;
                A[j+k+n]=sub(A[j+k],u);
                A[j+k]=add(A[j+k],u);
            }
        }
	}
	if(!opt){
		ll inv=qpow(len,p-2);
		for(int i=0;i<len;++i)A[i]=A[i]*inv%p;
	}
}

poly Tmp1,Tmp2;
inline void mul(poly &A,poly &B,poly &C){
	int len=1,lenA=A.size(),lenB=B.size(),lenC=lenA+lenB-1;
	while(len<lenC)len<<=1;
	Tmp1=A;Tmp1.resize(len);
	Tmp2=B;Tmp2.resize(len);
	ntt(Tmp1);ntt(Tmp2);
	for(int i=0;i<len;++i)Tmp1[i]=(ll)Tmp1[i]*Tmp2[i]%p;
	ntt(Tmp1,0);
	C=Tmp1;C.resize(lenC);
}

inline void add(poly &A,poly &B,poly &C){
	int len=A.size();
	C.resize(len);
	for(int i=0;i<len;++i)C[i]=add(A[i],B[i]);
}

int fac[N];
int n;
void lagrange(int l,int r,poly &A,poly &B){
	if(l==r){
		A.resize(2);
		A[0]=sub(p,l);
		A[1]=1;
		B.resize(1);
		r(B[0]);
		B[0]=(ll)B[0]*fac[l]%p*fac[n-l-1]%p;
		if((n-l-1)&1)B[0]=sub(p,B[0]);
	}
	else {
		int mid=(l+r)>>1;
		poly A1,A2,B1,B2;
		lagrange(l,mid,A1,B1);
		lagrange(mid+1,r,A2,B2);
		mul(A1,A2,A);
		mul(A1,B2,A1);
		mul(A2,B1,A2);
		add(A1,A2,B);
	}
}

//int rt[10000000];
//inline int get_root(){
//	for(int i=2;i<p-1;++i)if((p-1)%i==0)rt[++rt[0]]=i;
//	for(int i=2;;++i){
//		bool flag=1;
//		for(int j=1;flag&&j<=rt[0];++j)if(qpow(i,rt[j])==1)flag=0;
//		if(flag)return i;
//	}
//}

int main(){
//	freopen("polynomial.in","r",stdin);
//	freopen("polynomial.out","w",stdout);

//	cout<<get_root();
	r(n);
	fac[0]=1;
	for(int i=1;i<n;++i)fac[i]=(ll)fac[i-1]*i%p;
	fac[n-1]=inv(fac[n-1]);
	for(int i=n-1;i;--i)fac[i-1]=(ll)fac[i]*i%p;
	poly A,B;
	lagrange(0,n-1,A,B);
	for(int i=0;i<n;++i)printf("%d\n",B[i]);
}
/*
3
1
6
17

*/
\end{lstlisting}
\subsubsection{线性递推}
BM + 暴力多项式取模
\begin{lstlisting}
namespace BerlekampMassey{

	typedef vector<int> poly;
	
	#define len(A) A.size()
	
	inline poly mul(const poly &A,const poly&B,const poly&F){
		poly ret(len(F)*2-1);
		for(int i=0;i<len(F);++i){
			for(int j=0;j<len(F);++j){
			    ret[i+j]=add(ret[i+j],(ll)A[i]*B[j]%p);
			}
		}
		for(int i=len(F)*2-2;i>=len(F);--i){
			for(int j=0;j<len(F);++j){
			    ret[i-j-1]=add(ret[i-j-1],(ll)ret[i]*F[j]%p);
			}
		}
		ret.resize(len(F));
		return ret;
	}
	
	inline int solve(const poly &A,const poly &F,ll n){
		if(n<len(A))return A[n];
		poly base(len(F)),ans(len(F));
		base[1]=ans[0]=1;
		for(;n;n>>=1){
			if(n&1)ans=mul(ans,base,F);
			base=mul(base,base,F);
		}
		int ret=0;
		for(int i=0;i<len(F);++i)ret=add(ret,(ll)A[i]*ans[i]%p);
		return ret;
	}
	
	inline poly BM(const poly& A){
		poly F,F0;
		int d0,p0;
		for(int i=0;i<len(A);++i){
			int d=0;
			for(int j=0;j<len(F);++j){
				d=add(d,(ll)F[j]*A[i-j-1]%p);
			}
			d=sub(d,A[i]);
			if(!d)continue;
			if(!len(F)){
				F.resize(i+1);
				d0=d;
				p0=i;
				continue;
			}
			ll t=qpow(d0,p-2)*d%p;
			poly G(i-p0-1);
			G.push_back(t);
			t=sub(0,t);
			for(int j=0;j<len(F0);++j){
				G.push_back(F0[j]*t%p);
			}
			if(len(G)<len(F))G.resize(len(F));
			for(int j=0;j<len(F);++j){
				G[j]=add(G[j],F[j]);
			}
			if(i-p0+len(F0)>=len(F)){
				F0=F;
				d0=d;
				p0=i;
			}
			F=G;
		}
		return F;
	}
	
	inline int main(const poly &A,ll n){
		return solve(A,BM(A),n);
	}
}

int F[]={0,1,1,2,3,5,8,13};

int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	ll n;r(n);
	printf("%d\n",BerlekampMassey::main(vector<int>(F,F+(sizeof(F))/4),n));
}
\end{lstlisting}
NTT多项式取模
P4723 【模板】线性递推
\begin{lstlisting}
#include<bits/stdc++.h>

using namespace std;

#define gc c=getchar()
#define r(x) read(x)
#define ll long long

template<typename T>
inline void read(T&x){
    x=0;T k=1;char gc;
    while(!isdigit(c)){if(c=='-')k=-1;gc;}
    while(isdigit(c)){x=x*10+c-'0';gc;}x*=k;
}

const int N=500000;
const int p=998244353;
const int g=3;

inline int qpow(int a,int b){
    int ans=1;
    for(;b;b>>=1){
        if(b&1)ans=1ll*ans*a%p;
        a=1ll*a*a%p;
    }
    return ans;
}

namespace polynomial{
    int r[N];
    int NOW_LEN;
    inline void ntt(int *A,int len,int opt=1){
        if(len!=NOW_LEN)for(int i=0;i<len;++i)r[i]=(r[i>>1]>>1)|((i&1)*(len>>1));
        NOW_LEN=len;
        for(int i=0;i<len;++i)if(i<r[i])swap(A[i],A[r[i]]);
        for(int i=2;i<=len;i<<=1){
            int wn=qpow(g,(p-1)/i),n=i>>1;
            if(!opt)wn=qpow(wn,p-2);
            for(int j=0;j<len;j+=i){
                int w=1;
                for(int k=0;k<n;++k,w=1ll*w*wn%p){
                    int u=A[j+k],v=1ll*A[j+k+n]*w%p;
                    A[j+k]=(u+v)%p;
                    A[j+k+n]=(u-v+p)%p;
                }
            }
        }
        if(!opt){
            int inv=qpow(len,p-2);
            for(int i=0;i<len;++i)A[i]=1ll*A[i]*inv%p;
        }
    }
    
    int Tmp_mul1[N],Tmp_mul2[N];
    inline void mul(int *A,int *B,int *C,int lenA,int lenB){
        int len=1,lenC=lenA+lenB-1;
        while(len<lenC)len<<=1;
        memcpy(Tmp_mul1,A,lenA<<2);
        memcpy(Tmp_mul2,B,lenB<<2);
        memset(Tmp_mul1+lenA,0,(len-lenA)<<2);
        memset(Tmp_mul2+lenB,0,(len-lenB)<<2);
        ntt(Tmp_mul1,len);ntt(Tmp_mul2,len);
        for(int i=0;i<len;++i)C[i]=1ll*Tmp_mul1[i]*Tmp_mul2[i]%p;
        ntt(C,len,0);
        memset(C+lenC,0,(len-lenC)<<2);
    }
    
    int Tmp_inv[N];
    inline void inverse(int *A,int *Inv,int len){
        memset(Inv,0,len<<2);
        Inv[0]=qpow(A[0],p-2);
        for(int i=2;i<=len;i<<=1){
            memcpy(Tmp_inv,A,i<<2);
            memset(Tmp_inv+i,0,i<<2);
            ntt(Inv,i<<1);ntt(Tmp_inv,i<<1);
            for(int k=0;k<i<<1;++k)Inv[k]=Inv[k]*(2-1ll*Inv[k]*Tmp_inv[k]%p+p)%p;
            ntt(Inv,i<<1,0);
            memset(Inv+i,0,i<<2);
        }
    }
    
    int A0[N],B0[N];
    inline void mod(int A[],int B[],int R[],int lenA,int lenB){
        int len=1,t=lenA-lenB+1;
        while(len<=t)len<<=1;
        reverse_copy(B,B+lenB,A0);
        inverse(A0,B0,len);
        reverse_copy(A,A+lenA,A0);
        mul(A0,B0,A0,t,t);
        reverse(A0,A0+t);
        for(len=1;len<(lenA<<1);len<<=1);
        copy(B,B+lenB,B0);
        mul(A0,B0,R,t,lenB);
        for(int i=0;i<lenB-1;++i)R[i]=(A[i]-R[i]+p)%p;
    }
}

int n,k;

int Tmp[N<<1];

inline void mul(int a[],int b[],int f[]){
    polynomial::mul(a,b,Tmp,k,k);
    polynomial::mod(Tmp,f,a,2*k,k+1);
}

int base[N],ans[N];

inline int solve(int a[],int f[],int n){
    if(n<k)return a[n];
    
    reverse(f,f+k);
    for(int i=0;i<k;++i)f[i]=p-f[i];
    f[k]=1;
    
    base[1]=ans[0]=1;
    for(;n;n>>=1){
        if(n&1)mul(ans,base,f);
        mul(base,base,f);
    }
    int ret=0;
    for(int i=0;i<k;++i)ret=(ret+(ll)a[i]*ans[i]%p)%p;
    return ret;
}

int a[N],f[N];

int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
    r(n);r(k);
    for(int i=0;i<k;++i)r(f[i]),f[i]=(f[i]+p)%p;
    for(int i=0;i<k;++i)r(a[i]),a[i]=(a[i]+p)%p;
    printf("%d\n",solve(a,f,n));
}
/*
6 4
3 -1 0 4
-2 3 1 5

*/

\end{lstlisting}
\subsubsection{生成函数}
\subsection{组合数学}
\subsubsection{斯特林数}

\paragraph{第二类斯特林数}\ 

第二类斯特林数 $ \begin{Bmatrix} n\\ k \end{Bmatrix}$, 也记作 $S(n,k)$, 表示将 $n$ 个两两不同的元素，划分为 $k$ 个互不区分的非空子集的方案数。

讨论第 $n$ 个元素的放法, 要么新放一个集合, 要么选择一个已有的集合放入, 可以得到递推公式:

\begin{align*}
    \begin{Bmatrix} n\\ k \end{Bmatrix} = \begin{Bmatrix} {n-1}\\ {k-1} \end{Bmatrix} + k \begin{Bmatrix} {n-1}\\ k \end{Bmatrix}
\end{align*}

边界情况是 $\begin{Bmatrix} n\\ 0 \end{Bmatrix}=[N=0]$

枚举空盒子个数容斥可以得出通项公式:

\begin{align*}
    \begin{Bmatrix} n\\ m \end{Bmatrix} = \frac{1}{m!}\sum_{k=0}^{m}(-1)^k \binom{m}{k} (m-k)^n
\end{align*}

注意到卷积形式, 可以在 $O(n\log n)$的时间内求出 $\begin{Bmatrix} n\\ 0 \end{Bmatrix}, \begin{Bmatrix} n\\ 1 \end{Bmatrix}, ... ,\begin{Bmatrix} n\\ n \end{Bmatrix}$

\paragraph{第一类斯特林数}\ 

第一类斯特林数 $ \begin{bmatrix} n\\ k \end{bmatrix}$, 也记作 $s(n,k)$, 表示将 $n$ 个两两不同的元素，划分为 $k$ 个互不区分的非空轮换的方案数。

有符号的第一类斯特林数是 $(-1)^{n-k} \begin{bmatrix} n\\ k \end{bmatrix}$.

讨论第 $n$ 个元素的放法, 要么新放一个轮换, 要么选择一个已有的轮换的一个位置放入, 可以得到递推公式:

\begin{align*}
    \begin{bmatrix} n\\ k \end{bmatrix} = \begin{bmatrix} {n-1}\\ {k-1} \end{bmatrix} + (n-1) \begin{bmatrix} {n-1}\\ k \end{bmatrix}
\end{align*}

边界情况是 $\begin{bmatrix} n\\ 0 \end{bmatrix}=[N=0]$

第一类斯特林数没有实用的通项公式。

\paragraph{性质1}

\begin{align*}
    x^n &= \sum_{k=0}^{n} \begin{Bmatrix} n\\ k \end{Bmatrix} \binom{x}{k} k!\\
        &= \sum_{k=0}^{n} \begin{Bmatrix} n\\ k \end{Bmatrix} x^{\underline{k}}
\end{align*}
考虑这个式子的组合意义, 就是将 $n$ 个球放入 $x$ 个盒子, 枚举非空的盒子个数即可得到上式.

另外还有三个普通幂, 上升幂, 下降幂相关的式子:

\begin{align*}
    x^n &= \sum_{k=0}^{n} \begin{Bmatrix} n\\ k \end{Bmatrix} (-1)^{n-k} x^{\overline{k}}    
\end{align*}

\begin{align*}
    x^{\overline{n}} &= \sum_{k=0}^{n} \begin{bmatrix} n\\ k \end{bmatrix} x^k
\end{align*}

\begin{align*}
    x^{\underline{n}} &= \sum_{k=0}^{n} \begin{bmatrix} n\\ k \end{bmatrix} (-1)^{n-k} x^k
\end{align*}

\paragraph{性质2}
由于排列和非空轮换划分一一对应, 容易得到:
\begin{align*}
    n! = \sum_{k=0} \begin{bmatrix} n\\ k \end{bmatrix}
\end{align*}

\paragraph{斯特林数的生成函数}\ 

从性质一可以看到, 无符号第一类斯特林数每行的生成函数是升阶函数, 有符号的则是降阶函数.

\begin{proof}
    \begin{align*}
        f(x)=x^{\overline{n}} = x \cdot (x+1) \cdot (x+2) \cdots (x+n-1)
    \end{align*}

    $[x^k]f(x)$ 就是选了 $k$ 个 $x$, 然后选了 $n-k-1$ 个常数.
    
    考虑最后一项的选择, 如果选 $x$, 系数就是 $x^{\overline{n-1}}$ 中 $x^{k-1}$ 的系数; 
    如果选 $n-1$, 系数就是 $x^{\overline{n-1}}$ 中 $x^{k}$ 的系数乘上 $n-1$. 
    这恰好是第一类斯特林数的递推公式. 

    有符号第一类斯特林数的生成函数的证明就是把常数全部变成负的就行.
\end{proof}

据此我们可以通过求多项式 $x^{\overline{n}}$ 求出第一类斯特林数一行的取值.

考虑倍增, $x^{\overline{2n}}=x^{\overline{n}}((x+n)^{\overline{n}})$, 只要对于 $F(x)=x^{\overline{n}}$ 快速求出 $F(x+c)$ 即可.
注意对 $x^{\overline{2n+1}}$ 的情况, 先算 $x^{\overline{2n}}$ 直接暴力乘一个 $(x+2n)$ 上去就行, 递归最多 $log$ 层.

二项式定理拆开每一项:
\begin{align*}
    F(x+c) &= \sum_{i=0}^{n} f_i (x+c)^i \\
           &= \sum_{i=0}^{n} f_i \sum_{j=0}^{i} \binom{i}{j} x^j c^{i-j}\\
           &= \sum_{j=0}^{n} \frac{x^j}{j!} \sum_{i=j}^{n} i! f_i \frac{c^{i-j}}{(i-j)!}
\end{align*}

后面显然是卷积形式, 将 $i!f_i$ 翻转一下, 下标从 $i$ 变成 $n-i-1$, 贡献到了 $n-j-1$, 再翻转一次就贡献到 $j$ 的位置了.

代码: P5408 第一类斯特林数·行
\begin{lstlisting}
inline void solve(int* f, int n){
    if(n==1){
        f[1]=1;
        return ;
    }
    if(n&1){
        solve(f,n-1);
        for(int i=n;i;--i){
            f[i]=((ll)f[i]*(n-1)+f[i-1])%p;
        }
    }
    else{
        solve(f,n>>1);
        for(int i=0;i<=(n>>1);++i){
            A[i]=(ll)fac[(n>>1)-i]*f[(n>>1)-i]%p;
        }
        ll prod=1;
        for(int i=0;i<=(n>>1);++i){
            B[i]=prod*facinv[i]%p;
            (prod*=(n>>1))%=p;
        }
        mul(A,B,A,(n>>1)+1,(n>>1)+1);
        for(int i=0;i<=(n>>1);++i){
            B[i]=(ll)facinv[i]*A[(n>>1)-i]%p;
        }
        mul(f,B,f,(n>>1)+1,(n>>1)+1);
    }
}
\end{lstlisting}

利用生成函数同样可以对列计算第一类斯特林数, 此时轮换个数固定为 $k$, 将每个轮换的生成函数乘起来就是答案, 直接多项式 Exp.

单个轮换的指数型生成函数为 $f(x)=\sum \frac{1}{i!} (i-1)!x^i = \sum \frac{x^i}{i}$, 
有 $[x^n](f(x))^k= \frac{1}{n!} \cdot \begin{bmatrix} n\\ k \end{bmatrix} \cdot k!$. 
乘一个 $k!$ 是因为计算的轮换是有区分的, 但斯特林数是不区分的.

不过需要注意的是, 这里 $[x^0]f(x)=0$, 求 Ln 是没有意义的, 需要加强版的 Exp. (提公因式出来, 再将常数项消成 $1$).
\subsection{群论}
% https://www.cnblogs.com/Appleblue17/p/14238216.html
% https://www.luogu.com.cn/blog/command-block/qun-lun-xiao-ji
% https://oi-wiki.org/math/permutation-group/
% https://fanfansann.blog.csdn.net/article/details/113763883
% https://www.luogu.com.cn/training/47217

\subsubsection{基本定义}
\paragraph{群}\ 

给一个集合 $G$ 和 $G$ 上的二元运算 $*$, 满足\textbf{封闭性}, \textbf{结合律}, \textbf{存在单位元}, \textbf{存在逆元}, 则称集合 $G$ 是运算 $*$ 下的一个群, 记作 $(G, *)$.

若群的大小有限, 则称群的大小 $|G|$ 为群的阶.

另外, 如果还满足交换律, 就是一个阿贝尔群.
\paragraph{子群}\

设 $G$ 在 $*$ 下是一个群，若 $H$ 是 $G$ 的非空子集且 $H$ 在 $*$ 运算下也是一个群，则称 $(H, ∗)$ 是 $(G, ∗)$ 的子群.

\paragraph{置换}\ 

有限集合到自身的双射（即一一对应）称为置换。集合 $S=\{a_1,a_2,...,a_n\}$ 上的置换可以表示为

\begin{align*}
    f = \binom{a_1,a_2,...,a_n}{a_{p_1},a_{p_2},...,a_{p_n}}
\end{align*}

表示将 $a_i$ 映射到 $a_{p_i}$, 其中 $\{p_1,p_2,...,p_n\}$ 是一个排列.

对于两个置换 $f = \binom{a_1,a_2,...,a_n}{a_{p_1},a_{p_2},...,a_{p_n}}$ 
和 $g = \binom{a_{p_1},a_{p_2},...,a_{p_n}}{a_{q_1},a_{q_2},...,a_{q_n}}$,
$f$ 和 $g$ 的乘积记为 $f \circ g$

\begin{align*}
    f \circ g = f = \binom{a_1,a_2,...,a_n}{a_{q_1},a_{q_2},...,a_{q_n}}
\end{align*}
 
简单来说就是先后经过 $f$ 的映射，再经过 $g$ 的映射。

可以证明, 集合 $S$ 上的所有置换关于置换的乘法满足封闭性、结合律、有单位元（恒等置换，即每个元素映射成它自己）、有逆元（交换置换表示中的上下两行），因此构成一个群。
这个群的任意一个\textbf{子群}即称为\textbf{置换群}。

把置换看做一张有向图, 连边 $i\rightarrow a_i$, 因为每个点只有一个出度一个入度, 所以会形成若干个环。 

循环置换是一类特殊的置换，可表示为

\begin{align*}
    \binom{a_1,a_2,...,a_{n-1},a_n}{a_{2},a_{3},...,a_{n},a{1}}
\end{align*}

简记为 $(a_1,a_2,...,a_{n-1},a_n)$.

若两个循环置换不含有相同的元素，则称它们是\textbf{不相交} 的。

可以知道, 任意一个置换都可以分解为若干不相交的循环置换的乘积.
\subsubsection{Burnside 引理}
设 $G$ 是 $1,2,...,n$ 的一个置换群.

有如下定义:

\begin{itemize}
    \item 对 $p \in G$, 若 $k \xrightarrow{p} k$, 则称 $k$ 是 $p$ 下的\textbf{不动点}, 不动点的集合记为 $c(p)$.
    \item 对于 $p \in G$, 若 $k$ 是 $p$ 下的不动点, 则 $p$ 属于\textbf{$k$ 不动置换类}, 记为 $Z_k$, 为 $G$ 的一个子群.
    \item 对元素 $k$ 施加 $G$ 中任意置换, 能够获得的元素集合记作\textbf{等价类 $E_k$}.\\
          如 $G=\{e,(1,2),(3,4),(1,2)\circ (3,4)\}$, 则 $E_1=\{1,2\}$.
\end{itemize}

\begin{theorem} 
    当 $x,y$ 属于一个等价类时, 有 $|Z_x|=|Z_y|$.
\end{theorem}

\begin{proof}\ 

    根据等价类的定义, $\exists p_0 \in G, x \xrightarrow{p_0} y, y \xrightarrow{p_0^{-1}} x$.

    假设 $x \xrightarrow{p} x$, 则 $y \xrightarrow{p_0^{-1}\circ p \circ p_0} y$.

    故 $\forall p \in Z_x, \exists p'=p_0^{-1}\circ p \circ p_0 \in Z_y$.

    同理, $\forall p \in Z_y, \exists p'=p_0\circ p \circ p_0^{-1} \in Z_y$.

    所以 $|Z_x|=|Z_y|$.
\end{proof}

\begin{theorem} 轨道-稳定化子定理

    \begin{align*}
        |Z_k| \times |E_k| = |G|
    \end{align*}
\end{theorem}

\begin{proof}\ 

    设 $E_k=\{a_1,a_2,...,a_m\}$, 有 $\forall a_i, \exists p_i \in G, x \xrightarrow{p_i}=a_i$.

    设 $G_i = \{p = p' \circ p_i | p' \in Z_k\}$, 则 $\forall p \in G_i, x \xrightarrow{p} a_i$.

    由于对 $x$ 作用的结果不同, $G_i$ 互不相交, 但由于封闭性, 它们都属于 $G$. 
    
    同时 $G$ 中所有元素作用在 $k$ 上都会得到 $a_i$ 中的一种.
    
    因此 $|G|=\sum_{i=1}^{m} |G_i| = \sum_{i=1}^{m} |Z_k| = |E_k| \times |Z_k|$

\end{proof}

\begin{theorem} Burnside引理
    
    设等价类个数为 $l$, 第$t$个等价类代表元素为$s_t$, 有
    
    \begin{align*}
        l = \frac{1}{|G|}\sum_{p \in G}|c(p)|
    \end{align*}

    即等价类个数=置换下不动点个数的平均数。
\end{theorem}

\begin{proof}\ 

    设 $G=\{p_1,p_2,...,p_m\}$, 有

    \begin{align*}
        \sum_{i=1}^{m}|c(p_i)| &= \sum_{i=1}^{m}\sum_{k=1}^{n} [k \xrightarrow{a_i} k] \\
                             &= \sum_{k=1}^{n}\sum_{i=1}^{m} [k \xrightarrow{a_i} k] \\
                             &= \sum_{k=1}^{n} |Z_k|\\
                             &= \sum_{t=1}^{l} \sum_{k\in E_{S_t}} |Z_k|\\
                             &= \sum_{t=1}^{l} |E_{S_t}|\times|Z_{S_t}|\\
                             &= l \times |G|
    \end{align*}
\end{proof}

\begin{theorem} 带权 Burnside 引理
    
    
    设 $G=\{p_1,p_2,...,p_m\}$ 为在 $1,2,...,n$ 上的置换群.

    \begin{itemize}
        \item 给每个元素 $k \in \{1\sim n\}$ 一个权值 $\omega(k)$, 定义不动点集合$c(p)$的权重为$\omega(c(p)) = \sum_{k\in c(p)} \omega(k)$.
        \item 给每个置换 $p \in G$ 一个权值 $\Omega(p)$, 定义不动置换类 $Z_k$ 的权值为 $\Omega(Z_k) = \sum_{p \in Z_k} \Omega(p)$
    \end{itemize}

    有如下结论:

    \begin{align*}
        \sum_{i=1}^{m}\Omega(p_i)\omega(c(p_i)) = \sum_{k=1}^{n}\omega(k)\Omega(Z_k)
    \end{align*}

\end{theorem}

\begin{proof}\ 
    
    \begin{align*}
        \sum_{i=1}^{m}\Omega(p_i)\omega(c(p_i)) &= \sum_{i=1}^{m}\Omega(p_i)\sum_{k=1}^{n} \omega(k)[k \xrightarrow{a_i} k] \\
                                                &= \sum_{k=1}^{n}\omega(k)\sum_{i=1}^{m} \Omega(p_i)[k \xrightarrow{a_i} k] \\
                                                &= \sum_{k=1}^{n}\omega(k)\Omega(Z_k)
    \end{align*}
\end{proof}

这个版本看起来比一般的 Burnside 引理还要清晰, 
其证明不需要用到轨道-稳定子群定理, 
结论也更弱, 
其实就是 Burnside 引理证明的前几步推导,
交换求和顺序即可证明.

可以看到, 只要令 $\Omega(p)=x$, 就是只有元素带权的 Burnside 引理.

$$
    \sum_{i=1}^{m}x\cdot \omega(c(p_i)) = \sum_{k=1}^{n}\omega(k)(|Z_k|\cdot x)
$$

两边约去 $x$, 有

\begin{align*}
    \sum_{i=1}^{m}\omega(c(p_i)) &= \sum_{k=1}^{n}\omega(k)|Z_k|\\
                                 &= \sum_{k=1}^{n}\omega(k)\frac{|G|}{|E_k|}
\end{align*}

整理可得

$$
    \frac{1}{|G|}\sum_{i=1}^{m}\omega(c(p_i)) = \sum_{k=1}^{n}\frac{\omega(k)}{|E_k|}
$$

类似也可写出只有置换带权的版本, 不过看起来没啥用.
如果进一步令$\omega(k)=y$, 就回到了一般的 Burnside 引理.

$$
    \frac{1}{|G|}\sum_{i=1}^{m}|c(p_i)| = \sum_{k=1}^{n}\frac{1}{|E_k|} = l
$$

后面一个等号是显然的, 因为每个等价类的贡献都是 $1$.
\subsubsection{Burnside 引理的经典应用}
\paragraph{烷基计数}\ 

实际上就是对 $n$ 个点构成的\textbf{度数不超过$3$的无标号有根树} 计数, 但是儿子交换是同构的.

设答案为 $a_n$, 对于儿子交换同构, 实际上就是根的儿子在置换群 $G$ 下的等价类个数, 其中

\begin{align*}
    G=\{e=(1)\circ(2)\circ(3),(1,2,3),(3,1,2),(1)\circ(2,3),(1,2)\circ(3),(1,3)\circ(2)\} 
\end{align*}

枚举三个儿子的节点个数, 可以计算出每种置换下的不动点个数, 于是得到递推式

\begin{align*}
    a_n=\sum_{i+j+k=n-1}\frac{1}{6}(a_i a_j a_k + [i=j=k]a_i + [i=j=k]a_i + [j=k]a_i a_j + [i=j]a_i a_k + [i=k]a_i a_j)
\end{align*}

设生成函数 $A(x)=\sum_{i=0}^{\infty} a_i x^i$, 有

\begin{align*}
    A(x)=1+x\frac{A(x)^3+2A(x^3)+3A(x^2)A(x)}{6}
\end{align*}

至于这个看起来就很诡异的东西的计算, 可以利用多项式牛顿迭代.

简单回顾一下,就是对于给定$F(x)$, 求出$G(x)$使得

$$
F(G(x))\equiv 0 \mod x^n
$$

只需求出$G_0(x)$满足
$$
F(G_0(x))\equiv 0 \mod x^{\lceil \frac{n}{2} \rceil}
$$

则有
$$
G(x)\equiv G_0(x)-\frac{F(G_0(x))}{F'(G_0(x))} \mod x^n
$$

所以我们设 
$$
F(A(x))=1+x\frac{A(x)^3+2A(x^3)+3A(x^2)A(x)}{6}-A(x)=0
$$

这里有一个trick,
假如我们求出了 $A_0(x) \mod x^{\lceil \frac{n}{2} \rceil}$, 
那么我们就已知了 $A(x^2) \mod x^n$ 和 $A(x^3) \mod x^n$, 
(因为$A_0(x^2)$的前$n$项就是$A(x^2)$的前$n$项), 
所以可以将它们看成常数, 则
$$
F'(A(x))=x\frac{3A(x)^2+3A(x^2)}{6}-1
$$

于是可以得到
\begin{align*}
    A(x) &\equiv A_0(x)-\frac{F(A_0(x))}{F'(A_0(x))} \mod x^n\\
         &\equiv A_0(x)-\frac{1+x\frac{A_0(x)^3+2A_0(x^3)+3A_0(x^2)A_0(x)}{6}-A_0(x)}{x\frac{3A_0(x)^2+3A_0(x^2)}{6}-1} \mod x^n\\
         &\equiv A_0(x)-\frac{x(A_0(x)^3+2A_0(x^3)+3A_0(x^2)A_0(x))-6A_0(x)+6}{x(3A_0(x)^2+3A_0(x^2))-6} \mod x^n
\end{align*}

复杂度 $O(n\log n)$.

\begin{lstlisting}
// get number of alkyl from 0 to n-1
inline void alkyl(int* F, int n){
    static int A[N],B[N],C[N];
    F[0]=1;
    for(int i=2;(i>>1)<n;i<<=1){
        for(int j=0;j<i;++j)A[j]=F[j];
        ntt(A,i<<1,1);
        for(int j=0;j<i<<1;++j)B[j]=1ll*A[j]*A[j]%p;
        ntt(B,i<<1,-1);
        memset(B+i,0,i<<2);
        C[0]=p-6;
        for(int j=0;j+1<i;++j)C[j+1]=B[j];
        for(int j=0;j*2+1<i;++j)inc(C[j*2+1],3ll*F[j]%p);
        ntt(C,i<<1,1);
        for(int j=0;j<i<<1;++j)C[j]=1ll*C[j]*A[j]%p;
        ntt(C,i<<1,-1);
        memset(C+i,0,i<<2);
        for(int j=0;j*3+1<i;++j)inc(C[j*3+1],2ll*F[j]%p);
        inc(C[0],6);
        for(int j=0;j*2<i;++j)inc(B[j*2],F[j]);
        for(int j=i-1;~j;--j)B[j+1]=3ll*B[j]%p;
        B[0]=p-6;
        inverse(B,A,i);
        ntt(A,i<<1,1);
        ntt(C,i<<1,1);
        for(int j=0;j<i<<1;++j)C[j]=1ll*C[j]*A[j]%p;
        ntt(C,i<<1,-1);
        memset(C+i,0,i<<2);
        for(int j=0;j<i;++j)dec(F[j],C[j]);
    }
}
\end{lstlisting}

\paragraph{烷烃计数}\ 

实际上就是对 $n$ 个点构成的\textbf{度数不超过$4$的无标号无根树} 计数.

无标号无根树计数的套路是钦定根为重心，减掉不合法的方案数。

假设$A(x)$是烷基的生成函数, $F(x)$是烷烃的生成函数, 还是考虑 Burnside 引理, 
\begin{itemize}
    \item $(1,1,1,1)$ 型($1$代表对应循环节长度, 下同): $1$ 种; 
    \item $(1,1,2)$ 型: $\binom{4}{2}=6$种;
    \item $(1,3)$ 型: $\binom{4}{3}\times 2=8$种;
    \item $(2,2)$ 型: $\binom{4}{2}\times \frac{1}{2}=3$种;
    \item $(4)$ 型: $4!-1-6-8-3=6$种.
\end{itemize}

\begin{align*}
    F(x)=x\frac{A(x)^4+6A(x)^2A(x^2)+8A(x)A(x^3)+3A(x^2)^2+6A(x^4)}{24}
\end{align*}

接下来进行去重, 考虑根不是重心的方案数, 此时必存在一个儿子所在子树的大小大于 $\lfloor \frac{n}{2} \rfloor$.

我们考虑枚举这个子树, 显然这个子树是个烷基, 剩下的部分也是烷基, 
直接减去 $\sum_{k=\lfloor \frac{n}{2} \rfloor+1}^{n-1}a_k a_{n-k}$.
注意两边都不能空, 所以 $k$ 只到$n-1$.

不过即使根是重心, 如果树有双重心, 还是会算重,
即一个子树大小恰好是 $\frac{n}{2}$, 与剩下部分大小恰好相等, 如果它们形态不同, 就会算两次, 而形态相同就只会算一次.
因此再减去 $[2|n]\binom{a_{\frac{n}{2}}}{2}$.

最终$n$个点的烷烃个数就是

\begin{align*}
    [x^n]F(x)-\sum_{k=\lfloor \frac{n}{2} \rfloor+1}^{n-1}a_k a_{n-k} - [2|n]\binom{a_{\frac{n}{2}}}{2}
\end{align*}

这一部分也可以写出生成函数

\begin{align*}
     &\sum_{k=\lfloor \frac{n}{2} \rfloor+1}^{n-1}a_k a_{n-k} + [2|n]\binom{a_{\frac{n}{2}}}{2}\\
    =&\frac{1}{2}(\sum_{k=1}^{n-1}a_k a_{n-k}-[2|n]a_{\frac{n}{2}}^2)+ [2|n]\binom{a_{\frac{n}{2}}}{2}\\
    =&\frac{1}{2}(\sum_{k=1}^{n-1}a_k a_{n-k})-[2|n] \frac{1}{2}a_{\frac{n}{2}}
\end{align*}

所以去重后烷烃个数的生成函数为
$$
    F(x)-\frac{1}{2}((A(x)-1)^2-(A(x^2)-1))=F(x)+\frac{1}{2}(A(x^2)-(A(x)-1)^2-1)
$$

\begin{lstlisting}
// get number of alkane from 0 to n-1
inline void alkane(int *F,int *A,int n){
    static int A1[N],A2[N],A3[N],T[N];
    for(int i=0;1*i<n;++i)A1[1*i]=A[i];
    for(int i=0;2*i<n;++i)A2[2*i]=A[i];
    for(int i=0;3*i<n;++i)A3[3*i]=A[i];
    ntt(A1,n<<1,1);
    ntt(A2,n<<1,1);
    ntt(A3,n<<1,1);
    for(int i=0;i<n<<1;++i)A3[i]=add(8ll*A1[i]*A3[i]%p,3ll*A2[i]*A2[i]%p);
    for(int i=0;i<n<<1;++i)A1[i]=1ll*A1[i]*A1[i]%p;
    ntt(A1,n<<1,-1);
    memset(A1+n,0,n<<2);
    memcpy(T,A1,n<<2);
    ntt(T,n<<1,1);
    for(int i=0;i<n<<1;++i)inc(A3[i],(1ll*T[i]*T[i]+6ll*T[i]*A2[i])%p);
    ntt(A3,n<<1,-1);
    memset(A3+n,0,n*3<<2);
    for(int i=0;4*i<n;++i)inc(A3[4*i],6ll*A[i]%p);
    ll inv24=qpow(24,p-2);
    for(int i=n-1;~i;--i)A3[i+1]=inv24*A3[i]%p;
    A3[0]=0;
    ll inv2=(p+1)/2;
    memset(A1+n,0,n<<2);
    for(int i=0;i<n;++i)inc(A3[i],sub((i&1)?0:A[i/2],A1[i])*inv2%p);
    for(int i=1;i<n;++i)inc(A3[i],A[i]);
    memcpy(F,A3,n<<2);
}
\end{lstlisting}
\subsubsection{Pólya定理}

Burnside 引理使用时需要对于每种置换计算不动点个数, 通常没法枚举所有情况判断是否是一个置换下的不动点. 
Pólya定理其实就是 Burnside 引理在染色计数的简单推论, 对一个置换快速计算不动点个数.

现在假设我们给 $n$ 个位置染色, 每个位置可以都可以染 $k$ 种颜色, 考虑计算 $|c(p)|$ (就是经过 $p$ 映射后不变的染色方案数).

我们将每个置换分解成循环置换的乘积, 相当于得到一堆环, 当且仅当每个环内的元素全部相同, 染色方案在置换下不变.

所以若分解得到的循环的个数为 $d(p)$, 则$|c(p)|=k^{d(p)}$, 所以本质不同的染色方案数就是

\begin{align*}
    \frac{1}{|G|}\sum_{p \in G}k^{d(p)}
\end{align*}

说人话就是不动点个数有时可以直接根据置换循环节数算出来, 不用一个一个枚举出来判断, 仅此而已.

带权的Pólya定理先咕咕.
% 当然, 既然 Burnside 引理可以带权, Pólya定理当然也可以.
% 置换带权就不用说了, 本来这个式子就要枚举每个置换, 考虑元素带权.

% 假设每种颜色有一个权值 $\omega(k)$, 定义一种染色方案(元素)的权值是每个位置染的颜色的权值的积.
% 在这个定义下, 如果两个染色方案在同一个等价类, 其权值必然相同(因为每种颜色的个数相同才可能等价).

% 这样由带权的 Burnside 引理
% $$
%     \frac{1}{|G|}\sum_{i=1}^{m}\omega(c(p_i)) = \sum_{k=1}^{n}\frac{\omega(k)}{|E_k|} = \sum_{t=1}^{l}\omega(s_t)
% $$

\subsubsection{Pólya定理的常见模型}
实际上只是考虑 $d(p)$ 的具体内容.
\paragraph{旋转同构}\ 

显然 $G = \{p_0, p_1,...p_{n-1}\}$, 其中 $p_i$ 是旋转 $i$ 的置换.

所以答案就是

\begin{align*}
    l &= \frac{1}{|G|}\sum_{p_i \in G} |c(p_i)| \\
      &= \frac{1}{n} \sum_{i=0}^{n-1} k^{d(p_i)}\\
      &= \frac{1}{n} \sum_{i=0}^{n-1} k^{gcd(i,n)}\\
      &= \frac{1}{n} \sum_{d|n}k^d \varphi(\lfloor \frac{n}{d}\rfloor)
\end{align*}

\begin{proof}
    有$n$个位置, 旋转距离为 $i$ 时, 循环个数为 $gcd(i,n)$.

    \begin{itemize}
        \item 若 $k|n$, 显然每个环的大小都是 $\frac{n}{k}$, 所以有 $k = gcd(k,n)$ 个环.
        \item 若 $k\not |n$, 相当于 $lcm(k,n)$ 里每 $k$ 个选一个, 所以环大小为 $\frac{lcm(k,n)}{k}$, 所以有 $ \frac{nk}{lcm(k,n)} = gcd(k,n)$ 个环.
    \end{itemize}

    然后莫反套路枚举约数, 可以化简表达式.
\end{proof}
\subsection{线性代数}
\subsubsection{高斯消元}
\begin{lstlisting}
const db eps=1e-10;

db a[N][N];

inline void gauss(int n){
	for(int i=0;i<n;++i){
		int mx=0;
		for(int j=i;j<n;++j){
			if(fabs(a[mx][i])+eps<fabs(a[j][i])){
				mx=j;
			}
		}
		if(!mx)continue;
		for(int j=0;j<=n;++j){
			std::swap(a[mx][j],a[i][j]);
		}
		for(int j=0;j<n;++j){
			if(fabs(a[j][i])>eps&&j!=i){
				db t=a[j][i]/a[i][i];
				for(int k=i;k<=n;++k){
					a[j][k]-=a[i][k]*t;
				}
			}
		}
	}
	for(int i=0;i<n;++i){
		a[i][n]/=a[i][i];
	}
}
\end{lstlisting}
\subsubsection{LGV 引理}
Lindström–Gessel–Viennot lemma，即 LGV 引理，可以用来处理\textbf{有向无环图}上不相交路径计数等问题。

\paragraph{定义}
\begin{itemize}
    \item $\omega(P)$：路径 $P$ 上所有边权积之和。
    \item $e(u, v)$：$u$ 到 $v$ 的每条路径 $P$ 的 $\omega$ 之和，即 $\sum_{P: u\to v} \omega(P)$。
    \item 起点集合 $A$ 和终点集合 $B$ （$n = |A| = |B|$）。
    \item $S = \{P_1, P_2, ..., P_n\}$：一种 $A$ 到 $B$ 的不相交路径方案，其中 $P_i: A_i \to B_{\sigma(S)}$（显然 $\sigma(S)$ 是排列）。
\end{itemize}

\paragraph{内容}

$$
M = \begin{bmatrix}e(A_1,B_1)&e(A_1,B_2)&\cdots&e(A_1,B_n)\\
    e(A_2,B_1)&e(A_2,B_2)&\cdots&e(A_2,B_n)\\
    \vdots&\vdots&\ddots&\vdots\\
    e(A_n,B_1)&e(A_n,B_2)&\cdots&e(A_n,B_n)\end{bmatrix}
$$

有 
$$
\det(M)=\sum_{S}(-1)^{\tau(\sigma(S))}\prod_{P \in S} \omega(P)
$$

其中 $\tau(\sigma)$ 表示排列 $\sigma$ 的逆序对数。

在常见的题目中，
起点与终点存在一一对应关系，
也就是说只有一种排列 $\sigma$ 可以使得路径不交，
此时 $(-1)^{\tau(\sigma(S))}$ 可以直接去掉，变成
$$
\det(M)=\sum_{S}\prod_{P \in S} \omega(P)
$$

\paragraph{例题} P6657 【模板】LGV 引理

有一个 $n \times n$ 的棋盘，左下角为 $(1, 1)$，右上角为 $(n, n)$，
若一个棋子在点 $(x,y)$，那么走一步只能走到 $(x+1,y)$ 或 $(x,y+1)$。

现在有 $m$ 个棋子，第 $i$ 个棋子一开始放在 $(a_i, 1)$，最终要走到 $(b_i, n)$。
问有多少种方案，使得每个棋子都能从起点走到终点，且对于所有棋子，走过路径上的点互不相交。

显然，对于任意不相交方案，都是从 $A_i$ 走到 $B_i$（$1 \le i \le n$），
所以 $\sigma(S) = {1, 2, ..., n}$，
若令边权全为 $1$，则
$$
\det(M)= \sum_{S} 1 = |S|
$$
此时我们考虑 $e(u, v)$ 显然是组合数，于是得到 $M$ 计算行列式即可得到答案 $|S|$。

\subsubsection{LLL 算法}
LLL(Lenstra–Lenstra–Lovász) 算法用于格基规约，
可以将使输入基 $B=\{b_0, ..., b_{n - 1}\}$ 变换到相对正交且相对短的基，
可用与寻找格中最短向量的近似解。

算法流程是维护 Gram-Schmidt 正交化矩阵和系数

\begin{align*}
    B^* &= \{b^*_0, ..., b^*_{n - 1}\}\\
    \mu_{i, j} &= \frac{\langle b_i, b^*_j \rangle}{\langle b^*_j, b^*_j \rangle}
\end{align*}

考虑满足两个条件
\begin{itemize}
    \item (size-reduced) 对 $0 \le j < i < n$，$|\mu_{i, j}| \le 0.5$
    \item (Lovász condition) 对 $0 < i < n$，${\Vert b_i \Vert} ^ 2 \ge (\delta - \mu_{i, i - 1}^2) {\Vert b_{i-1} \Vert}$
\end{itemize}

其中参数 $\delta \in (0.25, 1)$，常见取值是 $0.75$。

假设当前处理第 $k$ 个向量，
倒序枚举 $i\in{0, ..., k - 1}$，
依次令 $b_k \leftarrow b_k - \lceil \mu_{k, i} \rfloor b_i$；
再检查是否满足 Lovász condition 条件，若不满足，则交换当前向量与前一个向量，重新处理前一个向量，否则处理下一个向量。

LLL 算法复杂度与输入向量个数 $n$，向量维数 $m$，以及 $Y = \max\{{\Vert b_i \Vert} ^ 2\}$ 有关，
为 $O(n^5 m \log^3(Y))$。

\begin{lstlisting}[language = Python]
from decimal import Decimal, getcontext
getcontext().prec = 55

def round_div(a, b):
    if b < 0: return round_div(-a, -b)
    if a >= 0: return a // b + (a % b * 2 >= b)
    else: return -round_div(-a, b)
    
def ceil_div(a, b):
    if b < 0: return ceil_div(-a, -b)
    if a > 0: return a // b + (a % b != 0)
    else: return -ceil_div(-a, b)

def ceil_sqrt(n):
    x = pow(10, len(str(n)) // 2)
    while True:
        nx = round_div(x + round_div(n, x), 2)
        if abs(nx - x) <= 1: break
        x = nx
    while (x - 1) ** 2 >= n: x -= 1
    while x ** 2 < n: x += 1
    return x

def calc_poly(A, x, M = None):
    prod, ans = 1, 0
    for a in A:
        prod, ans = prod * x, ans + a * prod
        if M != None: prod, ans = prod % M, ans % M
    return ans

def newton(A, x):
    dA = [A[i] * i for i in range(1, len(A))]
    for i in range(8):
        fx = calc_poly(A, x)
        if fx == 0: return x
        dfx = calc_poly(dA, x)
        if dfx == 0: return None
        x -= ceil_div(fx, dfx)
    return None

def dot(A, B):
    return sum([a * b for a, b in zip(A, B)])

def mul(b, A):
    return [a * b for a in A]

def sub(A, B):
    return [a - b for a, b in zip(A, B)]

def len2(A):
    return dot(A, A)
    
def LLL(A):
    n = len(A)
    gs = [[] for _ in range(n)]

    def calc_mu(i, j):
        return dot(A[i], gs[j]) / len2(gs[j])
    
    def calc_gs(i):
        gs[i] = [Decimal(val) for val in A[i]]
        for j in range(i):
            gs[i] = sub(gs[i], mul(calc_mu(i, j), gs[j]))

    k = 0
    while(k < n):
        for i in range(k - 1, -1, -1):
            A[k] = sub(A[k], mul(round(calc_mu(k, i)), A[i]))
        calc_gs(k)
        if k == 0 or len2(gs[k]) >= (Decimal(0.75) - calc_mu(k, k - 1) ** 2) * len2(gs[k - 1]):
            k += 1
        else:
            A[k], A[k - 1] = A[k - 1], A[k]
            k -= 1
\end{lstlisting}

\subsubsection{Coppersmith Method}
若 $d$ 次同余方程 $F(x) \equiv 0 \mod N$ 存在小值根（$0 \le x_0 < X$），
其中 $X = O(N^{\frac{1}{d} - \varepsilon})$，
则 Coppersmith 算法可以求解 $x_0$，其
运行时间由在 $w = O(\min\{\frac{1}{\varepsilon}, \log(N)\})$ 个向量的格基上运行 LLL 算法的时间决定。

Coppersmith 算法的基本思想在于构造方程 $H(x)$ 满足 $H(x_0) \equiv 0 \mod N$ 且 $H(xX)$ 的范数较小。
这是因为 $H(xX)$ 范数较小时，$H(x_0)$ 的值的绝对值较小。
若其上界 $\sum{|h_iX^i|} < N$，显然有 $H(x_0) = 0$，
此时即可通过数值方法（如牛顿迭代）求解 $x_0$

在实际算法中，Coppersmith 构造了一系列 $G_{u, v}(x) = N^{m-v} x^u F^v(x)$，显然 $G_{u, v}(x_0) \equiv 0 \mod N^m$。
通过 LLL 算法，获得 $G_{u, v}(xX)$ 的较小范数的线性组合 $H(xX)$，并求解检验即可。

可以知道，对于足够大的 $m$，总是能找到满足所要求的界的 $H(xX)$。

一般而言，取 $w = O(\min\{\frac{1}{\varepsilon}, \log(N)\})$，$ m = O(w / d)$ 时可以得到解。

\begin{lstlisting}[language = Python]
def ceil_div(a, b):
    if b < 0: return ceil_div(-a, -b)
    if a > 0: return a // b + (a % b != 0)
    else: return -ceil_div(-a, b)

def calc_poly(A, x, M = None):
    prod, ans = 1, 0
    for a in A:
        prod, ans = prod * x, ans + a * prod
        if M != None: prod, ans = prod % M, ans % M
    return ans

# find integer root of polynomial by Newton's method
def newton(A, x):
    dA = [A[i] * i for i in range(1, len(A))]
    for i in range(10): # 注意牛顿迭代次数是否足够
        fx = calc_poly(A, x)
        if fx == 0: return x
        dfx = calc_poly(dA, x)
        if dfx == 0: return None
        x -= ceil_div(fx, dfx)
    return None

def coppersmith(A, N, X):
    for i in range(len(A)): A[i] %= N
    d = len(A) - 1
    m = 1
    while True:
        w = d * (m + 1)
        
        PowX = [1]
        for i in range(w): PowX.append(PowX[i] * X);
        
        PowA = [[1]]
        for v in range(m):
            tmp = [0 for _ in range(len(PowA[v]) + len(A) - 1)]
            for i in range(len(PowA[v])):
                for j in range(len(A)):
                    tmp[i + j] += PowA[v][i] * A[j]
            PowA.append(tmp)
        
        mat = []
        for v in range(m + 1):
            for u in range(d):
                # g_{u, v}(x) = N^(m-v) x^u f^v(x)
                tmp = [0 for _ in range(w)]
                for i in range(len(PowA[v])):
                    tmp[u + i] = PowA[v][i] * PowX[u + i]
                mat.append(mul(pow(N, m - v), tmp))
        
        LLL(mat)
                
        for f in mat:
            eq = [a // x for a, x in zip(f, PowX)]
            x = newton(eq, X // 2)
            if x != None and 0 <= x < X and calc_poly(A, x, N) == 0:
                return x
        m += 1
\end{lstlisting}

\subsection{快速沃尔什变换}
\subsubsection{二进制FWT \& FMT}
P4717 【模板】快速沃尔什变换
\begin{lstlisting}
#include<bits/stdc++.h>

using namespace std;

#define gc c=getchar()
#define r(x) read(x)
#define ll long long

template<typename T>
inline void read(T&x){
    x=0;T k=1;char gc;
    while(!isdigit(c)){if(c=='-')k=-1;gc;}
    while(isdigit(c)){x=x*10+c-'0';gc;}x*=k;
}

const int N=1<<17|7;
const int p=998244353;
const ll inv2=499122177;

inline int add(int a,int b){
    a+=b;
    if(a>=p)a-=p;
    return a;
}

inline int sub(int a,int b){
    a-=b;
    if(a<0)a+=p;
    return a;
}

// inline void FMT_or(int *A,int op(int,int)){
// 	for(int i=1;i<len;i<<=1){
// 		for(int j=0;j<=len;++j){
// 			if(i&j)A[j]=op(A[j],A[j^i]);
// 		}
// 	}
// }

// inline void FMT_and(int *A,int op(int,int)){
// 	for(int i=1;i<len;i<<=1){
// 		for(int j=0;j<=len;++j){
// 			if(i&j)A[j^i]=op(A[j^i],A[j]);
// 		}
// 	}
// }

inline void FWT_or(int *A,int len,bool opt=1){
    for(int i=1;i<len;i<<=1){
        for(int j=0;j<len;j+=i<<1){
            for(int k=0;k<i;++k){
                A[j+k+i]=opt?add(A[j+k],A[j+k+i]):sub(A[j+k+i],A[j+k]);
            }
        }
    }
}

inline void FWT_and(int *A,int len,bool opt=1){
    for(int i=1;i<len;i<<=1){
        for(int j=0;j<len;j+=i<<1){
            for(int k=0;k<i;++k){
                A[j+k]=opt?add(A[j+k],A[j+k+i]):sub(A[j+k],A[j+k+i]);
            }
        }
    }
}

inline void FWT_xor(int *A,int len,bool opt=1){
    for(int i=1;i<len;i<<=1){
        for(int j=0;j<len;j+=i<<1){
            for(int k=0;k<i;++k){
                int u=A[j+k],v=A[j+k+i];
                A[j+k]=add(u,v);
                A[j+k+i]=sub(u,v);
                if(!opt){
                    A[j+k]=A[j+k]*inv2%p;
                    A[j+k+i]=A[j+k+i]*inv2%p;
                }
            }
        }
    }
}
int T1[N],T2[N];

inline void OR(int* A,int* B,int* C,int len){
    memcpy(T1,A,len<<2);
    memcpy(T2,B,len<<2);
    FWT_or(T1,len);
    FWT_or(T2,len);
    for(int i=0;i<len;++i)C[i]=(ll)T1[i]*T2[i]%p;
    FWT_or(C,len,0);
}

inline void AND(int* A,int* B,int* C,int len){
    memcpy(T1,A,len<<2);
    memcpy(T2,B,len<<2);
    FWT_and(T1,len);
    FWT_and(T2,len);
    for(int i=0;i<len;++i)C[i]=(ll)T1[i]*T2[i]%p;
    FWT_and(C,len,0);
}

inline void XOR(int* A,int* B,int* C,int len){
    memcpy(T1,A,len<<2);
    memcpy(T2,B,len<<2);
    FWT_xor(T1,len);
    FWT_xor(T2,len);
    for(int i=0;i<len;++i)C[i]=(ll)T1[i]*T2[i]%p;
    FWT_xor(C,len,0);
}

int a[N],b[N],c[N];

int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
    int n;
    r(n);n=1<<n;
    for(int i=0;i<n;++i)r(a[i]);
    for(int i=0;i<n;++i)r(b[i]);
    OR(a,b,c,n);
    for(int i=0;i<n;++i)printf("%d ",c[i]);puts("");
    AND(a,b,c,n);
    for(int i=0;i<n;++i)printf("%d ",c[i]);puts("");
    XOR(a,b,c,n);
    for(int i=0;i<n;++i)printf("%d ",c[i]);puts("");
}
\end{lstlisting}

\subsubsection{子集卷积 FST}
如果要求子集不交，可以按位拆分进行卷积
\begin{lstlisting}
for(int i=0;i<len;++i){
    t[bit[i]=(bit[i>>1]+(i&1))][i]=cnt[i];
}
for(int i=0;i<=17;++i){
    FWT_or(t[i]);
    // FMT_or(t[i],add);
}
for(int i=0;i<=17;++i){
    for(int j=0;i+j<=17;++j){
        for(int k=0;k<len;++k){
            f[i+j][k]=add(f[i+j][k],(ll)t[i][k]*t[j][k]%p);
        }
    }
}
for(int i=0;i<=17;++i)FWT_or(f[i],0);
// for(int i=0;i<=17;++i)FMT_or(f[i],sub);
for(int i=0;i<len;++i){
    A[i]=f[bit[i]][i];
}
\end{lstlisting}

\subsubsection{k进制FWT}
\begin{lstlisting}
inline void FWT_or(int *A,int D,int K){
    int len=1;
    for(int i=1;i<=D;++i)len*=K;
    for(int cur=1;cur<len;cur*=K){
        for(int i=0;i<len;i+=cur*K){
            for(int j=0;j<cur;++j){ //交换j,k枚举顺序可以卡常
                for(int k=1;k<K;++k){
                    A[i+j+k*cur]=add(A[i+j+k*cur],A[i+j+(k-1)*cur]);
                }
            }
        }
    }
}

inline void IFWT_or(int *A,int D,int K){
    int len=1;
    for(int i=1;i<=D;++i)len*=K;
    for(int cur=1;cur<len;cur*=K){
        for(int i=0;i<len;i+=cur*K){
            for(int j=0;j<cur;++j){
                for(int k=K-1;k;--k){
                    A[i+j+k*cur]=sub(A[i+j+k*cur],A[i+j+(k-1)*cur]);
                }
            }
        }
    }
}

inline void FWT_and(int *A,int D,int K){
    int len=1;
    for(int i=1;i<=D;++i)len*=K;
    for(int cur=1;cur<len;cur*=K){
        for(int i=0;i<len;i+=cur*K){
            for(int j=0;j<cur;++j){
                for(int k=K-1;k;--k){
                    A[i+j+(k-1)*cur]=add(A[i+j+(k-1)*cur],A[i+j+k*cur]);
                }
            }
        }
    }
}

inline void IFWT_and(int *A,int D,int K){
    int len=1;
    for(int i=1;i<=D;++i)len*=K;
    for(int cur=1;cur<len;cur*=K){
        for(int i=0;i<len;i+=cur*K){
            for(int j=0;j<cur;++j){
                for(int k=1;k<K;++k){
                    A[i+j+(k-1)*cur]=sub(A[i+j+(k-1)*cur],A[i+j+k*cur]);
                }
            }
        }
    }
}

inline void FWT_xor(int *A,int D,int K){
    int tmp[K];
    int len=1;
    for(int i=1;i<=D;++i)len*=K;
    for(int cur=1;cur<len;cur*=K){
        for(int i=0;i<len;i+=cur*K){
            for(int j=0;j<cur;++j){
                memset(tmp,0,sizeof(tmp));
                for(int a=0;a<K;++a){
                    ll step=qpow(wn,a); // wn为k次单位根
                    ll w=1;
                    for(int b=0;b<K;++b,w=w*step%p){
                        tmp[a]=add(tmp[a],(ll)A[i+j+b*cur]*w%p);
                    }
                }
                for(int a=0;a<K;++a){
                    A[i+j+a*cur]=tmp[a];
                }
            }
        }
    }
}

inline void IFWT_xor(int *A,int D,int K){
    int tmp[K];
    int len=1;
    for(int i=1;i<=D;++i)len*=K;
    for(int cur=1;cur<len;cur*=K){
        for(int i=0;i<len;i+=cur*K){
            for(int j=0;j<cur;++j){
                memset(tmp,0,sizeof(tmp));
                for(int a=0;a<K;++a){
                    ll step=qpow(wn,(ll)(p-2)*a%(p-1));
                    ll w=1;
                    for(int b=0;b<K;++b,w=w*step%p){
                        tmp[a]=add(tmp[a],(ll)A[i+j+b*cur]*w%p);
                    }
                }
                for(int a=0;a<K;++a){
                    A[i+j+a*cur]=tmp[a];
                }
            }
        }
    }
    ll x=qpow(len,p-2);
    for(int i=0;i<len;++i){
        A[i]=A[i]*x%p;
    }
}
    
\end{lstlisting}
\subsection{计算几何}
\subsubsection{凸包}
把点按坐标排序(双关键字)

以最小的一个为原点

因为所有点的坐标都比它大

所以一定在凸包上

用一个栈维护当前最优解

叉积判断是否更优

二维凸包(double)
\begin{lstlisting}
inline bool cmp(const Vec &a,const Vec &b){
	return Cross(a,b)>0||(Cross(a,b)==0&&Lenth(a)<Lenth(b));
}

int sta[N],top;

inline int Convex(Point *A,Point *C,int n){
	Point tmp=A[1];
	for(int i=2;i<=n;++i){
		if(A[i].x<tmp.x||(A[i].x==tmp.x&&A[i].y<tmp.y))tmp=A[i];
	}
	for(int i=1;i<=n;++i)A[i]-=tmp;
	sort(A+1,A+n+1,cmp);
	sta[++top]=1;
	for(int i=2;i<=n;++i){
		while(top>1&&Cross(A[i]-A[sta[top-1]],A[sta[top]]-A[sta[top-1]])>=0)top--;
		sta[++top]=i;
	}
	for(int i=1;i<=n;++i)A[i]+=tmp;
	for(int i=1;i<=top;++i){
		C[i]=A[sta[i]];
	}
	return top;
}

\end{lstlisting}
P2521 [HAOI2011]防线修建(动态凸包)
\begin{lstlisting}
#include<bits/stdc++.h>

using namespace std;

#define gc c=getchar()
#define r(x) read(x)
#define db double

template<typename T>
inline void read(T&x){
    x=0;T k=1;char gc;
    while(!isdigit(c)){if(c=='-')k=-1;gc;}
    while(isdigit(c)){x=x*10+c-'0';gc;}x*=k;
}

const int N=200005;

struct Point{
	int x,y;
	
	inline bool operator <(const Point &A)const{
		return x==A.x?y<A.y:x<A.x;
	}
}P[N];

inline Point operator - (const Point &A,const Point &B){
	return Point{A.x-B.x,A.y-B.y};
}

inline int operator * (const Point &A,const Point &B){
	return A.x*B.y-A.y*B.x;
}

inline db sqr(db x){
	return x*x;
}

inline db dist(const Point &A,const Point &B){
	return sqrt(sqr(A.x-B.x)+sqr(A.y-B.y));
}

struct Query{
	int t,x;
}Q[N];

set<Point>S;
db ans;

inline void insert(const Point &A){
	set<Point>::iterator l=S.lower_bound(A),r=l,t;
	--l;
	if((*l-A)*(*r-A)<0)return ;
	ans-=dist(*l,*r);
	while(1){
		t=r,++r;
		if(r==S.end()||(*t-A)*(*r-A)<0)break;
		ans-=dist(*t,*r);
		S.erase(t);
	}
	while(1){
		t=l,--l;
		if(t==S.begin()||(*l-A)*(*t-A)<0)break;
		ans-=dist(*l,*t);
		S.erase(t);
	}
	S.insert(A);
	l=r=S.find(A);
	l--;r++;
	ans+=dist(*l,A);
	ans+=dist(A,*r);
}

bool vis[N];
db Ans[N];

int main(){
	int n,x,y;r(n),r(x),r(y);
	int m;r(m);
	for(int i=1;i<=m;++i){
		r(P[i].x),r(P[i].y);
	}
	int q;r(q);
	for(int i=1;i<=q;++i){
		int type,x;r(type);
		if(type==1){
			r(x);
			vis[x]=1;
		}
		Q[i]=Query{type,x};
	}
	Point A{0,0};
	Point B{n,0};
	Point C{x,y};
	ans+=dist(A,C);
	ans+=dist(B,C);
	S.insert(A);
	S.insert(B);
	S.insert(C);
	for(int i=1;i<=m;++i){
		if(!vis[i])insert(P[i]);
	}
	for(int i=q;i;--i){
		if(Q[i].t==2)Ans[i]=ans;
		else insert(P[Q[i].x]);
	}
	for(int i=1;i<=q;++i){
		if(Q[i].t==2)printf("%.2lf\n",Ans[i]);
	}
	return 0;
}
\end{lstlisting}
\subsubsection{旋转卡壳}
P1452 平面最远点对

求出凸包

枚举离一条边最远的点

发现具有单调性
\begin{lstlisting}
inline ll MaxDist(Point *A,int n){
	A[++n]=A[1];
	ll ans=0;
	for(int i=1,j=3;i<n;++i){
		 while(Cross(A[i+1]-A[i],A[j]-A[i])<Cross(A[i+1]-A[i],A[j+1]-A[i])){
		 	if(++j>n)j=1;
		 }
		 ans=max(ans,dist(A[i],A[j]));
	}
	return ans;
}
\end{lstlisting}
\subsubsection{平面最近点对}
\begin{lstlisting}
#include<bits/stdc++.h>

using namespace std;

#define db double

const db INF=1e18;
const int N=1e5+7;

struct Point{
	db x,y;
}A[N];

inline db sqr(const db &x){
	return x*x;
}

inline db dist(const Point &a,const Point &b){
	return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));
}

inline bool cmp1(const Point &a,const Point &b){
	return a.x<b.x;
}

inline bool cmp2(const Point &a,const Point &b){
	return a.y<b.y;
}

vector<Point>Tmp;

db dfs(int l,int r){
	if(l==r)return INF;
	if(l+1==r)return dist(A[l],A[r]);
	int mid=(l+r)>>1;
	db d=min(dfs(l,mid),dfs(mid+1,r));
	Tmp.clear();
	for(int i=l;i<=r;++i){
		if(dist(A[i],A[mid])<d){
			Tmp.push_back(A[i]);
		}
	}
	sort(Tmp.begin(),Tmp.end(),cmp2);
	for(int i=0;i<Tmp.size();++i){
		for(int j=i+1;j<Tmp.size();++j){
			db dis=dist(Tmp[i],Tmp[j]);
			if(dis>=d)break;
			else d=dis;
		}
	}
	return d;
}

int main(){
	for(int n;scanf("%d",&n),n;){
		for(int i=1;i<=n;++i){
			scanf("%lf%lf",&A[i].x,&A[i].y);
		}
		sort(A+1,A+n+1,cmp1);
		printf("%.2lf\n",dfs(1,n)/2);
	}
}
\end{lstlisting}
\subsubsection{半平面交}
把线段极角排序

依次加入

同时维护线段和点

具体来说

维护两个双端队列(也可以用 pair 或者只维护直线每次计算交点然后只开一个)

分别维护一条直线和这条直线与下一条的交点(最后一条的下一条是第一条)

发现具有只能从队首队尾弹出
\begin{lstlisting}
inline db Angle(const Vec &a){
	return atan2(a.y,a.x);
}

struct Line{
	Point S,T;
	db theta;
	
	inline Line(){}
	inline Line(const Point &A,const Point &B):S(A),T(B),theta(Angle(B-A)){}
	
};

#define Seg Line

inline bool operator < (const Line &A,const Line &B){
	double alpha=A.theta-B.theta;
	if(dcmp(alpha))return dcmp(alpha)==-1;
	return dcmp(Cross(A.T-A.S,B.S-A.S))==-1;
}

inline Point LineCross(const Line &a,const Line &b){
	Vec u=a.T-a.S;
	Vec v=b.T-b.S;
	Vec w=a.S-b.S;
	db t=Cross(v,w)/Cross(u,v);
	return a.S+u*t;
}
//on the right or not
inline bool Direction(const Line &a,const Point &A){
	return dcmp(Cross(a.T-a.S,A-a.S))==-1;
}

Line Q1[N];
Point Q2[N];

inline int Half(Line *A,int n,Point *B){
	int head=0,tail=0;
	sort(A+1,A+n+1);
	Q1[0]=A[1];
	for(int i=2;i<=n;++i){
		if(!dcmp(A[i].theta-A[i-1].theta))continue;
		while(head<tail&&Direction(A[i],Q2[tail-1]))--tail;
		while(head<tail&&Direction(A[i],Q2[head]))++head;
		Q1[++tail]=A[i];
		Q2[tail-1]=LineCross(A[i],Q1[tail-1]);
	}
	while(head<tail&&Direction(Q1[head],Q2[tail-1]))--tail;
	while(head<tail&&Direction(Q1[tail],Q2[head]))++head;
	Q2[tail]=LineCross(Q1[head],Q1[tail]);
	int m=0;
	for(int i=head;i<=tail;++i)B[++m]=Q2[i];
	return m;
}
\end{lstlisting}
\subsubsection{圆交多边形}
\begin{lstlisting}
const db eps=1e-10;
const int N=100005;

struct Point{
    db x,y;

    inline Point(){}
    inline Point(db _x,db _y): x(_x),y(_y){}
};

inline int dcmp(const db &x){
    if(fabs(x)<eps)return 0;
    return x>0?1:-1;
}

#define Vec Point

inline Vec operator +(const Vec &a,const Vec &b){
    return Point(a.x+b.x,a.y+b.y);
}

inline Vec operator -(const Vec &a,const Vec &b){
    return Point(a.x-b.x,a.y-b.y);
}

inline Vec operator +=(Vec &a,const Vec &b){
    a.x+=b.x;a.y+=b.y;
}

inline Vec operator -=(Vec &a,const Vec &b){
    a.x-=b.x;a.y-=b.y;
}

inline Vec operator *(const Vec &a,const db &b){
    return Point(a.x*b,a.y*b);
}

inline Vec operator *(const db &a,const Vec &b){
    return Point(a*b.x,a*b.y);
}

inline db dot(const Vec &a,const Vec &b){
    return a.x*b.x+a.y*b.y;
}

inline db cross(const Vec &a,const Vec &b){
    return a.x*b.y-a.y*b.x;
}

inline db sqr(const db &x){
    return x*x;
}

inline db norm(const Vec &a){
    return sqr(a.x)+sqr(a.y);
}

inline db lenth(const Vec &a){
    return sqrt(norm(a));
}

inline db shan(const Vec &a,const Vec &b,const db &r){
    return dcmp(cross(a,b))*acos(dot(a,b)/lenth(a)/lenth(b))*r*r;
}

inline bool Circle_Line_Intersect(Point A,Point B,Point &T1,Point &T2,const db &r){
    Vec AB=B-A;
    db dx=AB.x;
    db dy=AB.y;
    db a=norm(AB);
    db b=2*dot(A,AB);
    db c=norm(A)-r*r;
    db delta=sqr(b)-4*a*c;
    if(delta<0){
        if(delta>-eps)delta=0;
        else return 0;
    }
    db t1=(-b+sqrt(delta))/(2*a);
    db t2=(-b-sqrt(delta))/(2*a);
    T1=A+t1*AB;
    T2=A+t2*AB;
    return 1;
}

inline db Triangle_Circle_Area(Point A,Point B,db r){
    if(dcmp(cross(A,B))==0)return 0;
    db a2=norm(A);
    db b2=norm(B);
    db sg=1;
    if(a2>b2){
        swap(A,B);
        swap(a2,b2);
        sg=-1;
    }
    db r2=sqr(r);
    if(dcmp(r2-b2)>=0){
        return sg*cross(A,B)/2;
    }
    else if(dcmp(r2-a2)>0){
        Point T,T1,T2;
        assert(Circle_Line_Intersect(A,B,T1,T2,r));
        if(dcmp(dot(T1-A,B-A))>=0){
            T=T1;
        }
        else {
            assert(dcmp(dot(T2-A,B-A))>=0);
            T=T2;
        }
        return sg*(cross(A,T)+shan(T,B,r))/2;
    }
    else {
        Point T,T1,T2;
        if(Circle_Line_Intersect(A,B,T1,T2,r)){
            if(dot(B-A,T1-A)>dot(B-A,T2-A)){
                swap(T1,T2);
            }
            if(dcmp(dot(B-A,T1-A))>=0){
                return sg*(shan(A,T1,r)+cross(T1,T2)+shan(T2,B,r))/2;
            }
        }
        return sg*(shan(A,B,r))/2;
    }
}

inline db Polygon_Circle_Area(Point *A,int n,const Point &O,const db &r){
    db ans=0;
	A[0]=A[n];
    for(int i=1;i<=n;++i){
        ans+=Triangle_Circle_Area(A[i-1]-O,A[i]-O,r);
    }
    return ans;
}    
\end{lstlisting}
\subsubsection{自适应辛普森}
P4525 【模板】自适应辛普森法1
\begin{lstlisting}
#include<bits/stdc++.h>

using namespace std;

typedef double db;

const db Eps=1e-6;

db a,b,c,d;
inline db f(db x){return (c*x+d)/(a*x+b);}

inline db simpson(db l,db r){return (r-l)*(f(l)+f(r)+4*f((l+r)*0.5))/6;}

inline db asr(db l,db r,db ans,db eps){
    db mid=(l+r)*0.5;
    db v1=simpson(l,mid);
    db v2=simpson(mid,r);
    db t=v1+v2-ans;
    return (fabs(t)<15*eps)?(v1+v2+t/15):(asr(l,mid,v1,eps*0.5)+asr(mid,r,v2,eps*0.5));
}

int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
    db l,r;
    scanf("%lf%lf%lf%lf%lf%lf",&a,&b,&c,&d,&l,&r);
    printf("%.6lf",asr(l,r,simpson(l,r),Eps));
}
\end{lstlisting}
P4526 【模板】自适应辛普森法2
\begin{lstlisting}
#include<bits/stdc++.h>

using namespace std;

typedef double db;

const db Eps=1e-8;

db a;
inline db f(db x){return pow(x,a/x-x);}

inline db simpson(db l,db r){return (r-l)*(f(l)+f(r)+4*f((l+r)*0.5))/6;}

inline db asr(db l,db r,db ans,db eps){
    db mid=(l+r)*0.5;
    db v1=simpson(l,mid);
    db v2=simpson(mid,r);
    db t=v1+v2-ans;
    return (fabs(t)<15*eps)?(v1+v2+t/15):(asr(l,mid,v1,eps*0.5)+asr(mid,r,v2,eps*0.5));
}

int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
    scanf("%lf",&a);
    if(a<0)return puts("orz"),0;
    db l=1e-9,r=20;
    printf("%.5lf",asr(l,r,simpson(l,r),Eps));
}
\end{lstlisting}
\subsubsection{最小圆覆盖}
随机增量法
\begin{lstlisting}
#include<bits/stdc++.h>

using namespace std;

#define db double

const int N=100005;
const db eps=1e-12;

struct Point{
	db x,y;
	
	inline Point(){}
	inline Point(const db &_x,const db &_y):x(_x),y(_y){}
};

#define Vec Point

inline Vec operator + (const Vec &a,const Vec &b){
	return Vec(a.x+b.x,a.y+b.y);
}

inline Vec operator - (const Vec &a,const Vec &b){
	return Vec(a.x-b.x,a.y-b.y);
}

inline db sqr(const db &x){
	return x*x;
}

inline db dis(const Point &A,const Point &B){
	return sqrt(sqr(A.x-B.x)+sqr(A.y-B.y));
}

inline Point mid(const Point &A,const Point &B){
	return Point((A.x+B.x)/2,(A.y+B.y)/2);
}

struct Circle{
	Point O;
	db r;
	inline Circle(){}
	inline Circle(const Point &_O,const db &_r):O(_O),r(_r){}
	inline Circle (const Point &A,const Point &B,const Point &C){
		Vec a=B-A,b=C-A;
		db a1=a.x,b1=a.y,c1=(a1*a1+b1*b1)/2;
		db a2=b.x,b2=b.y,c2=(a2*a2+b2*b2)/2;
		db d=1/(a1*b2-a2*b1);
		O=A+Vec((c1*b2-c2*b1)*d,(c2*a1-c1*a2)*d);
		r=dis(A,O);
	}
	
};

inline bool in(const Circle &C,const Point &A){
	return dis(C.O,A)+eps<C.r;
}

inline Circle MinCircle(Point *A,int n){
	srand(time(0));
	random_shuffle(A,A+n);
	Circle ans=Circle(A[0],0);
	for(int i=1;i<n;++i){
		if(in(ans,A[i]))continue;
		ans=Circle(A[i],0);
		for(int j=0;j<i;++j){
			if(in(ans,A[j]))continue;
			ans=Circle(mid(A[i],A[j]),dis(A[i],A[j])/2);
			for(int k=0;k<j;++k){
				if(in(ans,A[k]))continue;
				ans=Circle(A[i],A[j],A[k]);
			}
		}
	}
	return ans;
}

Point A[N];

int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	int n;scanf("%d",&n);
	for(int i=0;i<n;++i){
		scanf("%lf%lf",&A[i].x,&A[i].y);
	}
	Circle ans=MinCircle(A,n);
	printf("%.10lf\n%.10lf %.10lf\n",ans.r,ans.O.x,ans.O.y);
	return 0;
}
\end{lstlisting}
\subsubsection{最小球覆盖}
三分套三分
\begin{lstlisting}
const db eps=1e-5;

struct Point{
    db x,y,z;
    
    inline Point(){}
    inline Point(const db &_x,const db &_y,const db &_z):x(_x),y(_y),z(_z){}
}A[N];

#define Vec Point

inline Vec operator - (const Vec &a,const Vec &b){
    return Vec(a.x-b.x,a.y-b.y,a.z-b.z);
}

inline db sqr(const db &x){
    return x*x;
}

inline db norm(const Vec &a){
    return sqrt(sqr(a.x)+sqr(a.y)+sqr(a.z));
}

inline db dis(const Point &A,const Point &B){
    return norm(A-B);
}

int n;

inline db solve4(const db a,const db b,const db c){
    Point O={a,b,c};
    db ans=0;
    for(int i=1;i<=n;++i){
        ans=max(ans,dis(O,A[i]));
    }
    return ans;
}

inline db solve3(const db a,const db b){
    db l=-100000,r=100000,ans=1e9;
    while(l+eps<r){
        db midl=l+(r-l)/3;
        db midr=r-(r-l)/3;
        db tl=solve4(a,b,midl);
        db tr=solve4(a,b,midr);
        if(tl>tr){
            l=midl;
            ans=tl;
        }
        else {
            r=midr;
            ans=tr;
        }
    }
    return ans;
}

inline db solve2(const db a){
    db l=-100000,r=100000,ans=1e9;
    while(l+eps<r){
        db midl=l+(r-l)/3;
        db midr=r-(r-l)/3;
        db tl=solve3(a,midl);
        db tr=solve3(a,midr);
        if(tl>tr){
            l=midl;
            ans=tl;
        }
        else {
            r=midr;
            ans=tr;
        }
    }
    return ans;
}

inline db solve1(){
    db l=-100000,r=100000,ans=1e9;
    while(l+eps<r){
        db midl=l+(r-l)/3;
        db midr=r-(r-l)/3;
        db tl=solve2(midl);
        db tr=solve2(midr);
        if(tl>tr){
            l=midl;
            ans=tl;
        }
        else {
            r=midr;
            ans=tr;
        }
    }
    return ans;
}

int main(){
    r(n);
    for(int i=1;i<=n;++i){
        r(A[i].x);
        r(A[i].y);
        r(A[i].z);
    }
    printf("%.5lf\n",solve1());
    return 0;
}
\end{lstlisting}
\subsubsection{Pick定理}
给定顶点座标均是整点（或正方形格子点）的简单多边形，
皮克定理说明了其面积$A$和内部格点数目$i$、
边上格点数目$b$的关系：
$$
A=i+\frac{b}{2}-1
$$
\subsubsection{曼哈顿距离与切比雪夫距离}
曼哈顿距离：
$$
|x_1-x_2|+|y_1-y_2|
$$

切比雪夫距离：
$$
\max\{|x_1-x_2|,|y_1-y_2|\}
$$

由于
$$
\begin{aligned}
    &|x_1-x_2|+|y_1-y_2| \\
     =& max\{x_1-x_2+y_1-y_2,x_1-x_2+y_2-y_1,x_2-x_1+y_1-y_2,x_2-x_1+y_2-y_1\}
\end{aligned}
$$

若将$(x, y)$转化为$(x+y,x-y)$，
新坐标系下的切比雪夫距离即为原坐标系下曼哈顿距离。 

若将$(x, y)$转化为$(\frac{x+y}{2},\frac{x-y}{2})$，
新坐标系下的曼哈顿距离即为原坐标系下切比雪夫距离。

后一个转化比较常用，曼哈顿距离一般可以通过排序前缀和的方式降低计算复杂度。

可以理解为曼哈顿坐标系是通过切比雪夫坐标系旋转$45^\circ$后，再缩小到原来的一半得到的。
\subsubsection{欧拉公式（几何）}
对于任意简单多面体，设$V$为多面体定点数，$F$为多面体面数，$E$为多面体边数，则有公式：
$$
V+F-E=2
$$
证明：

任何多面体若有一个面不是三角形，增加一对角线，即加一面、一边，$F + V - E$ 的值不变，一直重复，最后可令每一个面都是三角形。

考虑每一个面都是三角形时，取走一面，即要证明 $F + V - E = 1$。
减少一个三角形，可以取去一面、一点、兩边或一面、一边，$F + V - E$ 的值均不变，最后剩下一个三角形，可知 $F + V - E = 1 + 3 - 3 = 1$。
\subsubsection{平面图转对偶图及点定位}

最小左转法的流程：
\begin{itemize}
    \item[1] 把所有的边改成双向边。
    \item[2] 对每个点的出边按照极角排序。
    \item[3] 找一条没有标记过的边$(u,v)$，将$(u,v)$设为当前边。
    \begin{itemize}
        \item 将当前边$(u,v)$标记。
        \item 找到$v$的出边中极角序在$(v,u)$前的最后一条边，设为下一条的当前边。
        \item 重复这个过程，直到找到一条已经被标记过的当前边，这时候就找到了一个区域。
    \end{itemize}
\end{itemize}

不断重复$3$，直到所有边都被标记过。

我们把逆时针方向围成一个区域的边认为是属于这个区域的，这样一条边就只会属于唯一一个区域。

注意到有一个十分特别的区域，它是无界的，在$3$过程中，我们计算出这个区域的有向面积，如果是正的，那就说明是有界域，否则就是无界域。

这个算法直观上来讲，就是不断找到一条这条边右边最"左转"的边，这样最后你就会得到一个个由逆时针方向的边构成的区域（当然无界域看起来是顺时针的）。

\paragraph{P4073 [WC2013]平面图}
（平面图转对偶图+点定位+最小生成树）

在一个平面图中有 $n$ 个顶点和 $m$ 条直线段，
第 $i$ 个顶点的坐标为 $(x_i,y_i)$，第 $j$ 条直线段连接顶点 $u_j$ 和顶点 $v_j$。权值为 $h_j$，
除顶点 $u_j$ 和 $v_j$ 外直线段 $j$ 不经过其他的顶点。
任意两条直线段如果存在公共点，则该公共点一定是一个顶点，此时这两条直线段都会连接这个顶点。
对于任意的两个顶点 $x$ 和 $y$，总是可以找到一顶点序列 $a_1,a_2,\dot,a_k$ 使得 $a_1=x,a_k=y$ 且对于任意 $1\le i\le k$ 满足 $a_i$ 和 $a_i+1$ 被一条直线段直接连接。

这 $m$ 条直线段将整个平面分成了若干个区域，其中只有一个区域是无穷大的，其余均是有界的，我们称无穷大的区域为禁区。

现在给出 $q$ 次询问，每次给定平面中的任意两个不是顶点且分别不在任意一条直线段上的点 $A$ 和 $B$，请画一条曲线连接 $A$ 和 $B$，要求曲线不能经过禁区以及任何顶点，并使得穿过的直线段中权值最大的尽可能小。你需要对每次询问回答这个值最小为多少。

对于全部数据，均满足 $5\le n,m\le 100000$，所有直线段的权值不会超过 $10^9$。所有询问的坐标均为不超过 $10^7$ 的非负实数，且保证是 $0.5$ 的奇数倍。

\begin{lstlisting}
const int N=2e5+7;
const db eps=1e-6;

struct Point{
	//这里坐标都是原来的两倍
	//这样就可以用int储存了 
	int x,y;
	
	Point(){}
	Point(int x,int y):x(x),y(y){}
};

#define Vec Point

inline Vec operator -(const Vec &a,const Vec &b){
	return Vec(a.x-b.x,a.y-b.y);
}

inline ll Cross(const Vec &a,const Vec &b){
	return (ll)a.x*b.y-(ll)a.y*b.x;
}

inline db Angle(const Vec &a){
	return atan2(a.y,a.x);
}

int n,m,q;

namespace Graph{
	
	Point P[N];
	
	struct Edge{
		int u,v,w;
		db angle;
		Edge(){}
		Edge(int u,int v,int w):u(u),v(v),w(w),angle(Angle(P[v]-P[u])){}
	};
	
	int tot,OUT;
	int ecnt=1;
	Edge E[N];
	int ID[N];
	int nex[N];
	vector<int>G[N];
	
	inline void addedge(int u,int v,int w){
		E[++ecnt]=Edge(u,v,w),G[u].push_back(ecnt);
		E[++ecnt]=Edge(v,u,w),G[v].push_back(ecnt);
	}
	
	inline bool cmp(const int &a,const int &b){
		return E[a].angle<E[b].angle;
	}
	
	inline void work(){
		r(n),r(m);
		for(int i=1;i<=n;++i){
			int x,y;r(x),r(y);
			P[i]=Point(x*2,y*2);
		}
		for(int i=1;i<=m;++i){
			int u,v,w;
			r(u),r(v),r(w);
			addedge(u,v,w);
		}
		//极角排序 
		//ID表示排名 
		for(int i=1;i<=n;++i){
			sort(G[i].begin(),G[i].end(),cmp);
			for(int j=1;j<G[i].size();++j){
				ID[G[i][j]]=j;
			}
		}
		//nex表示下一条该走哪条
		//就是其反向边的前一条 
		for(int i=2;i<=ecnt;++i){
			int x=E[i].v;
			if(ID[i^1])nex[i]=G[x][ID[i^1]-1];
			else nex[i]=G[x][G[x].size()-1];
		}
		//ID现在表示所属区域 
		for(int i=2;i<=ecnt;++i)ID[i]=0;
		for(int i=2;i<=ecnt;++i){
			if(!ID[i]){
				ID[i]=++tot;
				ll Area=0;
				for(int j=nex[i];j!=i;j=nex[j]){
					ID[j]=tot;
					Area+=Cross(P[E[i].u]-P[E[j].u],P[E[i].u]-P[E[j].v]);
				}
				//无穷大区域面积为负 
				if(Area<0)OUT=tot;
			}
		}
	}
}

namespace Local{
	
	struct Node{
		int id;
		Point A;
		inline Node(){}
		inline Node(const int &id,const Point &A):id(id),A(A){}
		inline bool operator <(const Node &x)const {
			return (A.x==x.A.x)?id<x.id:A.x<x.A.x;
		}
	};
	
	inline bool cmp(const Node &a,const Node &b){
		return a.id<b.id;
	}
	
	int NOW; 
	struct Info{
		int id;
		db k,b;
		int x,y;
		inline Info(){}
		inline Info(const int &id,const Point &A,const Point &B):id(id){
			x=A.x;
			y=A.y;
			k=(db)(A.y-B.y)/(A.x-B.x);
			b=y-k*x;
		}
		
		inline db f()const {
			return k*NOW+b;
		}
		//先按高低排再按斜率排 
		inline bool operator < (const Info &A)const {
			db t=f()-A.f();
			if(fabs(t)<eps)return k<A.k;
			return t<0;
		}
	};
	
	Node S[N];
	Node Q[N];
	int Pos[N];
	Info Data[N];
	set<Info>Set;
	
	inline void work(){
		r(q);
		for(int i=0;i<q<<1;++i){
			db x,y;
			scanf("%lf%lf",&x,&y);
			Q[i]=Node(i,Point(x*2,y*2));
		}
		sort(Q,Q+(q<<1));
		
		using Graph::P;
		using Graph::E;
		using Graph::ID;
		using Graph::ecnt;
		int tot=0;
		for(int i=2;i<=ecnt;i+=2){
			if(P[E[i].u].x>P[E[i].v].x)i^=1;
			if(P[E[i].u].x==P[E[i].v].x)continue;
			S[tot++]=Node(i,P[E[i].u]);
			S[tot++]=Node(-i,P[E[i].v]);
		}
		sort(S,S+tot);
		
		for(int i=0,j=0;i<(q<<1);++i){
			while(j<tot&&S[j].A.x<=Q[i].A.x){
				NOW=S[j].A.x;
				int id=S[j].id;
				if(id<0)Set.erase(Data[-id]);
				else Set.insert(Data[id]=Info(id,P[E[id].u],P[E[id].v]));
				++j;
			}
			NOW=Q[i].A.x;
			Point A=Q[i].A;
			Point B=A;B.x++;
			//上面没有边，在无界区域 
			if(Set.lower_bound(Info(0,A,B))==Set.end())Pos[Q[i].id]=Graph::OUT;
			else {
				//上面有边，因为当前边一定是从左到右，所以在其反向边所在区域 
				Info t=*Set.lower_bound(Info(0,A,B));
				Pos[Q[i].id]=ID[t.id^1];
			}
		}
	}
	
}

namespace Tree{
	struct Edge{
		int u,v,w;
		
		inline Edge(){}
		inline Edge(int u,int v,int w):u(u),v(v),w(w){}
		
		inline bool operator <(const Edge &a)const{
			return w<a.w;
		}
	}E[N];
	
	int ecnt;
	int fir[N],nex[N],to[N],w[N];
	
	inline void addedge(int u,int v,int c){
		nex[++ecnt]=fir[u],fir[u]=ecnt,to[ecnt]=v,w[ecnt]=c;
		nex[++ecnt]=fir[v],fir[v]=ecnt,to[ecnt]=u,w[ecnt]=c;
	}
	
	int dep[N];
	int ac[N][20];
	int mx[N][20];
	
	void dfs(int x,int f){
		dep[x]=dep[f]+1;
		ac[x][0]=f;
		for(int i=1;(ac[x][i]=ac[ac[x][i-1]][i-1]);++i){
			mx[x][i]=max(mx[x][i-1],mx[ac[x][i-1]][i-1]);
		}
		for(int i=fir[x];i;i=nex[i]){
			int v=to[i];
			if(v==f)continue;
			mx[v][0]=w[i];
			dfs(v,x);
		}
	}
	
	inline int query(int u,int v){
		int ret=0;
		if(dep[u]<dep[v])swap(u,v);
		for(int i=17;~i;--i){
			if(dep[ac[u][i]]>=dep[v]){
				ret=max(ret,mx[u][i]);
				u=ac[u][i];
			}
		}
		if(u==v)return ret;
		for(int i=17;~i;--i){
			if(ac[u][i]!=ac[v][i]){
				ret=max(ret,mx[u][i]);
				ret=max(ret,mx[v][i]);
				u=ac[u][i],v=ac[v][i];
			}
		}
		return max(ret,max(mx[u][0],mx[v][0]));
	}

	int fa[N];
	
	int find(int x){
		return x==fa[x]?x:fa[x]=find(fa[x]);
	}
	
	inline bool uni(int u,int v){
		u=find(u),v=find(v);
		if(u==v)return 0;
		fa[u]=v;
		return 1;
	}
	//注意特判无解 
	inline void solve(){
		using Graph::ID;
		int tot=0;
		for(int i=2;i<=Graph::ecnt;i+=2){
			E[++tot]=Edge(ID[i],ID[i^1],Graph::E[i].w);
		}
		sort(E+1,E+tot+1);
		for(int i=1;i<=Graph::tot;++i)fa[i]=i;
		for(int i=1;i<=tot;++i){
			if(E[i].u==Graph::OUT||E[i].v==Graph::OUT)continue;
			if(uni(E[i].u,E[i].v)){
				addedge(E[i].u,E[i].v,E[i].w);
				if(ecnt==(n-1)*2)break;
			}
		}
		for(int i=1;i<=Graph::tot;++i){
			if(!ac[i][0])dfs(i,0);
		}
		using Local::Pos;
		for(int i=0;i<(q<<1);i+=2){
			if(find(Pos[i])!=find(Pos[i^1])||Pos[i]==Graph::OUT)puts("-1");
			else printf("%d\n",query(Pos[i],Pos[i^1]));
		}
	}
}

int main(){
	Graph::work();
	Local::work();
	Tree::solve();
	return 0;
}
\end{lstlisting}
\subsubsection{圆反演}
\paragraph{定义}
给定圆 $C(O, R)$，则 $P$ 关于圆 $O$ 的反演点 $P^{\prime}$ 满足 $\vec{OP'} = \frac{R^2}{|\vec{OP}|^2} \vec{OP}$

\paragraph{性质}
\begin{itemize}
    \item 圆内点与圆外点互为反演点，圆上点的反演点是本身；
    \item 过圆心的直线的反演图形是本身；
    \item 不过反演中心的直线，反形是过反演中心的圆；
    \item 过反演中心的圆，反形是不过反演中心的直线；
    \item 不过反演中心的圆，反形也是不过反演中心的圆，且反演中心是它们的位似中心
    \item 相切两圆的反形仍相切，若切点恰是反演中心，则反形为两平行线。
\end{itemize}

\paragraph{例题} 2023 川大校赛 O. 捕鱼达人！

给定平面上 $n(1\le n \le 1000)$ 个点，
每个点有点权 $v_i(-10^7 \le v_i \le 10^7$)，
和坐标$-10^4\le x, y\le 10^4$，
求过原点的圆能覆盖点的最大权值和（允许退化成半平面）。

考虑对原点的圆⼼圆反演，这样过原点的圆变为一条直线，
问题变为找一条线使得线一侧的权值和最大。

枚举一个点极角排序双指针统计即可。

\begin{lstlisting}
const db eps = 1e-10;

inline int dcmp(const db &x){
    if(fabs(x)<eps)return 0;
    return x>0?1:-1;
}

inline db Angle(const Vec &a){
	return atan2(a.y,a.x);
}

inline int Quadrant(const Point &A){
	if(dcmp(A.x) > 0 && dcmp(A.y) >= 0) return 1;
	if(dcmp(A.x) <= 0 && dcmp(A.y) > 0) return 2;
	if(dcmp(A.x) < 0 && dcmp(A.y) <= 0) return 3;
	if(dcmp(A.x) >= 0 && dcmp(A.y) < 0) return 4;
	assert(0);
	return 0;
}

const int R = 200; // 注意精度

inline Point trans(const Point &A){
	return A * R / norm2(A) * R;
}

const int N = 3000;

Point A[N];
Point B[N];
int val[N];
int w[N];
int ord[N];

int main(){
	// freopen(".in","r",stdin);
	// freopen(".out","w",stdout);
	int n; r(n);
	for(int i = 0; i < n; ++i){
		r(val[i]);
	}
	for(int i = 0; i < n; ++i){
		int x, y; r(x), r(y);
		A[i] = Point(x, y);
	}
	ll ans = 0;
	for(int i = 0; i < n; ++i){
		ll sum1 = 0;
		ll sum2 = 0;
		for(int j = 0; j < n; ++j){
			if(dcmp(cross(A[i], A[j])) >= 0){
				sum1 += val[j];
			}
			if(dcmp(cross(A[i], A[j])) <= 0){
				sum2 += val[j];
			}
		}
		ans = max(ans, sum1);
		ans = max(ans, sum2);
	}
	for(int i = 0; i < n; ++i){
		A[i] = trans(A[i]);
		ord[i] = i;
	}
	for(int i = 0; i < n; ++i){
		for(int j = 0; j < n; ++j){
			B[j] = i == j ? Point(0, 0) - A[i] : A[j] - A[i];
			w[j] = i == j ? 0 : val[j];
		}
		sort(ord, ord + n, [i](const int &X, const int &Y){
			int qa = Quadrant(B[X]);
			int qb = Quadrant(B[Y]);
			if(qa != qb) return qa < qb;
			else if(dcmp(cross(B[X], B[Y])) != 0){
				return dcmp(cross(B[X], B[Y])) == 1;
			}
			else return norm(B[X]) < norm(B[Y]);
		});
		for(int i = 0; i < n * 2; ++i){
			ord[i + n] = ord[i];
		}
		int st = 0;
		while(ord[st] != i) ++st;
		int p1 = st;
		int p2 = st - 1;
		ll sum = val[i];
		int cnt = 0;
		while(p1 < st + n){
			while(p1 < st + n && dcmp(cross(B[ord[p1]], B[ord[p1 + 1]])) == 0 && dcmp(dot(B[ord[p1]], B[ord[p1 + 1]])) == 1){
				sum -= w[ord[p1]];
				++p1;
			}
			while(p2 < p1){
				sum += w[ord[p2 + 1]];
				++p2;
			}
			if(dcmp(cross(B[ord[p1]], B[ord[st]])) > 0 || (dcmp(cross(B[ord[p1]], B[ord[st]])) == 0 && dcmp(dot(B[ord[p1]], B[ord[st]]) < 0))) break;
			while(dcmp(cross(B[ord[p1]], B[ord[p2 + 1]])) > 0 || (dcmp(cross(B[ord[p1]], B[ord[p2 + 1]])) == 0 && dcmp(dot(B[ord[p1]], B[ord[p2 + 1]]) < 0))){
				sum += w[ord[p2 + 1]];
				++p2;
			}
			sum -= w[ord[p1]];
			++p1;
			ans = max(ans, sum);
		}
		assert(p1 <= 2 * n);
		assert(p2 < 3 * n);
	}
	printf("%lld\n", ans);
	return 0;
}
\end{lstlisting}

% \subsubsection{三角剖分}
\section{字符串}
\subsection{KMP}
\begin{lstlisting}
for(int i=2,j=0;i<=m;++i){
    while(t[j+1]!=t[i]&&j)j=Next[j];
    if(t[j+1]==t[i])++j;
    Next[i]=j;
}
for(int i=2,j=0;i<=n;++i){
    while(j&&t[j+1]!=s[i])j=Next[j];
    if(t[j+1]==s[i])++j;
    if(j==m){
        ++ans;
        j=Next[j];
    }
}
\end{lstlisting}
\subsection{AC自动机}
给你一个文本串 $S$ 和 $n$ 个模式串 $T_{1..n}$，请你分别求出每个模式串 $T_i$. 在 $S$ 中出现的次数。\\
数据不保证任意两个模式串不相同。
\begin{lstlisting}
#include<bits/stdc++.h>

using namespace std;

#define gc c=getchar()
#define r(x) read(x)
#define ll long long
#define db double

template<typename T>
inline void read(T&x){
    x=0;T k=1;char gc;
    while(!isdigit(c)){if(c=='-')k=-1;gc;}
    while(isdigit(c)){x=x*10+c-'0';gc;}x*=k;
}

const int N=2e5+7;
const int M=2e6+7;
int tot;
int trans[N][26];
vector<int>dep[N];

inline int Insert(char *s){
    int n=strlen(s),x=0;
    for(int i=0;i<n;++i){
        int c=s[i]-'a';
        if(!trans[x][c]){
            trans[x][c]=++tot;
            dep[i].push_back(tot);
        }
        x=trans[x][c];
    }
    return x;
}

int fail[N];
queue<int>Q;

inline void GetFail(){
    for(int c=0;c<26;++c){
        if(trans[0][c]){
            Q.push(trans[0][c]);
        }
    }
    while(!Q.empty()){
        int x=Q.front();
        Q.pop();
        for(int c=0;c<26;++c){
            if(!trans[x][c]){
                trans[x][c]=trans[fail[x]][c];
            }
            else {
                fail[trans[x][c]]=trans[fail[x]][c];
                Q.push(trans[x][c]);
            }
        }
    }
}

vector<int>ID[N];
int tag[N];
int cnt[N];

inline void Query(char *s){
    int n=strlen(s),x=0;
    for(int i=0;i<n;++i){
        int c=s[i]-'a';
        x=trans[x][c];
        tag[x]++;
    }
    for(int i=N-1;~i;--i){
        for(int j=0;j<dep[i].size();++j){
            int x=dep[i][j];
            for(int k=0;k<ID[x].size();++k){
                cnt[ID[x][k]-1]=tag[x];
            }
            tag[fail[x]]+=tag[x];
        }
    }
}

char s[M];

int main(){
    int n;r(n);
    for(int i=0;i<n;++i){
        scanf("%s",s);
        ID[Insert(s)].push_back(i+1);
    }
    GetFail();
    scanf("%s",s);
    Query(s);
    for(int i=0;i<n;++i){
        printf("%d\n",cnt[i]);
    }
    return 0;
}
\end{lstlisting}
\subsection{Manacher}
\begin{lstlisting}
char s[N];
char t[N<<1];
int p[N<<1];

inline int manacher(){
    t[0]='@';
    t[1]='#';
    int m=strlen(s),n=1;
    for(int i=0;i<m;++i)t[++n]=s[i],t[++n]='#';
    t[++n]=0;
    int ans=0,mx=1,id;
    for(int i=0;i<n;++i){
        if(i<mx)p[i]=min(p[(id<<1)-i],mx-i);
        else p[i]=1;
        while(t[i-p[i]]==t[i+p[i]])++p[i];
        if(mx<i+p[i])mx=(id=i)+p[i];
        ans=max(ans,p[i]);
    }
    return ans-1;
}

\end{lstlisting}
% \subsection{字符串哈希}
% \subsection{字典树}
\subsection{后缀数组}
P3966 [TJOI2013]单词\\
给出$n$个单词，求每个单词在这$n$个单词中出现的次数
\begin{lstlisting}
const int N=1e6+207;

namespace Suffix_Array{
    int n,m;
    
    int SA[N];
    int Rank[N];
    int tmp[N];
    int cnt[N];
    
    inline void Qsort(int *a,int *b){
        for(int i=1;i<=m;++i)cnt[i]=0;
        for(int i=1;i<=n;++i)cnt[a[i]]++;
        for(int i=1;i<=m;++i)cnt[i]+=cnt[i-1];
        for(int i=n;i>=1;--i)SA[cnt[a[b[i]]]--]=b[i];
    }
    
    inline void GetSA(int *s,int len){
        n=len,m=300;
        for(int i=1;i<=n;++i)Rank[i]=s[i];
        for(int i=1;i<=n;++i)tmp[i]=i;
        Qsort(Rank,tmp);
        for(int l=1,p=0;p<n;l<<=1){
            p=0;
            for(int i=1;i<=l;++i)tmp[++p]=n-i+1;
            for(int i=1;i<=n;++i)if(SA[i]>l)tmp[++p]=SA[i]-l;
            Qsort(Rank,tmp);
            memcpy(tmp+1,Rank+1,n<<2);
            p=Rank[SA[1]]=1;
            for(int i=2;i<=n;++i){
                if(tmp[SA[i]]!=tmp[SA[i-1]]||tmp[SA[i]+l]!=tmp[SA[i-1]+l])++p;
                Rank[SA[i]]=p;
            }
            m=p;
        }
    }
    
    int Hight[N];
    
    inline void GetHight(int *s){
        for(int i=1,p=0;i<=n;++i){
            int j=SA[Rank[i]-1];
            if(p)--p;
            while(s[i+p]==s[j+p]&&p<n)++p;
            Hight[Rank[i]]=p;
        }
    }
    
    int st[N][20];
    int LG[N];
    
    inline void RMQinit(){
        for(int i=1;i<=n;++i)st[i][0]=Hight[i];
        for(int i=2;i<=n;++i)LG[i]=LG[i>>1]+1;
        for(int i=1;i<=LG[n];++i){
            for(int j=1;j+(1<<i)-1<=n;++j){
                st[j][i]=min(st[j][i-1],st[j+(1<<(i-1))][i-1]);
            }
        }
    }
    
    inline int lcp(int l,int r){
        int x=LG[r-l];
        return min(st[l+1][x],st[r-(1<<x)+1][x]);
    }
    
    inline int query(int x,int len){
        x=Rank[x];
        /*
        int l=x,r=x+1;
        while(Hight[l]>=len)--l;
        while(Hight[r]>=len)++r;--r;
        return r-l+1;
        */
        
        int l=1,r=x,mid,ans=x,ret=0;
        while(l<=r){
            mid=(l+r)>>1;
            if(lcp(mid,x)>=len)r=mid-1,ans=mid;
            else l=mid+1;
        }
        ret+=x-ans;
        ans=l=x,r=n;
        while(l<=r){
            mid=(l+r)>>1;
            if(lcp(x,mid)>=len)l=mid+1,ans=mid;
            else r=mid-1;
        }
        ret+=ans-x;
        return ret+1;
        
    }
}

char str[N];
int s[N];
int pos[N];
int len[N];

int main(){
    int n,p=0;r(n);
    for(int i=1;i<=n;++i){
        scanf("%s",str);
        pos[i]=p+1;
        len[i]=strlen(str);
        for(int j=0;j<len[i];++j){
            s[++p]=str[j]-'a'+1;
        }
        s[++p]=26+i;
    }
    Suffix_Array::GetSA(s,p);
    Suffix_Array::GetHight(s);
    Suffix_Array::RMQinit();
    for(int i=1;i<=n;++i){
        printf("%d\n",Suffix_Array::query(pos[i],len[i]));
    }
}
\end{lstlisting}
\subsection{后缀自动机}
P2178 [NOI2015]品酒大会
\begin{lstlisting}
#include<bits/stdc++.h>

using namespace std;

#define gc c=getchar()
#define r(x) read(x)
#define ll long long

template<typename T>
inline void read(T&x){
    x=0;T k=1;char gc;
    while(!isdigit(c)){if(c=='-')k=-1;gc;}
    while(isdigit(c)){x=x*10+c-'0';gc;}x*=k;
}

const int N=6e5+7;
const int INF=1e9;

int tot;
int len[N],fa[N],trans[N][26],siz[N];
int mx[N],_mx[N],mi[N],_mi[N];
vector<int>G[N];

inline int NewNode(int l,int *tr,int su){
	++tot;
	fa[tot]=su;
	len[tot]=l;
	mi[tot]=_mi[tot]=INF;
	mx[tot]=_mx[tot]=-INF;
	if(tr!=NULL)memcpy(trans[tot],tr,26<<2);
	return tot;
}

inline int Extend(int u,int c){
	int t=NewNode(len[u]+1,NULL,0);
	for(;u&&!trans[u][c];u=fa[u])trans[u][c]=t;
	if(!u){
		fa[t]=1;
		return t;
	}
	int v=trans[u][c];
	if(len[v]==len[u]+1){
		fa[t]=v;
		return t;
	}
	int x=NewNode(len[u]+1,trans[v],fa[v]);
	fa[t]=fa[v]=x;
	for(;u&&trans[u][c]==v;u=fa[u])trans[u][c]=x;
	return t;
}

inline void Max(int x,int v){
	if(v>=mx[x])_mx[x]=mx[x],mx[x]=v;
	else if(v>_mx[x])_mx[x]=v;
}

inline void Min(int x,int v){
	if(v<=mi[x])_mi[x]=mi[x],mi[x]=v;
	else if(v<_mi[x])_mi[x]=v;
}

ll sum[N],ans[N];

void dfs(int x){
	for(int i=0;i<G[x].size();++i){
		int v=G[x][i];
		dfs(v);
		sum[len[x]]+=(ll)siz[x]*siz[v];
		siz[x]+=siz[v];
		Max(x,mx[v]);
		Max(x,_mx[v]);
		Min(x,mi[v]);
		Min(x,_mi[v]);
	}
	if(siz[x]>1)ans[len[x]]=max(ans[len[x]],max((ll)mx[x]*_mx[x],(ll)mi[x]*_mi[x]));
}

int w[N];
char s[N];

int main(){
	int n;r(n);
	scanf("%s",s);
	for(int i=0;i<n;++i)r(w[i]);
	int lst=NewNode(0,NULL,0);
	for(int i=n-1;~i;--i){
		lst=Extend(lst,s[i]-'a');
		mx[lst]=mi[lst]=w[i];
		siz[lst]=1;
		ans[i]=-INF;
	}
	for(int i=2;i<=tot;++i)G[fa[i]].push_back(i);
	dfs(1);
	for(int i=n-2;~i;--i){
		sum[i]+=sum[i+1];
		ans[i]=max(ans[i],ans[i+1]);
	}
	for(int i=0;i<n;++i){
		printf("%lld %lld\n",sum[i],sum[i]?ans[i]:0);
	}
}
\end{lstlisting}
% \subsection{后缀树}
% \subsection{后缀平衡树}
% \subsection{回文树}
% \subsection{回自动机}
\section{图论}
\subsection{最短路}
\subsubsection{Dijkstra}
\begin{lstlisting}
struct data{
    int a,b;
    bool operator < (const data& x)const{
        return a>x.a;
    }
};

priority_queue<data>Q;
inline void dijkstra(int s){
    memset(dis+1,INF,n<<2);
    dis[s]=0;
    Q.push(data{0,s});
    while(!Q.empty()){
        int x=Q.top().b;
        int d=Q.top().a;
        Q.pop();
        if(d!=dis[x])continue;
        for(int i=fir[x],v,t;i;i=nex[i]){
            if((t=d+w[i])<dis[v=to[i]]){
                dis[v]=t;
                Q.push(data{t,v});
            }
        }
    }
}
\end{lstlisting}
\subsubsection{SPFA}
\begin{lstlisting}
inline void spfa(){
    for(int i=1;i<=n;++i)dis[i]=inf;
    dis[s]=0;
    Q.push(s);
    while(!Q.empty()){
        int x=Q.front();
        Q.pop();
        for(int i=fir[x];i;i=nex[i]){
            int v=to[i];
            if(dis[v]>dis[x]+w[i]){
                dis[v]=dis[x]+w[i];
                Q.push(v);
            }
        }
    }
}
\end{lstlisting}
\subsubsection{Floyd}
写不出来就可以退役了
\subsection{二分图最大匹配}
给定一个二分图，其左部点的个数为 $n$，右部点的个数为 $m$，边数为 $e$，求其最大匹配的边数。
\begin{lstlisting}
const int N=1005;

int fir[N];
int nex[N*N];
int to[N*N];

int vis[N];
int match[N<<1];

bool dfs(int x,int Tim){
	for(int i=fir[x];i;i=nex[i]){
		int v=to[i];
		if(vis[v]!=Tim){
			vis[v]=Tim;
			if(!match[v]||dfs(match[v],Tim)){
				match[v]=x;
				return 1;
			}
		}
	}
	return 0;
}

int main(){
	int n,m,e;r(n),r(m),r(e);
	for(int i=1;i<=e;++i){
		int u,v;r(u),r(v);
		if(u>n||v>m)continue;
		nex[i]=fir[u],fir[u]=i,to[i]=v+n;
	}
	int ans=0;
	for(int i=1;i<=m;++i){
		ans+=dfs(i,i);
	}
	printf("%d\n",ans);
	return 0;
}
\end{lstlisting}
\subsection{tarjan}
\subsubsection{割点}
\begin{lstlisting}
const int N=100005;

int ecnt;
int fir[N],nex[N<<1],to[N<<1];

inline void addedge(int u,int v){
    nex[++ecnt]=fir[u];fir[u]=ecnt;to[ecnt]=v;
    nex[++ecnt]=fir[v];fir[v]=ecnt;to[ecnt]=u;
}

int dfs_clock,dfn[N],low[N];
bool cut[N];
inline void dfs(int x,int rt){
    low[x]=dfn[x]=++dfs_clock;
    int ch=0;
    for(int i=fir[x];i;i=nex[i]){
        int v=to[i];
        if(!dfn[v]){
            dfs(v,rt);
            low[x]=min(low[x],low[v]);
            if(low[v]>=dfn[x]&&x!=rt)cut[x]=1;
            if(x==rt)++ch;
        }
        else low[x]=min(low[x],dfn[v]);
    }
    if(x==rt&&ch>=2)cut[x]=1;
}	

int cnt,Q[N];

int main(){
    int n,m;scanf("%d%d",&n,&m);
    for(int i=1,x,y;i<=m;++i)scanf("%d%d",&x,&y),addedge(x,y);
    for(int i=1;i<=n;++i)if(!dfn[i])dfs(i,i);
    for(int i=1;i<=n;++i)if(cut[i])Q[++cnt]=i;
    printf("%d\n",cnt);
    for(int i=1;i<=cnt;++i)printf("%d ",Q[i]);
}
\end{lstlisting}
\subsubsection{缩点}
环缩成点
\begin{lstlisting}
const int N=1e4+5;
const int M=1e5+5;

int ecnt;
int fir[N],nex[M],to[M],from[M];

inline void addedge(int u,int v){
    nex[++ecnt]=fir[u];fir[u]=ecnt;to[ecnt]=v;from[ecnt]=u;
}

int dfs_clock,dfn[N],low[N],scc[N],w[N],val[N],id;
bool vis[N];
int sta[N],top=0;
inline void dfs(int x){
    low[x]=dfn[x]=++dfs_clock;
    sta[++top]=x;
    vis[x]=1;
    for(int i=fir[x];i;i=nex[i]){
        int v=to[i];
        if(!dfn[v]){
            dfs(v);
            low[x]=min(low[x],low[v]);
        }
        else if(vis[v]) low[x]=min(low[x],dfn[v]);
    }
    if(dfn[x]==low[x]){
        ++id;
        while(sta[top+1]!=x){
            scc[sta[top]]=id;
            val[id]+=w[sta[top]];
            vis[sta[top--]]=0;
            
        }
    }
    
}
    
int main(){
    int n,m;r(n);r(m);
    for(int i=1;i<=n;++i)r(w[i]);
    for(int i=1,x,y;i<=m;++i)r(x),r(y),addedge(x,y);
    for(int i=1;i<=n;++i)if(!dfn[i])dfs(i);
    memset(fir+1,0,n<<1);
    ecnt=0;
    for(int i=1;i<=m;++i){
        int u=scc[from[i]],v=scc[to[i]];
        if(u!=v)addedge(u,v);
    }
    ...
}
\end{lstlisting}
\subsection{圆方树}
BZOJ2125 最短路\\
给定一棵仙人掌，每次询问仙人掌两点间的最短路，$n\le 10000,Q\le 10000​$。
\begin{lstlisting}
const int N=40005;

int n,m,q,tot;

namespace tr{
	int ecnt;
	int fir[N],nex[N],to[N],w[N];
	
	inline void addedge(int u,int v,int c){
		nex[++ecnt]=fir[u],fir[u]=ecnt,to[ecnt]=v,w[ecnt]=c;
	}
	
	int dfs_clock;
	int fa[N],siz[N],dep[N],son[N],top[N],dis[N],dfn[N],ptn[N],sum[2][N];
	
	void dfs1(int x,int f){
		fa[x]=f;
		dep[x]=dep[f]+1;
		siz[x]=1;
		for(int i=fir[x];i;i=nex[i]){
			int v=to[i];
			dis[v]=dis[x]+w[i];
			dfs1(v,x);
			siz[x]+=siz[v];
			if(siz[son[x]]<siz[v])son[x]=v;
		}
	}
	
	void dfs2(int x,int t){
		top[x]=t;
		dfn[x]=++dfs_clock;
		ptn[dfs_clock]=x;
		if(!son[x])return ;
		dfs2(son[x],t);
		for(int i=fir[x];i;i=nex[i]){
			int v=to[i];
			if(v!=son[x])dfs2(v,v);
		}
	}
	
	inline int lca(int u,int v){
		while(top[u]!=top[v]){
			if(dep[top[u]]<dep[top[v]])swap(u,v);
			u=fa[top[u]];
		}
		return dep[u]<dep[v]?u:v;
	}
	
	inline int lst(int u,int v){
		int ret; 
		while(top[u]!=top[v]){
			ret=top[u],u=fa[top[u]];
		}
		return u==v?ret:ptn[dfn[v]+1];
	}
	
	inline int clac(int u,int v,int f){
		int d1=sum[0][u]>sum[1][u];
		int d2=sum[0][v]>sum[1][v];
		int d;
		if(d1==d2)d=abs(sum[d1][u]-sum[d2][v]);
		else d=sum[d1][u]+sum[d2][v];
		return min(d,sum[0][u]+sum[1][u]-d);
	}
	
	inline int query(int u,int v){
		int LCA=lca(u,v);
		if(LCA<=n)return dis[u]+dis[v]-dis[LCA]*2;
		int u0=lst(u,LCA);
		int v0=lst(v,LCA);
		return dis[u]+dis[v]-dis[u0]-dis[v0]+clac(u0,v0,LCA);
	}
	
}

namespace ca{
	int ecnt;
	int fir[N],nex[N],to[N],w[N];
	
	inline void addedge(int u,int v,int c){
		nex[++ecnt]=fir[u],fir[u]=ecnt,to[ecnt]=v,w[ecnt]=c;
		nex[++ecnt]=fir[v],fir[v]=ecnt,to[ecnt]=u,w[ecnt]=c;
	}
	
	int dfs_clock;
	int fa[N],dis[N],low[N],dfn[N];
	
	inline void add_circle(int u,int v,int c){
		tr::addedge(u,++tot,0);
		int sum1=c;
		int sum2=dis[v]-dis[u];
		for(int i=v;i!=u;i=fa[i]){
			tr::sum[0][i]=sum1;
			tr::sum[1][i]=sum2;
			tr::addedge(tot,i,min(sum1,sum2));
			int d=dis[i]-dis[fa[i]];
			sum1+=d;
			sum2-=d;
		}
	}

	void dfs(int x,int f){
		fa[x]=f;
		dfn[x]=low[x]=++dfs_clock;
		for(int i=fir[x];i;i=nex[i]){
			int v=to[i];
			if(v==f)continue;
			if(!dfn[v]){
				dis[v]=dis[x]+w[i];
				dfs(v,x);
				low[x]=min(low[x],low[v]);
				if(dfn[x]<low[v])tr::addedge(x,v,w[i]);
			}
			else {
				low[x]=min(low[x],dfn[v]);
				if(dfn[x]<dfn[v])add_circle(x,v,w[i]);
			}
		}
	}	

}

int main(){
	r(n),r(m),r(q),tot=n;
	for(int i=1,u,v,w;i<=m;++i){
		r(u),r(v),r(w);
		ca::addedge(u,v,w);
	}
	ca::dfs(1,0);
	tr::dfs1(1,0);
	tr::dfs2(1,1);
	while(q--){
		int u,v;r(u),r(v);
		printf("%d\n",tr::query(u,v));
	}
	return 0;
}
\end{lstlisting}
\subsection{网络流}
\subsubsection{最大流}

\paragraph{模板}

P3376【模板】网络最大流
\begin{lstlisting}
const int N=10005;
const int M=100005;
const int INF=0x3f3f3f3f;

int n,m,s,t,ecnt=1;
int fir[N],cur[N],dep[N],nex[M<<1],to[M<<1],w[M<<1];

inline void addedge(int u,int v,int c){
    nex[++ecnt]=fir[u],fir[u]=ecnt,to[ecnt]=v,w[ecnt]=c;
    nex[++ecnt]=fir[v],fir[v]=ecnt,to[ecnt]=u,w[ecnt]=0;
}

inline bool bfs(){
    memset(dep+1,0,n<<2);
    memcpy(cur+1,fir+1,n<<2);
    dep[s]=1;
    queue<int>Q;
    Q.push(s);
    while(!Q.empty()){
        int x=Q.front();
        Q.pop();
        for(int i=fir[x];i;i=nex[i]){
            int v=to[i];
            if(dep[v]||!w[i])continue;
            dep[v]=dep[x]+1;
            if(v==t)return 1;
            Q.push(v);
        }
    }
    return 0;
}

int dfs(int x,int lim){
    if(x==t||!lim)return lim;
    int flow=0;
    for(int &i=cur[x],f;i&&lim;i=nex[i]){
        int v=to[i];
        if((dep[v]==dep[x]+1)&&(f=dfs(v,min(lim,w[i])))){
            if(f){
                w[i]-=f;
                w[i^1]+=f;
                flow+=f;
                lim-=f;
            }
        }
    }
    return flow;
}

int main(){
    r(n),r(m),r(s),r(t);
    for(int i=1;i<=m;++i){
        int u,v,c;
        r(u),r(v),r(c);
        addedge(u,v,c);
    }
    long long Ans=0;
    while(bfs()){
        Ans+=dfs(s,INF);
    }
    printf("%lld\n",Ans);
    return 0;
}
\end{lstlisting}

vector 版 Dinic
\begin{lstlisting}
int tot,s,t,ecnt;
namespace Dinic{
    const int N = 5e5 + 7;
    struct edge{
        int v,r;ll cap;
        edge(int a=0,ll b=0,int c=0):v(a),cap(b),r(c){}
    };
    vector<edge> e[N];
    inline void addedge(int u,int v,ll w){
        ecnt+=2;
        e[u].pb(edge(v,w,e[v].size()));
        e[v].pb(edge(u,0,e[u].size()-1));
    }
    #define It vector<edge>::iterator
    int lev[N];It tp[N];
    queue<int> q;
    inline bool bfs(){
        memset(lev,-1,sizeof(ll)*(tot+1));
        lev[s]=0,q.push(s);
        while(!q.empty()){
            int u=q.front();q.pop();
            for(edge &x:e[u]){
                if(lev[x.v]==-1&&x.cap>0){
                    lev[x.v]=lev[u]+1,q.push(x.v);
                }
            }
        }
        return lev[t]!=-1;
    }
    ll dfs(int u,ll flow){
        if(u==t)return flow;
        ll res=0;
        for(It &it=tp[u];it!=e[u].end();it++){
            if(lev[it->v]==lev[u]+1&&it->cap>0){
                ll now=dfs(it->v,min(it->cap,flow-res));
                res+=now,it->cap-=now,e[it->v][it->r].cap+=now;
                if(res==flow)break;
            }
        }
        return res;
    }
    inline ll maxflow(){
        ll res=0;
        while(bfs()){
            for(int i=1;i<=tot;i++)tp[i]=e[i].bg();
            res+=dfs(s,INF);
        }
        return res;
    }
}
\end{lstlisting}

ISAP
\begin{lstlisting}
struct Edge {
    int u, v;
    ll cap;
    Edge(int _u, int _v, ll _cap) {
        u = _u, v = _v, cap = _cap;
    }
};

const int maxn = 1e6 + 7;

struct ISAP{
    vector<Edge> edge;
    vector<int> G[maxn];
    ll dis[maxn], cur[maxn];
    int n, s, t;
    ll p[maxn], num[maxn];
    bool vis[maxn];
    void init(int _n, int _s, int _t) {
        this->n = _n, this->s = _s, this->t = _t;
        for (int i = 1; i <= _n; i++) G[i].clear();
        edge.clear();
    }
    void add(int u, int v, ll cap) {
        edge.push_back(Edge(u, v, cap));
        edge.push_back(Edge(v, u, 0));
        int siz = edge.size();
        G[u].push_back(siz - 2);
        G[v].push_back(siz - 1);
    }
    void BFS() {
        for (int i = 1; i <= n; i++) dis[i] = n;
        queue<int> que;
        que.push(t);
        dis[t] = 0;
        while (que.size()) {
            int u = que.front();
            que.pop();
            for (int i = 0; i < G[u].size(); i++) {
                Edge &e = edge[G[u][i]];
                if (e.cap == 0 && dis[e.v] == n) {
                    que.push(e.v);
                    dis[e.v] = dis[u] + 1;
                }
            }
        }
    }
    ll Augment() {
        ll x = t, a = INF;
        while (x != s) {
            Edge &e = edge[p[x]];
            a       = min(a, e.cap);
            x       = edge[p[x]].u;
        }
        x = t;
        while (x != s) {
            edge[p[x]].cap -= a;
            edge[p[x] ^ 1].cap += a;
            x = edge[p[x]].u;
        }
        return a;
    }
    ll MaxFlow() {
        ll flow = 0LL;
        BFS();
        memset(num, 0, sizeof num);
        for (int i = 0; i <= n; i++) num[dis[i]]++;
        int x = s;
        memset(cur, 0, sizeof cur);
        while (dis[s] < n) {
            if (x == t) {
                flow += Augment();
                x = s;
            }
            int ok = 0;
            for (int i = cur[x]; i < G[x].size(); i++) {
                Edge &e = edge[G[x][i]];
                if (e.cap && dis[x] == dis[e.v] + 1) {
                    ok     = 1;
                    p[e.v] = G[x][i];
                    cur[x] = i;
                    x      = e.v;
                    break;
                }
            }
            if (!ok) {
                ll m = n - 1;
                for (int i = 0; i < G[x].size(); i++) {
                    Edge &e = edge[G[x][i]];
                    if (e.cap) m = min(m, dis[e.v]);
                }
                if (--num[dis[x]] == 0) break;
                num[dis[x] = m + 1]++;
                cur[x] = 0;
                if (x != s) x = edge[p[x]].u;
            }
        }
        return flow;
    }
};
\end{lstlisting}

HLPP
\begin{lstlisting}
template <typename Cap>
struct HLPP {
    struct Edge {
        int j, q;
        Cap x;
    };
    int N, K = 0;
    vector<vector<Edge>> G;
    HLPP(int n): N(n), G(N) { }
    void addEdge(int i, int j, Cap x, Cap y = 0) {
        int p=G[i].size(), q=G[j].size();
        G[i].push_back({j, q, x});
        G[j].push_back({i, p, y});
    }
    Cap calc(int src, int sink, Cap inf = numeric_limits<Cap>::max()) {
        vector<int> pos(N);
        vector<Cap> ex(N);
        int queue[N], height[N], ex_next[N * 2], gap_prev[N * 2], gap_next[N * 2];
        int ex_highest = 0, gap_highest = 0, discharge_count = 0;
        auto ex_insert = [&](int i, int h) {
            ex_next[i] = ex_next[N + h];
            ex_next[N + h] = i;
            ex_highest = max(ex_highest, h);
        };
        auto gap_insert = [&](int i, int h) {
            gap_prev[i] = N + h;
            gap_next[i] = gap_next[N + h];
            gap_prev[gap_next[i]] = gap_next[gap_prev[i]] = i;
            gap_highest = max(gap_highest, h);
        };
        auto gap_erase = [&](int i) {
            gap_next[gap_prev[i]] = gap_next[i];
            gap_prev[gap_next[i]] = gap_prev[i];
        };
        auto ex_add = [&](int i, Cap f) {
            ex[i] += f;
            if (ex[i] == f) ex_insert(i, height[i]);
        };
        auto update_height = [&](int i, int h) {
            if (height[i] != N + 1) gap_erase(i);
            height[i] = h;
            if (h == N + 1) return;
            gap_insert(i, h);
            if (ex[i] > 0) ex_insert(i, h);
        };
        auto global_relabel = [&] {
            discharge_count = 0;
            iota(ex_next + N, ex_next + N * 2, N);
            iota(gap_prev + N, gap_prev + N * 2, N);
            iota(gap_next + N, gap_next + N * 2, N);
            fill(height, height + N, N + 1);
            height[sink] = 0;
            int head = 0, tail = 0;
            queue[tail++] = sink;
            while (head < tail) {
                int i = queue[head++];
                for (auto& [j, q, x] : G[i]) {
                    if (!G[j][q].x || height[j] <= height[i] + 1) continue;
                    update_height(j, height[i] + 1);
                    queue[tail++] = j;
                }
            }
        };
        auto discharge = [&](int i) {
            auto &v = ex[i];
            int h = height[i], nh = N;
            for (int &p = pos[i], n = G[i].size(); n--; p = (p ?: G[i].size()) - 1) {
                auto& [j, q, x] = G[i][p];
                if (!x) continue;
                if (h != height[j] + 1) { // i == sink?
                    nh = min(nh, height[j]);
                    continue;
                }
                auto f = min(v, x);
                v -= f;
                ex_add(j, f);
                x -= f;
                G[j][q].x += f;
                if(!v) return;
            }
            discharge_count++;
            if (gap_next[gap_next[N + h]] < N) {
                update_height(i, nh + 1);
                return;
            }
            for (int oldh = h; gap_highest >= oldh; gap_highest--)
                while (gap_next[N + gap_highest] < N) {
                    int j = gap_next[N + gap_highest];
                    height[j] = N + 1;
                    gap_erase(j);
                }
        };
        global_relabel();
        ex_add(src, inf);
        ex[sink] -= inf;
        while (~ex_highest) {
            int i = ex_next[N + ex_highest];
            if (i >= N) { ex_highest--; continue; }
            ex_next[N + ex_highest] = ex_next[i];
            if (height[i] != ex_highest) continue;
            discharge(i);
            if (discharge_count >= 4 * N) global_relabel();
        }
        return ex[sink] + inf;
    }
};
\end{lstlisting}

\paragraph{最小割建模}

\begin{itemize}
    \item 平面图最小割 = 最大流 = 对偶图最短路
          建立对偶图，以直线 $s - t$ 分割出的两侧为起点和终点跑最短路。
    \item 在某条件下求最大收益 = 先获得所有收益再放弃最少收益 $\Rightarrow$ 最小割
\end{itemize}

\subsubsection{最小费用最大流}
P3381 【模板】最小费用最大流-SPFA
\begin{lstlisting}
const int N=5005;
const int M=50005;
const int INF=1e9;

int n,m,s,t;
int ecnt=1,fir[N],nex[M<<1],to[M<<1],w[M<<1],c[M<<1];
int dis[N],lst[N];
int flow[N];
bool vis[N];

inline void addedge(int u,int v,int F,int C){
    nex[++ecnt]=fir[u];fir[u]=ecnt;to[ecnt]=v;w[ecnt]=F;c[ecnt]=C;
    nex[++ecnt]=fir[v];fir[v]=ecnt;to[ecnt]=u;w[ecnt]=0;c[ecnt]=-C;
}

inline bool spfa(){
    for(int i=1;i<=n;++i)dis[i]=INF;
    memset(vis+1,0,n);
    queue<int>Q;
    Q.push(s);
    dis[s]=0;
    vis[s]=1;
    flow[s]=INF;
    while(!Q.empty()){
        int x=Q.front();
        Q.pop();
        vis[x]=0;
        for(int i=fir[x],t,v;i;i=nex[i]){
            if(w[i]&&(t=dis[x]+c[i])<dis[v=to[i]]){
                dis[v]=t;
                lst[v]=i;
                flow[v]=min(flow[x],w[i]);
                if(!vis[v]){
                    vis[v]=1;
                 	Q.push(v);
                }
            }
        }
    }
    return dis[t]!=INF;
}

long long maxflow,mincost;
inline void solve(){
    while(spfa()){
        maxflow+=flow[t];
        mincost+=1ll*dis[t]*flow[t];
        for(int i=t;i!=s;i=to[lst[i]^1]){
            w[lst[i]]-=flow[t];
            w[lst[i]^1]+=flow[t];
        }
    }
}
\end{lstlisting}
P3381 【模板】最小费用最大流-Dijkstra
\begin{lstlisting}
const int N=5e3+7;
const int M=5e4+7;
const int INF=1e9;

struct Edge{
	int u,v,f,c;
}E[M<<1];

vector<int>G[N];

int n,m,s,t,ecnt=1;

inline void addedge(int u,int v,int f,int c){
	E[++ecnt]=Edge{u,v,f,c};
	G[u].push_back(ecnt);
}

typedef pair<int,int> Pair;

int h[N];
int dis[N];
int lst[N];

inline bool dijkstra(){
	for(int i=1;i<=n;++i){
		dis[i]=INF;
	}
	priority_queue<Pair,vector<Pair>,greater<Pair> >Q;
	Q.push(make_pair(dis[s]=0,s));
	while(!Q.empty()){
		int x=Q.top().second;
		int d=Q.top().first;
		Q.pop();
		if(d!=dis[x])continue;
		for(int i=0;i<G[x].size();++i){
			Edge &e=E[G[x][i]];
			int v=e.v;
			int tmp=dis[x]+h[x]-h[v]+e.c;
			if(e.f&&dis[v]>tmp&&dis[t]>tmp){
				dis[v]=tmp;
				lst[v]=G[x][i];
				Q.push(make_pair(dis[v],v));
			}
		}
	}
	return dis[t]!=INF;
}

int MinCost,MaxFlow;

inline void MCMF(){
	while(dijkstra()){
		int flow=INF;
		for(int x=t,e;x!=s;){
			e=lst[x];
			flow=min(flow,E[e].f);
			x=E[e].u;
		}
		MaxFlow+=flow;
		MinCost+=flow*(dis[t]+h[t]-h[s]);
		for(int x=t,e;x!=s;){
			e=lst[x];
			E[e].f-=flow;
			E[e^1].f+=flow;
			x=E[e].u;
		}
		for(int i=1;i<=n;++i){
			h[i]+=dis[i];
		}
	}
}

int main(){
	r(n),r(m),r(s),r(t);
	for(int i=1,u,v,c,f;i<=m;++i){
		r(u),r(v),r(f),r(c);
		addedge(u,v,f,c);
		addedge(v,u,0,-c);
	}
	MCMF();
	printf("%d %d\n",MaxFlow,MinCost);
	return 0;
}
\end{lstlisting}
\subsection{2-SAT}
有 $n$ 个布尔变量 $x_1 \sim x_n$ ，另有 $m$ 个需要满足的条件，每个条件的形式都是 $x_i$ 为 true / false 或 $x_j$ 为 true / false。
2-SAT 问题的目标是给每个变量赋值使得所有条件得到满足。
\begin{lstlisting}
vector<int>G[N]; 

int n,m,tot,dfs_clock;
int dfn[N];
int low[N];
int scc[N];
int sta[N],top;
bool in[N];

inline void addedge(int u,int v){
	if(u==v)return ;
	G[u].push_back(v);
}

void dfs(int x){
	dfn[x]=low[x]=++dfs_clock;
	sta[++top]=x;
	in[x]=1;
	for(int i=0;i<G[x].size();++i){
		int v=G[x][i];
		if(!dfn[v]){
			dfs(v);
			low[x]=min(low[x],low[v]);
		}
		else if(in[v])low[x]=min(low[x],dfn[v]);
	}
	if(dfn[x]==low[x]){
		tot++;
		int v;
		do{
			v=sta[top--];
			in[v]=0;
			scc[v]=tot;
		}while(v!=x);
	}
}

inline bool solve(){
	for(int i=1;i<=2*n;++i){
		if(!dfn[i]){
			dfs(i);
		}
	}
	for(int i=1;i<=n;++i){
		if(scc[i]==scc[i+n])return 0;
	}
	return 1;
}

int main(){
	r(n),r(m);
	for(int i=1;i<=m;++i){
		int a,b,c,d;
		r(a),r(b),r(c),r(d);
		addedge(a+(b^1)*n,c+d*n);
		addedge(c+(d^1)*n,a+b*n);
	}
	if(solve()){
		puts("POSSIBLE");
		for(int i=1;i<=n;++i){
			printf("%d ",scc[i]>scc[n+i]);
		}
	}
	else {
		puts("IMPOSSIBLE");
	}
	return 0;
}
\end{lstlisting}
\subsection{欧拉回路}
CF723E One-Way Reform\\
给出一个$n$个点$m$条边的无向图，你需要给每条边定向，使得有尽量多的点，入度等于出度，并构造方案.\\
一共有$t$组数据 $t, n <= 200$
\begin{lstlisting}
bool G[N][N];
bool vis[N];
int deg[N];
int n,m;

void dfs(int x){
	vis[x]=1;
	for(int i=0;i<=n;++i){
		if(G[x][i]){
			G[x][i]=0;
			G[i][x]=0;
			dfs(i);
			if(x&&i)printf("%d %d\n",x,i);
		}
	}
}

int main(){
    r(n),r(m);
    for(int i=1;i<=m;++i){
        int u,v;r(u),r(v);
        G[u][v]=G[v][u]=1;
        ++deg[u],++deg[v];
    }
    int ans=n;
    for(int i=1;i<=n;++i){
        if(deg[i]&1){
            G[i][0]=G[0][i]=1;
            --ans;
        }
    }
    printf("%d\n",ans);
    for(int i=0;i<=n;++i){
        if(!vis[i])dfs(i);
    }
	return 0;
}
\end{lstlisting}

\subsection{三四元环计数}
考虑求无向图三元环个数

给边定向，所有边从小度点指向大度点，度数相等时则比较编号，
可以发现我们得到了一个有向无环的新图。
原图上的三元环在新图上一定具有 $(u \to v), (v \to w), (w \leftarrow u)$ 的形式。

同时容易证明，新图上每个点的出度不超过 $O(\sqrt(m))$：
我们将度数大于 $\sqrt m$ 的称为大点，至多 $\sqrt(m)$ 个，其它点称为小点。
显然小点出边和入边之和不超过 $\sqrt m$，大点的出边指向更大的点，因此也不超过$\sqrt(m)$。

所以我们可以枚举 $(u \to v)$，再枚举$(v \to w)$，$O(1)$检查是否存在$(u \to w)$。
对$v$的每条入边 $(u \to v)$，检查了$outdeg(v)$ 次，因此总复杂度不超过 $O(m\sqrt(m))$。

\begin{lstlisting}
inline long long calc3() {
    long long ans = 0;
    for(int u=1;u<=N;++u) { \\ 枚举所有点
        for(auto v: H[u]) vis[v] = 1; \\ 打上标记
        for(auto v: H[u])  \\ 枚举v
            for(auto w: H[v]) \\ 枚举w
                if(vis[w]) ++ans; 
        for(auto v: H[u]) vis[v] = 0; \\ 清空标记   
    }  
    return ans;
}
\end{lstlisting}

对有向图，当成无向图做然后检查每个三元环是否合法即可。

对于无向图四元环计数，我们有类似技巧。
同样方法排序，得到每个点的排名，从排名小的指向排名大的。

我们考虑 $a,b,c,d$ 四个点，假设排名最大的点是 $d$，
那么我们首先枚举一个点 $u$（实际上就是 $b$ 点），枚举原图中的一条边$(u \to v)$ 可以找到 $a, c$，
由于满足条件的 $d$ 只有入边，所以枚举新图中的一条边$(v \to w)$，即可找到 $d$，
同时为了保证 $d$ 排名最大，需要检查满足 $rk_w > rk_u$。
对这样任意两个不同的三元组 $u(b), v, v(d)$，都会形成四元环，因此在 $d$ 开个计数器，每次答案加上计数器的值，同时计数器自增。

\begin{lstlisting}
inline long long calc4() {
    long long ans = 0;
    for(int u=1;u<=N;++u) {
        for(auto v: G[u]) //原图上的边
            for(auto w: H[v]) //新图上的边
                if(cmp(u,w)) (ans += vis[w] ++)%=MOD;
        for(auto v: G[u])
            for(auto w: H[v])
                if(cmp(u,w)) vis[w] = 0;
    }
    return ans;
} 
\end{lstlisting}
\section{动态规划}
\subsection{决策单调性}

\paragraph{CF868F} 

给一个长度为 $n$ 的序列，将其分为 $m$ 段，每段的代价是段中 $a_i = a_j, i < j$ 的 $(i, j)$ 对数。
求最小代价。

显然可以写出 $dp$ 方程：$dp[i][j] = \min_{1 \le k \le i}\{dp[k - 1][j - 1] + \omega(k, i)\}$

其中 $dp[i][j]$ 表示前 $i$ 个数分 $j$ 段的最小代价，$\omega(l, r)$ 表示 $[l, r]$ 段的代价。

可以发现，对于 $\omega(l_1, r), \omega(l_2, r), l_1 < l_2$，
当 $r$ 增加时，$\omega(l_1, r)$ 增速更快，因此 $i$ 增大时决策点只会向右移动。

但是由于不知道怎么得到最优决策点，采用分治策略，即每次选中点暴力求出最优决策点，然后递归到两侧求解。

由于 $\omega$ 不方便 $O(1)$ 计算，采用类似莫队的方法移动指针维护，显然移动次数与区间长度同阶，复杂度正确。

\begin{lstlisting}
#include<bits/stdc++.h>

using namespace std;

#define gc c=getchar()
#define r(x) read(x)
#define ll long long

template<typename T>
inline void read(T &x){
	x=0;T k=1;char gc;
	while(!isdigit(c)){if(c=='-')k=-1;gc;}
	while(isdigit(c)){x=x*10+c-'0';gc;}x*=k;
}

const int N = 1e5 + 7;
const ll INF = 1e18;

int a[N];

ll ans;
int nowl = 1, nowr = 0;
int cnt[N];

inline ll calc(int l, int r){
	while(nowl > l) ans += cnt[a[--nowl]]++;
	while(nowr < r) ans += cnt[a[++nowr]]++;
	while(nowl < l) ans -= --cnt[a[nowl++]];
	while(nowr > r) ans -= --cnt[a[nowr--]];
	// cerr << l << " " << r << " " << ans << endl;
	return ans;
}

inline void solve(ll *f, ll *g, int l, int r, int x, int y){
	if(l > r) return ;
	int pos = 0;
	int mid = (r + l) >> 1;
	g[mid] = INF;
	for(int i = x; i <= min(mid - 1, y); ++i){
		ll tmp = f[i] + calc(i + 1, mid);
		if(g[mid] > tmp){
			g[mid] = tmp;
			pos = i;
		}
	}
	solve(f, g, l, mid - 1, x, pos);
	solve(f, g, mid + 1, r, pos, y); 
}

ll f[21][N];

int main(){
	// freopen(".in","r",stdin);
	// freopen(".out","w",stdout);
	int n, m; r(n), r(m);
	for(int i = 1; i <= n; ++i){
		r(a[i]);
		f[1][i] = calc(1, i);
	}
	for(int i = 1; i < m; ++i){
		solve(f[i], f[i + 1], 1, n, 1, n);
	}
	printf("%lld\n", f[m][n]);
	return 0;
}
\end{lstlisting}
\section{奇技淫巧}
\subsection{O(n)整形排序}
\begin{lstlisting}
typedef unsigned int u32;

namespace Sorting { //两倍数组
    int cnt0[256],cnt8[256],cnt16[256],cnt24[256];
    inline void Sort(u32 *a, int n) {
        const u32 *ed=a+n;
        u32 *b=a+n;
        for(u32*i=a;i!=ed;++i){
            ++cnt0[*i&255];
            ++cnt8[*i>>8&255];
            ++cnt16[*i>>16&255];
            ++cnt24[*i>>24];
        }
        for(int i=1;i<256;++i){
            cnt0[i]+=cnt0[i-1];
            cnt8[i]+=cnt8[i-1];
            cnt16[i]+=cnt16[i-1];
            cnt24[i]+=cnt24[i-1];
        }
        register u32*i;
        for(i=a+n-1;i>=a;--i){ //可循环展开
            b[--cnt0[*i&255]]=*i;
        }
        for(i=b+n-1;i>=b;--i){
            a[--cnt8[*i>>8&255]]=*i;
        }
        for(i=a+n-1;i>=a;--i){
            b[--cnt16[*i>>16&255]]=*i;
        }
        for(i=b+n-1;i>=b;--i){
            a[--cnt24[*i>>24]]=*i;
        }
    }
}
\end{lstlisting}
\subsection{O(1)快速乘}
\begin{lstlisting}
inline ll mul(ll a,ll b,ll mod){
	return (a*b-(ll)((long double)a/mod*b)*mod+mod)%mod;
}
\end{lstlisting}
\subsection{奇妙库函数}
\subsubsection{bitset操作}
\begin{itemize}
    \item \texttt{\_Find\_fisrt()}: 找到从低位到高位第一个$1$的位置
    \item \texttt{\_Find\_next(x)}: 找到从低位到高位下一个$1$的位置
    \item \texttt{size()}: 返回大小（位数）
    \item \texttt{count()}: 返回$1$的个数
    \item \texttt{any()}: 返回是否有$1$
    \item \texttt{none()}: 返回是否没有$1$
    \item \texttt{set()}: 全都变成$1$
    \item \texttt{set(p)}: 将第$p + 1$位变成$1$
    \item \texttt{set(p, x)}: 将第$p + 1$位变成$x$
    \item \texttt{reset()}: 全都变成$0$
    \item \texttt{reset(p)}: 将第$p + 1$位变成$0$
    \item \texttt{flip()}: 全都取反
    \item \texttt{flip(p)}: 将第$p + 1$位取反
    \item \texttt{to\_ulong()}: 返回它转换为unsigned long的结果，如果超出范围则报错
    \item \texttt{to\_ullong()}: 返回它转换为unsigned long long的结果，如果超出范围则报错
    \item \texttt{to\_string()}: 返回它转换为string的结果
\end{itemize}

\subsubsection{builtin系列}
\begin{itemize}
    \item \texttt{\_\_builtin\_popcount(x)}: 返回$1$个数
    \item \texttt{\_\_builtin\_clz(x)}: 返回高位(前导)$0$个数
    \item \texttt{\_\_builtin\_ctz(x)}: 返回低位(末尾)$0$个数
    \item \texttt{\_\_builtin\_parity(x)}: $1$个数奇偶性
    \item \texttt{\_\_builtin\_ffs(x)}: 最后一个$1$是从后往前第几位
    \item \texttt{\_\_builtin\_expect(exp,c)}: 用来引导gcc进行条件分支预测
    
\begin{lstlisting}
    if (__builtin_expect (ptr != NULL, 1))
        foo (*ptr);
\end{lstlisting}
表示ptr一般不会为NULL，所以foo函数得到执行的概率较大
    
    \item \texttt{\_\_builtin\_bswap32(x)}: $32$位数按字节翻转
    \item \texttt{\_\_builtin\_types\_compatible\_p(type1, type2)}: 判断type1和type2是否是相同的数据类型，相同返回1，否则返回0
    \item \texttt{\_\_builtin\_return\_address(n)}: 当前函数的第$n$级调用者的地址，\_\_builtin\_return\_address(0)获得当前函数的调用者的地址
\end{itemize}
类型为\texttt{long long}时需要在后面加\texttt{ll} 
\subsection{编译命令}
\begin{itemize}
    \item -g
    \item -O2
    \item -std=c++17
    \item ulimit -s (102400/unlimited)
    \item -fsanitize=address
    \item -fsanitize=undefined
    \item -ftrapv
\end{itemize}

\end{document}